#!/usr/bin/python
import sys
sys.path.append('/opt/nextest/lib/')
import logging
import socket
import os
import unittest
#from   qm.test import *
from  qm.test.result import *

#Enhancement for the MSX 6.0 CDR Streaming Feature
#PR 133009
#Code for reading the cdrs and the radius packets and matching their values
#if the values mismatch, the test case is marked as FAIL

#mapping for the radius and cdr field for filed 85
#cdr: radius  as - source  : 2 destination : 4 internal : 6
field_85={'source':'2','destination':'4','internal':'6'}

class CdrMappingError(Exception):
    "General exception for CDR Mapping"

class CdrMapping(object):
    
    def __init__(self,context,result):
        
        self.mappingFile="/opt/nextest/lib/python2.3/site-packages/mapping-6.0"
        self.log = logging.getLogger('nextestlog')
        try:
            self.mswip=socket.gethostbyname('mymsw') 
        except socket.gaierror, exc:
            errnum, errstr = exc
            raise Exception('Exception: %s -  Error retrieving address for %s' %(str(exc),name))
        
        self.path=context['nextest.result_path']
	
        cdr_temp=result[result.NEXTEST_CDR].split('.')[0]

        testcaseid=context['qmtest.id']
        #print cdr_temp
        
         
	self.localInterimCdr=self.path+'/'+cdr_temp+"_interim.dat"
        self.cdrfile=self.path+'/'+cdr_temp+".decode"


        self.remoteInterimCdr=None
        prefix=context['qmtest.id'].replace('.', '-')
        self.radiusfile=self.path+"/rad-pkt.log"
        self.copyRadfile=self.path+"/"+prefix+"_rad.log"
        self._moveRadPkt()
            
        #Adding support for bkup cdr
        self.bkupcdrfile=self.path+'/'+prefix+"_bkupcdr.decode"
        #print self.bkupcdrfile
        	
        if context.has_key('cdrCurrentPath'):
            remoteCdrPath=context['cdrCurrentPath']
            self.remoteInterimCdr=remoteCdrPath.split('.')[0]+'.CIT'
        self.result=result
        self.fieldsToCompare = []
        	

    
    def match(self,interimTimer=None):
	cdrInterim=None
        if (interimTimer != None) and (interimTimer != '0'):
	    try:
                self._copyInterimCdr(self.remoteInterimCdr,self.localInterimCdr)
                cdrInterim=self._decodeInterimCdr(self.localInterimCdr)
	        self.log.info("Copied and decoded interim cdrs at %s" %cdrInterim)
	        #print ("Copied and decoded interim cdrs at %s" %cdrInterim)
	    except Exception,e:
                # takes care if there is problem in logline
                msg = 'Exception:%s  ' % str(e)
                self.log.error(msg)
        
	ret = self._matchRadiusandCdr(self.radiusfile,self.cdrfile,self.result,cdrInterim)
	if (ret == 1):
            self.result.Annotate({'No CDR Matching,Files missing':'%s:%s' %(self.radiusfile,self.cdrfile)})
            print ('No CDR Matching,Files missing %s:%s' %(self.radiusfile,self.cdrfile))
        
        #self._moveRadPkt()

    #PR 151806
    def matchCdrFields(self,cdrtype,cdrFields,interimTimer=None):
        """ 
        Function to match specific fields of cdr and radius packets
        when the input is the cdr field list
        """
        fieldsToMatch=[]
            
	cdrInterim=None
        if (interimTimer != None) and (interimTimer != '0'):
	    try:
                self._copyInterimCdr(self.remoteInterimCdr,self.localInterimCdr)
                cdrInterim=self._decodeInterimCdr(self.localInterimCdr)
	        self.log.info("Copied and decoded interim cdrs at %s" %cdrInterim)
	        #print ("Copied and decoded interim cdrs at %s" %cdrInterim)
	    except Exception,e:
                # takes care if there is problem in logline
                msg = 'Exception:%s  ' % str(e)
                self.log.error(msg)

        if (cdrFields == None):
            msg="The cdr fields to be matched are not specified"
            self.log.error(msg)
        else:
            matchType = "cdr"
            if isinstance(cdrFields,str) :
                fieldsToMatch = [cdrFields]
            else:
                fieldsToMatch = cdrFields
            ret = self._matchField(cdrtype,matchType,fieldsToMatch,cdrInterim)
	    if (ret == 1):
                self.result.Annotate({'No CDR Matching,Files missing':'%s:%s' %(self.radiusfile,self.cdrfile)})

    #PR 151806
    def matchRadiusFields(self, cdrtype,radiusFields,interimTimer=None):
        """ 
        Function to match specific fields of cdr and radius packets
        when the input is the radius field list
        """
	cdrInterim=None

        fieldsToMatch=[]

        if (interimTimer != None) and (interimTimer != '0'):
	    try:
                self._copyInterimCdr(self.remoteInterimCdr,self.localInterimCdr)
                cdrInterim=self._decodeInterimCdr(self.localInterimCdr)
	        self.log.info("Copied and decoded interim cdrs at %s" %cdrInterim)
	        print ("Copied and decoded interim cdrs at %s" %cdrInterim)
	    except Exception,e:
                # takes care if there is problem in logline
                msg = 'Exception:%s  ' % str(e)
                self.log.error(msg)

        if (radiusFields == None):
            msg="The radius fields to be matched are not specified"
            self.log.error(msg)
        else:
            matchType = "radius"
            if isinstance(radiusFields,str) :
                fieldsToMatch = [radiusFields]
            else:
                fieldsToMatch = radiusFields
            ret = self._matchField(cdrtype,matchType,fieldsToMatch,cdrInterim)
	    if (ret == 1):
                self.result.Annotate({'No CDR Matching,Files missing':'%s:%s' %(self.radiusfile,self.cdrfile)})


    def _copyInterimCdr(self,remoteInterimCdr,localInterimCdr):
        """
        Function to copy the interim cdrs from the MSX to the local gen machine
    
        remoteInterimCdr -- Path of the interim cdr on the remote machine
        localInterimCdr -- Path on the local machine(syntax" *_interim.dat
    
        """
        remotepath =  'root@%s:%s' % (self.mswip, remoteInterimCdr)
        cmd = 'scp -q %s %s  > /dev/null 2>&1' %  (remotepath,localInterimCdr)
        self.log.debug("Copying %s" % cmd)
        os.system(cmd)
    
    def _decodeInterimCdr(self,interimcdr):
        """
        Function to decode the copied interim cdr in to the readable format.

        interimcdr -- Path of the interm.dat file on the gen machine.
        """
    
   
        decodepath=interimcdr.split('.')[0]+".decode"
        # Prep (strip empty records from) the interim CDR file
	if os.path.isfile(interimcdr):
            i_fd = open(interimcdr, 'r')
            interimlist = i_fd.readlines()
            i_fd.close()
            interimlist = [x for x in interimlist if len(x) > 1]
            i_fd = open(interimcdr, 'w')
            i_fd.writelines(interimlist)
            i_fd.close()
    
            cmd='cat %s | /tmp/cdr_decode.pl > %s' %(interimcdr,decodepath)
            os.system(cmd)
	    return decodepath
        else:
            msg = "Failed to open file %s" % decodepath
            self.log.error(msg)
            raise CdrMappingError(msg)

    def _moveRadPkt(self):

	if os.path.isfile(self.radiusfile):
            cmd = 'mv %s %s' %  (self.radiusfile,self.copyRadfile)
            self.log.debug("Copying %s" % cmd)
            os.system(cmd)
        self.radiusfile=self.copyRadfile


    def readMapping(self):
        """
        Read the Mapping file for the cdr and radius packet field match
        Each field is added to the cdrmap List
        """ 
        cdrmap=[]
        fd=open(self.mappingFile,"r")
        for line in fd :
            line=line.strip()
            if len(line)==0:
                continue
            t1=line.split(":")
            inx=int(t1[0])
            sublist=t1[1].split(";")
            cdrmap.append(sublist)
        return cdrmap

    
    
    def _readFile(self,filename,type,ListofList):
        """
        This function reads the cdr/radius file and puts the values in datastructures.
        Each key value pair read from the cdr/radius file is stored in a dictionary element which in turn is
        added to a List(DictList).
        For each cdr and radius packet there will be one element in ListofList.
    
        filename: name of file to be read
        type: cdr/rad - type of file being read
	List of Lists : This has all the cdrs read and sublist of each cdr name value pair
        """

        fd=open(filename,"r")
        #List of dictionary 
        DictList=[]
        #Counters
        iter_sub=0
        count=0
        index=0
        
        for line in fd :
            line=line.strip()
            if len(line)==0:
                count=count+1
            if (count == 1):
                continue;

            if (count == 2):
                ListofList.insert(iter_sub,DictList)
                DictList=[]
                iter_sub = iter_sub+1
                count=0
                continue;
            # Function for decoding each cdr line
            if (type=="cdr"):
                index,dict_temp=self._decodeCDRLine(line)
                DictList.insert(index,dict_temp)
		
            # Function for decoding each radius line
            if (type=="rad"):
                typeofrad,dict_temp=self._decodeRADLine(line)
		
                # Add the dictionary to the list
                if (dict_temp!=None):
                    DictList.append(dict_temp)



    def _decodeRADLine(self,line):
        """
        This function decodes each line of the file which has the radius packets and
        returns a dictionary
        """
        
        dict_temp={}
        line=line.strip()
        t1=line.split(": ")
        key=t1[0].strip()
        m=t1[1].strip('\[\'')
        value=m.strip('\'\]')
        typeofrad="default"
    
        # code for the combined parameters coming in (9L,1)
        if key.__contains__("9L"):
            subresult=value.split("\', \'")
            for i in subresult:
                pair=i.split("=")
                if (len(pair[1])!=0):
                    key=pair[0].strip()
                    value=pair[1].strip()
                    dict_temp[key]=value
            return typeofrad,dict_temp        
        
        elif value.__contains__("="):
             temp=value.split("=")
             if (len(temp[1])!=0):
                value=temp[1]
    
        if value.endswith('L'):
            value=value.rstrip('L')

        dict_temp={key:value}

        return typeofrad,dict_temp
        
    def _decodeCDRLine(self,line):
        """
        This function decodes each line of the file which has the decoded cdr values and
        returns a dictionary
        """
            
        dict_temp={}
        line=line.strip()
        t1=line.split(":",1)

        index=int(t1[0])
        sublist=t1[1].split("=")
        if len(sublist[1].strip())!=0:
            dict_temp={sublist[0].strip():sublist[1].strip()}
            return index,dict_temp
        else:
            return index,dict_temp



    def _findval(self,key,List):
        """
        This function finds the value of a key in the List of dictionaries.
          
        returns a string
        """

        for i in List:
            if i.has_key(key):
                return i[key]
        
       
        
    def _compareAll(self,cdrmap,cdrList,radList,result,interim=0):
        """
        This function parses the mapped value list of cdr and radius(cdrmap)
        For each entry in the cdrmap, finds the corresponding value in the cdrList and in the radList
        On getting the values, compares them and pass the FAIL/PASS Verdict
    
        """
        flag=0
        counter=1
   
        for i in xrange(1,len(cdrmap)):
            # continue if the cdr is empty
            if (len(cdrList[i]) == 0):
                continue;
            else:
                mapping=cdrmap[i]
                cdrKey=mapping[0]
                cdr=cdrList[i][cdrKey]
                rad=self._findval(mapping[1],radList)
                counter = counter + 1
                # special handling for not comparing the 11 field of cdr as it is unused 
		# and MSX has a bug for sending value in it
                if (i==11):
                    continue
	        #Incase of interim cdrs  donot compare the field 35(Account-Session-Info)
                if (interim==1):
                    if(i==35): 
                        continue
		# if the cdr field is filled and radius field is empty
                if ((cdr != None)and(rad==None)):
                    self.log.error("EMPTY RADIUS field '%s', cdr field is %s:%s" %(rad,i,cdr)) 
                    flag=1
                    continue
	        # If both the fields are filled
                elif ((cdr !=None)and(rad!=None)):
                    if (cdrKey=='call-release-source'):
                        cdr=field_85[cdr]
		    if (cdrKey=='protocol') and (cdr=='h323'):
		        cdr='H.323'

                    if (cdr.lower()!=rad.lower()):
                        self.log.error ("VALUE MISMATCH:cdr field %s:%s and radius field %s:%s " %(cdrKey,cdr,mapping[1],rad)) 
                        print ("VALUE MISMATCH:cdr field %s:%s and radius field %s:%s " %(cdrKey,cdr,mapping[1],rad)) 
                        flag=1
                        continue
                 
                    else:
                        self.log.debug ("MATCH:cdr field %s:%s and radius field %s:%s " %(cdrKey,cdr,mapping[1],rad)) 
                        #print ("MATCH:cdr field %s:%s and radius field %s:%s " %(cdrKey,cdr,mapping[1],rad)) 
    
        if (flag==1):
            return "field_mismatch"
        return  0
    
    def _segregatePackets(self,cdrmap,cdrList,radList):
        """
        This function seggregates 
    
        """
        #match field 24 and 39 and put the counts in dictionary
        matchDict={}
        interimList=[]
        # Find the mapping field of call-id in mapping file
        mapping_call_id=cdrmap[23]
        # Find the mapping field of cdr-type in mapping file
        mapping_cdrtype=cdrmap[38]
        mapping_msxname=cdrmap[48]	
        for x in xrange(len(radList)):
            rad_type=self._findval(mapping_cdrtype[1],radList[x])
            if (rad_type=='interim'):
                interimList.append(radList[x])
                

        # For each cdr in the cdrList, find the values of the call-id and the 
        # cdr-type and match with the values of the corresponding radius field
        # adding msw-name to match the packets
        for i in xrange(len(cdrList)):
            cdr_confid=self._findval(mapping_call_id[0],cdrList[i])
            cdr_type=self._findval(mapping_cdrtype[0],cdrList[i])
            msx_id=self._findval(mapping_msxname[0],cdrList[i])
   
            # Iteration though all the radius packets to find the match
            for x in xrange(len(radList)):
                rad_confid=self._findval(mapping_call_id[1],radList[x])
                rad_type=self._findval(mapping_cdrtype[1],radList[x])
                rad_msx=self._findval(mapping_msxname[1],radList[x])
                #print "%s:%s" %(rad_msx,msx_id )
                # If both call-id and the cdrtype match, append the count in a dict to be
                # used later
                if ((cdr_confid==rad_confid)and(cdr_type==rad_type)and(msx_id==rad_msx)):
                    self.log.debug("Matching Sequence is %s:%s" %(i,x))
                    #print("Matching Sequence is %s:%s" %(i,x))
                    matchDict[i]=x
            
    
        return interimList,matchDict          
            

    def _matchRadiusandCdr(self,radiusfile,cdrfile,result,interimpath=None):
        """
        This function matches the cdr and the radius packets
        The calling function need to pass these parameters 
        
        radiusfile: the path of the file which has the radius packets dumped
        cdrfile: the path of the decoded cdr file which is present in the result path
        result: qmtest result context variable. 

        """
        #Read the file which has the cdr field and radius field mapping
        cdrmap=self.readMapping()
        cdrList=[]
        radList=[] 
        interimCdr=[]
        bkupCdrList=[]
	
	if not os.path.isfile(cdrfile) or not os.path.isfile(radiusfile) :
	    self.log.error("Either cdrfile %s or radiusfile %s DONOT exist\n. No CDR AND RADIUS Matching" %(cdrfile,radiusfile))
	    return 1

        self._readFile(cdrfile,"cdr",cdrList)
        self._readFile(radiusfile,"rad",radList)
        
        if  os.path.isfile(self.bkupcdrfile):

            self._readFile(self.bkupcdrfile,"cdr",bkupCdrList)


            print len(bkupCdrList)
            # if bkupCdrList is not empty, append it to main cdr file
            for i in range(0,len(bkupCdrList)):
                cdrList.append(bkupCdrList[i])


        #interim cdr handling
        if (interimpath != None):
            self._readFile(interimpath,"cdr",interimCdr)
        
     
        if ((len(cdrList)+len(interimCdr)) !=  len(radList)):
            self.log.error('Mismatch in number of cdrs and the radius packets %s:%s' %(len(cdrList)+len(interimCdr),len(radList)))
            #print ('Mismatch in number of cdrs and the radius packets %s:%s' %(len(cdrList)+len(interimCdr),len(radList)))
            result.Annotate({'Mismatch in number of cdrs and the radius packets':'%s:%s' %((len(cdrList)+len(interimCdr)),len(radList))})
            result.Fail('Radius and Cdr COUNT MISMATCH ')
            return 2
        #Function to seggregate the cdrs and the radius packets
	# this returns a dictionary of the corresponding packets
        interimRad,matchDict=self._segregatePackets(cdrmap,cdrList,radList)
   
        for  iter in matchDict.iteritems():
            cdrnum=iter[0]
            radnum=iter[1]
            res=self._compareAll(cdrmap,cdrList[cdrnum],radList[radnum],result)
            if (res=="field_mismatch"):
                result.Fail('Radius and Cdr VALUE MISMATCH')
        
	#interim cdr handling
        if (interimpath !=None):
            for i in xrange(len(interimCdr)):
                res=self._compareAll(cdrmap,interimCdr[i],interimRad[i],result,interim=1)
                if (res=="field_mismatch"):
                    result.Fail('Radius and Cdr VALUE MISMATCH in INTERIM CDR')
        



    #PR 151806    
    def _matchField(self,cdrtype,matchType,fieldsToMatch,interimpath=None):
        """
        This function is for comparing the selective fields (cdr or radius)
        provided as input from the testcase.
        """

        radiusfile = self.radiusfile
        cdrfile = self.cdrfile 
        result = self.result
        self.fieldsToCompare = fieldsToMatch
        self.cdrmap=self.readMapping()

        cdrList=[]
        radList=[]
        interimCdr=[]



        if not os.path.isfile(cdrfile) or not os.path.isfile(radiusfile) :
            self.log.error("Either cdrfile %s or radiusfile %s DONOT exist\n. No CDR AND RADIUS Matching" %(cdrfile,radiusfile))
            return 1

        self._readFile(cdrfile,"cdr",cdrList)
        self._readFile(radiusfile,"rad",radList)

        #interim cdr handling
        if (interimpath != None):
            self._readFile(interimpath,"cdr",interimCdr)


        if ((len(cdrList)+len(interimCdr)) !=  len(radList)):
            self.log.error('Mismatch in number of cdrs and the radius packets %s:%s' %(len(cdrList)+len(interimCdr),len(radList)))
            result.Annotate({'Mismatch in number of cdrs and the radius packets':'%s:%s' %((len(cdrList)+len(interimCdr)),len(radList))})
            result.Fail('Radius and Cdr COUNT MISMATCH ')
            return 2
        #Function to seggregate the cdrs and the radius packets
        # this returns a dictionary of the corresponding packets
        interimRad,matchDict=self._segregatePackets(self.cdrmap,cdrList,radList)

        # Iterate the dictionary and extract the cdr and radius sub dicts
        for  iter in matchDict.iteritems():
            cdrnum=iter[0]
            radnum=iter[1]

            #Compare the value of cdrtype in all the cdrs collected to select the correct cdr
            if (matchType == "cdr"):
                cdr=self._findval('cdr-type',cdrList[cdrnum])
                if (cdr==cdrtype):
                    res=self._compareField(cdrList[cdrnum],radList[radnum],matchType,result)
                    if (res=="field_mismatch"):
                        result.Fail('Radius and Cdr VALUE MISMATCH')

            elif (matchType == "radius"):
                rad=self._findval('cdr-type',radList[radnum])
                if (rad==cdrtype):
                    res=self._compareField(cdrList[cdrnum],radList[radnum],matchType,result)
                    if (res=="field_mismatch"):
                        result.Fail('Radius and Cdr VALUE MISMATCH')



    #PR 151806    
    def _compareField(self,cdrList,radList,matchType,result):
        """
        This function is for comparision logic of the selective fields (cdr or radius)
        provided as input from the testcase.
        """

        flag=0
        counter = 0
        #print self.fieldsToCompare
        for i in xrange(1,len(self.cdrmap)):
            # continue if the cdr is empty
            if (len(cdrList[i]) == 0):
                continue;
            else:
                mapping=self.cdrmap[i]
                cdrKey=mapping[0]
                radKey =mapping[1]
                if (matchType == "cdr"):
                   key = cdrKey
                elif (matchType == "radius"):
                   key = radKey
                for element in self.fieldsToCompare:
                    if (key==element):
                       ## special handling for not comparing the 11 field of cdr as it is unused
                       ## and MSX has a bug for sending value in it
                       if (i==11):
                            continue
                       cdr=cdrList[i][cdrKey]
                       rad=self._findval(radKey,radList)
                       if ((cdr != None)and(rad==None)):
                           self.log.error("EMPTY RADIUS field '%s', cdr field is %s:%s" %(rad,i,cdr))
                           flag=1
                           continue
                       ## If both the fields are filled
                       if ((cdr !=None)and(rad!=None)):
                           if (cdrKey=='call-release-source'):
                               cdr=field_85[cdr]
                           if (cdrKey=='protocol') and (cdr=='h323'):
                               cdr='H.323'

                           if (cdr.lower()!=rad.lower()):
                              self.log.error ("VALUE MISMATCH:cdr field %s:%s and radius field %s:%s " %(cdrKey,cdr,mapping[1],rad))
                              flag=1
                              continue
                           else:
                              self.log.debug ("MATCH:cdr field %s:%s and radius field %s:%s " %(cdrKey,cdr,mapping[1],rad))
                              #print ("MATCH:cdr field %s:%s and radius field %s:%s " %(cdrKey,cdr,mapping[1],rad))
                              #print cdr,rad
                              counter = counter + 1
                        
        if (flag==1):
            return "field_mismatch"
        return  0
               
 

class utCdrMapping(unittest.TestCase):

    def test1(self):
   
        self.log = logging.getLogger('nextestlog')
         
        dummy_result=Result(Result.TEST,'Unit')
        context={}
        dummy_result[Result.NEXTEST_CDR]="production_components-rad_accounting-enhanced_rad_accounting-obp-radac_id_16_100768_cdr.decode"
        context['qmtest.id']="production_components-rad_accounting-enhanced_rad_accounting-obp-radac_id_16_100768"
        context['nextest.result_path']="/var/opt/nextest/tdb/results/20101207_0311"
        context['cdrCurrentPath']="/var/cdrs/D20101207.CDT"

        mapping=CdrMapping(context,dummy_result)
        print mapping.match()
        cdrtype="end1"
        #cdr=['cdr-seq-no','cdr-type','msw-name']
        cdr = 'cdr-seq-no' 
        print mapping.matchCdrFields(cdrtype,cdr)
        rad='hold-time'
        print mapping.matchRadiusFields(cdrtype,rad)
        #pass 

if __name__ == '__main__':
    unittest.main()
   

#main() 
