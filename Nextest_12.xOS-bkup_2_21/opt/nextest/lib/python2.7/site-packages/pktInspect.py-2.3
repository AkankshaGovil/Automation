
import os
import sys
from socket import gethostbyaddr
from socket import gethostbyname
import etherealXml
import unittest
import logging
import time

class pdmlPacketError(Exception):
    "General exception for pdml packet inspection"

class PacketCollection(object):
    """ 
      Base Class for Packet handling
    """

    def __init__(self, packets):
        self.packets = packets

    def filterPacket(self, fields):
        filteredPacket = []
        for packet in self.packets:
            frameNumber = packet.getFieldFirstValue('frame.number')

            isPacketIncluded = True
            for key in fields.keys():
                actualValue = packet.getFieldFirstValue(key)
                if actualValue not in fields[key]:
                    isPacketIncluded = False
                    break

            if isPacketIncluded == True:
                filteredPacket.append(packet)

        return filteredPacket


class readCapture(PacketCollection):
  """
    Reads PCAP file and converts the packets and fields into python objects for
    easy assertions in test cases. It converts PCAP file into  pdml format, using 
    ethereal version 10.13. Then it use XML parsing to convert the converted file
    into python objects.
  """

  def __init__(self, fileName,includertp=False):
        """ 
          if necessary converts pcap file into pdml file and reads pdml file into variable packets.
          Calls __processPackets for postprocessing.
        """
        self.PacketList = []
        self.endpoints = {}
        # 58253 changes
        self.pdmlFilepath = fileName
        self.log = logging.getLogger('nextestlog')
	#45468 changes
	self.includertp = includertp

        self.tempFile = None
        pdmlFileName = fileName
        if fileName.endswith('.pcap'):
            self.tempFile = os.tempnam() 

            os.system('tethereal -Tpdml -r %s > %s' % (fileName, self.tempFile))

            if not os.path.isfile(self.tempFile):
                raise EnvironmentError, 'tethereal could not create %s file' % self.tempFile
            pdmlFileName = self.tempFile

        fh = open(pdmlFileName)

        self.PacketList = []
        etherealXml.parse_fh(fh, self.pdmlCallback)
        self.packets = self.PacketList
        self.__processPackets()

        fh.close()

        if self.tempFile != None:
            os.remove(self.tempFile)
  
  # 58253 changes
  def getpdmlfilepath(self):
        return self.pdmlFilepath

  def __processPackets(self):
        """
          sorts all packets into Endpoints
        """

        endpointList = {}
        for packet in self.packets:
          for addr_type in ['ip.src', 'ip.dst']:
            ip = packet.getFieldFirstValue(addr_type)
            if ip != None:
              # Ticket 18956 changes
              try:
                  hostname, alias, iplist = gethostbyaddr(ip)
              except Exception, e:
                  #self.log.error("Error - %s - hostname %s can not be resolved" %(str(e),ip))
                  hostname = ip
              if hostname not in endpointList:
                  endpointList[hostname]=[]
              endpointList[hostname].append(packet)
              
        for host in endpointList:
	  #45468 changes
          self.endpoints[host] = Endpoint(endpointList[host],self.includertp)

        

  def printEndpoints(self):
       """
         prints a list a summery of all endpoints and the number of packets per endpoint
       """
       for endpoint in self.endpoints.keys():
         print "Endpoint %s, nPackets=%d" %(endpoint, len(self.endpoints[endpoint].packets) )


  def pdmlCallback(self, packet):
    """Callback function called by etherealXml module at the end of each packet. This
    function will first filter out the uninteresting packets. For better performance,
    it is recommended that ethereal filters should filter out most of these packets because
    it is a bit expensive to filter them at PDML level.
    """

    # 30978 - Include radius packets
    # 43816 - Include snmp packets
    keepPacketTypes = ['h225', 'sip','h245','dns','radius','snmp','tcp','sctp']
    #45468 changes
    if self.includertp:
        keepPacketTypes = ['h225', 'sip','h245','dns','radius','rtp','snmp','tcp','sctp']
	    
    discardPacket = True
    for packetType in keepPacketTypes:
        if packet.item_exists(packetType):
            discardPacket = False
            break

    if discardPacket:
        child = []
        packet.get_items('frame.number', child)
        #print 'Discarding frame %s' % child[0].get_show()
        return

    self.PacketList.append(packet)


class Endpoint(PacketCollection):
  """ 
    Takes all Packets addressed from or to a Endpoint.
    Packets will be categorizated into SIP, H323
  """

  def __init__(self, packets,includertp=False):
    """
      initialize Endpoint class and sorts packets into sip, h323 and dns lists
    """
   
    self.packets = packets

    #29925 - Modified to filter h245 packets
    #30978 - Sort the radius packets
    #43816 - snmp packets
    # - Added code for TLS packet verifications in form of TCP packets
    packetTypes = {'sip' : [], 'h225' : [], 'dns' : [], 'h245' : [], 'radius' : [], 'snmp' : [], 'tcp' : [] , 'sctp' : []}
    #45468 - Include rtp packets
    if includertp:
      packetTypes = {'sip' : [], 'h225' : [], 'dns' : [], 'h245' : [], 'radius' : [],'rtp' :[], 'snmp' :[], 'tcp' : [], 'sctp' : []}
	    
    for packet in self.packets:
      for packetType in packetTypes:
        if packet.item_exists(packetType):
          packetTypes[packetType].append(packet)
          # 36319 - H225 packets also contain H245 information in some cases. Hence
          # such packets should be filtered under both h225 and h245 lists. 
          #break

                 
    self.sip = SipOnly(packetTypes['sip'])
    self.h323 = h323Only(packetTypes['h225'])
    self.dns = DnsOnly(packetTypes['dns'])
    #29925 - Added to filter h245 packets
    self.h245 = h245Only(packetTypes['h245'])
    # 30978 - Put the radius packets in a list
    self.radius = packetTypes['radius']
    # PR 133010 - Count radius packets
    self.radius_count = radiusOnly(packetTypes['radius'])
    # 43816 - Put the snmp packets in a list
    self.snmp = packetTypes['snmp']
    # - Added code for TLS packet verifications
    self.tcp = TlsOnly(packetTypes['tcp'])
    # 52678 - Put the sctp packets in a list
    self.sctp = sctpOnly(packetTypes['sctp'])
    #45468 changes - filter rtp packets 
    if includertp:
        self.rtp = packetTypes['rtp']

  def printPackets(self):
    """
      print a summery of the sip packets
    """
    for packet in self.packets:
      frameNumber = packet.getFieldFirstValue('frame.number')
      sipMethod = packet.getFieldFirstValue('sip.Method')
      callId = packet.getFieldFirstValue('sip.Call-ID')
      cSeq = packet.getFieldFirstValue('sip.CSeq')
      statusCode = packet.getFieldFirstValue('sip.Status-Code')
      print 'Frame %s, call %s, method %s, Seq %s, status %s' % (frameNumber, callId, sipMethod, cSeq, statusCode)

class sctpOnly(PacketCollection):
  """ Collection of SCTP packets and methods"""

  def __init__(self, packets):
      self.packets = packets

  def getPacket(self,method, n=1):
    """ Return the nth packet """
    pktList = []
    for packet in self.packets:
        sctp_packet = packet.getFieldFirstValue(method)
        if sctp_packet:
            pktList.append(packet)
    if (len(pktList) >= n):
        return pktList[n-1]
    else:
        return None

class DnsOnly(PacketCollection):
  """ Collection of DNS packets and methods"""

  def __init__(self, packets):
      self.packets = packets
      self.requestPktCount = 0
      self.responsePktCount = 0
  #31291
  def getPackets(self,type,nbr=1):
    """ Returns the DNS Query or Response packet based on the input parameter"""
    pktList = []
    for packet in self.packets:
      # 40326 - Added a check for dns query type so that further verification is done 
      # only for these two types of dns packets.

      qry_type = packet.getFieldFirstShowName('dns.qry.type')

      #PR-149643 Added check for including SRV queries also
      if (qry_type == 'Type: NAPTR (Naming authority pointer)') or (qry_type == 'Type: A (Host address)' or (qry_type == 'Type: SRV (Service location)')):
          print "qry_type", qry_type
          if type == 'request':
              if packet.getFieldFirstValue('dns.flags.response') == '0':
                  pktList.append(packet)
                  self.requestPktCount = self.requestPktCount + 1
          if type == 'response':
              if packet.getFieldFirstValue('dns.flags.response') == '1':
                  pktList.append(packet)
                  self.responsePktCount = self.responsePktCount + 1
    if (len(pktList) >= nbr):
      return pktList[nbr-1]
    else:
      return None

  def getPacketCount(self,type):
      if type == 'request':
         return self.requestPktCount
      if type == 'response':
         return self.responsePktCount

class TlsOnly(PacketCollection):
  """ Collection of TLS packets and methods"""

  def __init__(self, packets):
      self.packets = packets

  #31291
  def getPackets(self,nbr=1):
    """
    Returns TLS Packets. Currently verifying these two headers one can say its a tls packet.
    This has to be used only for TLS cases and not for TCP cases. For TCP use sip.METHOD functions.
    """
    pktList = []
    for packet in self.packets:
      if (packet.getFieldFirstShowName('ip.proto') and packet.getFieldFirstShowName('tcp.dstport')):
        pktList.append(packet)
    
    return pktList 
 
class SipOnly(PacketCollection):
  """ Takes SIP packets and creates call and transaction structures for logical assertions.
      The idea is to allow assertion like the Invite transaction for the third call has failed
      with cause 404.
  """
  def __init__(self, packets):
      self.packets = packets

  def printPackets(self):
    """
      print a summery of the sip packets
    """
    for packet in self.packets:
      frameNumber = packet.getFieldFirstValue('frame.number')
      sipMethod = packet.getFieldFirstValue('sip.Method')
      callId = packet.getFieldFirstValue('sip.Call-ID')
      cSeq = packet.getFieldFirstValue('sip.CSeq')
      statusCode = packet.getFieldFirstValue('sip.Status-Code')
      print 'Frame %s, call %s, method %s, Seq %s, status %s' % (frameNumber, callId, sipMethod, cSeq, statusCode)
        
  def getCallIds(self):
    """
      returns a list of callId's found in the packets for the endpoint
    """
    callIdList = []
    for packet in self.packets:
      callId = packet.getFieldFirstValue('sip.Call-ID')
      sipMethod = packet.getFieldFirstValue('sip.Method')
      if (sipMethod == 'INVITE') and (callId not in callIdList):
        callIdList.append(callId)

    return callIdList

  def getCall(self, nbr=1):
    """ Returns a SipOnly instance with packets for the n-th called specified (nbr) """
    pktList = []
    callId = self.getCallIds()[nbr-1]
    pktList = self.filterPacket( {'sip.Call-ID': [callId] } ) 
    return SipOnly(pktList)

  def getTransactions(self, transaction):
    """
      Returns a list of all callId/cSeq for the defined transaction/method
      Known Transactions are INVITE/REGISTER/BYE
    """
    transactions = ['INVITE', 'REGISTER', 'BYE' ]

    idlist = []
    if transaction not in transactions:
      raise unknowName, "cwsip.getTransactions called with unknown transaction name!"

    for packet in self.packets:
      sipMethod = packet.getFieldFirstValue('sip.Method')
      if sipMethod == transaction:
        callId = packet.getFieldFirstValue('sip.Call-ID')
        cSeq = packet.getFieldFirstValue('sip.CSeq')
        idlist.append( [callId, cSeq] )

    return idlist

  def getTransactionResults (self, method, nbr=1):
    """
      returns a list of return codes for the specified transaction/method (INVITE,REGISTER,BYE),
      With nbr a n-th trnasaction of the specified method will be used.
    """

    try: 
      callId, cSeq = self.getTransactions(method)[nbr-1]
    except:
      raise pdmlPacketError,  'sip.assertTransaction: requested %s transaction (%d) not found' % (method, nbr)

    check_request = 0
    check_return = 0
    statusCode = []

    for packet in self.packets:
      current_callId = packet.getFieldFirstValue('sip.Call-ID')
      current_cSeq = packet.getFieldFirstValue('sip.CSeq')

      if (current_callId == callId) and (current_cSeq == cSeq):
        if check_request==0:
          sipMethod = packet.getFieldFirstValue('sip.Method')
          if sipMethod != method:
            raise pdmlPacketError, 'Transaction %s %s: Method in Request does not match (%s/%s)' % \
                           (callId, cSeq, sipMethod, method)
          check_request = 1
        else:
          statusCode.append ( int(packet.getFieldFirstValue('sip.Status-Code'))  )

    return statusCode

  def getTransactionFinalResult (self, method, nbr=1):
    """
      returns the final status codelist for the specified transaction 
      With nbr a n-th trnasaction of the specified method will be used.
    """

    try: 
      callId, cSeq = self.getTransactions(method)[nbr-1]
    except:
      raise pdmlPacketError,  'sip.assertTransaction: requested %s transaction (%d) not found' % (method, nbr)

    for packet in self.packets:
      current_callId = packet.getFieldFirstValue('sip.Call-ID')
      current_cSeq = packet.getFieldFirstValue('sip.CSeq')

      if (current_callId == callId) and (current_cSeq == cSeq):
        try:
          statusCode = int(packet.getFieldFirstValue('sip.Status-Code'))
        except:
          statusCode = None

    return statusCode

  def callExists (self, nbr=1):
    """
      Checks that the n-th call id exists only
    """

    try:
      callId = self.getCallIds()[nbr-1]
    except:
      return 0

    return 1

  #32414 - Added to get any SIP Response Packet
  def getResponsePacket(self,n=1):
    """Returns the  nth response packet
       n       -- indicates the index for the packet. For example if more packets
                 are found for the same message this method will return the packet based on
                 the value of n. The default value of n is 1
    """
    PacketList=[]
    for packet in self.packets:
        if packet.item_exists('sip.Status-Code'):
            PacketList.append(packet)
    if (len(PacketList) >= n):
        return PacketList[n-1]
    else:
        return None


  # 20365
  def getInvitePacket(self, n=1):
    """ Return the nth INVITE packet """
    invPktList = []
    for packet in self.packets:
      sipMethod = packet.getFieldFirstValue('sip.Method')
      if (sipMethod == 'INVITE'):
        invPktList.append(packet)

    if (len(invPktList) >= n):
      return invPktList[n-1]
    else:
      return None

  #36909
  def getResponse(self,respcode,n=1):
     """Returns the  nth responsecode packet
       n       -- indicates the index for the packet. For example if more packets
                 are found for the same message this method will return the packet based on
                 the value of n. The default value of n is 1
     """
     PacketList=[]
     for packet in self.packets:
         statusCode = packet.getFieldFirstValue('sip.Status-Code')
         if (statusCode == respcode):
            PacketList.append(packet)
     if (len(PacketList) >= n):
         return PacketList[n-1]
     else:
         return None

  def getSrcPort(self,pkt):
    """ Returns the Source Port of the packet """
    return pkt.getFieldFirstValue('udp.srcport')


  def getDestPort(self,pkt):
    """
      print a summery of the sip packets
    """
    return pkt.getFieldFirstValue('udp.dstport')

  # 36319 - Added a new function to filter a SIP packet
  def getPacket(self,method, n=1):
    """ Return the nth packet """
    pktList = []
    for packet in self.packets:
      sipMethod = packet.getFieldFirstValue('sip.Method')
      if (sipMethod == method):
        pktList.append(packet)

      sipStatusCode = packet.getFieldFirstValue('sip.Status-Code')
      if (sipStatusCode == method):
        pktList.append(packet)
 
    if (len(pktList) >= n):
      return pktList[n-1]
    else:
      return None

  #46173 - Added code to get all the packets
  def getAllPackets(self,method):
    """ Return the all the packet """
    pktList = []
    for packet in self.packets:
      sipMethod = packet.getFieldFirstValue('sip.Method')
      if (sipMethod == method):
          pktList.append(packet)

      #175674 Added because 480 response was not being added in pktList.
      sipStatusCode = packet.getFieldFirstValue('sip.Status-Code')
      if (sipStatusCode == method):
        pktList.append(packet)

    return pktList


class h323Only(PacketCollection):
  """
    Collection of H323 packets, methodes and assertions

    transactions defines the transaction types, the messages invloved in the transaction and 
    the number of messages expected for assertTransaction.
    (We may add a second number as a min/max so we can support optional/multiple messages)
  """

  transactions = {'registration' : [ ['h225.registrationRequest', 1], 
                                     ['h225.registrationConfirm', 1], 
                                     ['h225.registrationReject', 0] ],
                  'gatekeeper'   : [ ['h225.gatekeeperRequest', 1],
                                     ['h225.gatekeeperConfirm',1],
                                     ['h225.gatekeeperReject', 0] ],
                  'admission'    : [ ['h225.admissionRequest', 1],
                                     ['h225.admissionConfirm',1],
                                     ['h225.admissionReject', 0] ],
                  'inforequest'  : [ ['h225.infoRequestResponse',1] ],
                  'resource'     : [ ['h225.resourcesAvailableIndicate', 1],
                                     ['h225.resourcesAvailableConfirm', 0],
                                     ['h225.resourceUnavailable', 0] ],
                  'disengage'    : [ ['h225.disengageRequest', 1 ],
                                     ['h225.disengageConfirm', 1 ],
                                     ['h225.disengageReject', 0 ] ],
                  'location'     : [ ['h225.locationRequest', 1 ],
                                     ['h225.locationConfirm', 1 ],
                                     ['h225.locationReject', 0 ] ],
                  'unregister'   : [ ['h225.unregistrationRequest',1],
                                     ['h225.unregistrationConfirm', 1],
                                     ['h225.unregistrationReject',0] ] 
                 }
  
  def __init__(self, packets):
    self.packets = packets

  def printPackets(self):
    """ prints a summery of the h323 packets """
    for packet in self.packets:
      frameNumber = packet.getFieldFirstValue('frame.number')
      rasMessage = packet.getFieldFirstShowName('h225.RasMessage')
      messageBody = packet.getFieldFirstShowName('h225.h323_message_body')
      requestRefNum = packet.getFieldFirstValue('h225.requestSeqNum')
      callReference = packet.getFieldFirstValue('q931.call_ref')

      print 'Frame %s, rasMessage %s, message_body  %s, requestSeqNum %s, callReference %s' \
                   % (frameNumber, rasMessage, messageBody, requestRefNum, callReference)

  def getCallIds(self):
    """Returns a list of call_reference numbers from the h225 packets"""
    callList = []

    for packet in self.packets:
      callReference = packet.getFieldFirstValue('q931.call_ref')
      if callReference != None:
        if callReference not in callList:
          callList.append(callReference)
    return callList
       
  def getCall(self, nbr=1):
    """ Returns a instance of h323Only object with packets for the n-th called specified (nbr) """
    pktList = []
    callId = self.getCallIds()[nbr-1]
    pktList = self.filterPacket( {'q931.call_ref': [callId] } ) 
    return h323Only(pktList)


  def getTransactions(self, transaction):
    """Returns a list of all requestSeqNumbers filtered per transaction type"""

    transaction_list = []

    if transaction not in self.transactions.keys():
      raise unknowName, "h225.getTransaction called with unknown transaction name!"

    for packet in self.packets:
      for transactionTypeField in self.transactions[transaction][0]: 
        if packet.item_exists(transactionTypeField):

          requestSeqNum = packet.getFieldFirstValue('h225.requestSeqNum')
          if requestSeqNum not in transaction_list:
            transaction_list.append(requestSeqNum)
    return transaction_list

  def checkTransaction(self, transaction, nbr=1):
    """ 
      checks that a transaction has the right number of requests/responses, normally
      1 request is expected and 1 confirm but no reject (defined in transactions)
    """  

    nPacket = {}
    
    if transaction not in self.transactions.keys():
      raise pdmlPacketError, "h323.getTransaction called with unknown transaction name!"
    else:
      for msgType in self.transactions[transaction]:
        nPacket[msgType[0]] = 0

    idlist = self.getTransactions(transaction)
    if len(idlist) < nbr:
      raise pdmlPacketError, 'h323.assertTransaction: requested Transaction %s does not exist (%d/%d)' % \
                    (transaction, len(idlist), nbr)

    requestSeqNum = idlist[nbr-1]

    # for each packet check the type and the requestSeqNum, if it matches increase counter
    for packet in self.packets:
      for pktType in self.transactions[transaction]:
        if packet.item_exists(pktType[0]):
          if packet.getFieldFirstValue('h225.requestSeqNum') == requestSeqNum:
            nPacket[pktType[0]] += 1

    # now we are ready to compare defined values to counted values
    for pktType in self.transactions[transaction]:
      if nPacket[pktType[0]] != pktType[1]:
        # return 0 if numbers don't match
        return 0

    return 1

  def callExists(self, nbr=1):
    """ checks if a given call exists """
    idlist = self.getCallIds()
    if len(idlist)<nbr :
      return 0
    else:
      return 1

  def isCallSuccessful(self, nbr=1):
    """
      makes assertions on a call. Currently following criteria are checked:
        1. the n-th call is found in the trace
        2. a setup is send
        3. a callProceeding is send
        4. a connect is send
        5. a releaseComplete is send
    """
    msgTypes = ['h225.setup', 'h225.callProceeding', 'h225.connect', 'h225.releaseComplete']       

    nPacket = {}
    for type in msgTypes:
      nPacket[type] = 0

    idlist = self.getCallIds()
    if len(idlist)<nbr :
      #call does not exist
      return False

    setup = callProceeding = connect = releaseComplete = 0

    callReference = idlist[nbr-1]
    for packet in self.packets:
      if packet.getFieldFirstValue('q931.call_ref') == callReference:
        for type in msgTypes:
          if packet.item_exists(type):
            nPacket[type] += 1

    for type in msgTypes:
      if nPacket[type] == 0:
        #one of the messages was not found
        return False
   
    return True

  # 20365
  def getSetupPacket(self,n=1):
      """Returns the setup message"""
      setupPacketList=[]
      for packet in self.packets:
        if packet.item_exists('h225.setup'):
          setupPacketList.append(packet)

      if (len(setupPacketList) >= n):
        return setupPacketList[n-1]
      else:
        return None

  #Ticket 26611 
  def getRCFPacket(self,n=1):
      """Returns the Registration Confirm message"""
      rcfPacketList=[]
      for packet in self.packets:
        if packet.item_exists('h225.registrationConfirm'):
          rcfPacketList.append(packet)

      if (len(rcfPacketList) >= n):
        return rcfPacketList[n-1]
      else:
        return None

  #Ticket 26611
  def getRRJPacket(self,n=1):
      """Returns the Registration Reject  message"""
      rrjPacketList=[]
      for packet in self.packets:
        if packet.item_exists('h225.registrationReject'):
          rrjPacketList.append(packet)

      if (len(rrjPacketList) >= n):
        return rrjPacketList[n-1]
      else:
        return None

  # 26747
  def getPacket(self,message,n=1):
      """Returns the  nth packet for the message which is passed as input parameter
      message -- Name of the message Example: 'h225.admissionRequest'
      n       -- indicates the index for the packet. For example if more packets
                 are found for the same message this method will return the packet based on
                 the value of n. The default value of n is 1"""

      # 36319 - Modified filtering to be more specific
      reqList = message.split('.')

      PacketList=[]
      for packet in self.packets:
        if packet.item_exists('h225.h323_message_body'):
          if packet.getFieldFirstShowName('h225.h323_message_body').__contains__(reqList[1]):
            PacketList.append(packet)
        elif packet.item_exists('h225.RasMessage'):
          if packet.getFieldFirstShowName('h225.RasMessage').__contains__(reqList[1]):
            PacketList.append(packet)

      if (len(PacketList) >= n):
        return PacketList[n-1]
      else:
        return None


  #18523 
  def isTCSFound(self,n=1):
      """Returns true if H245 TCS message is found"""
      result = False
      reqPacketList=[]
      for packet in self.packets:
         if packet.item_exists('h245.terminalCapabilitySet'):
             result =  True
      return result

  #18523
  def isMSDFound(self,n=1):
      """Returns the true if H245 MSD message is found"""
      result = False
      reqPacketList=[]
      for packet in self.packets:
         if packet.item_exists('h245.masterSlaveDetermination'):
             result =  True
      return result

  #18523
  def isOLCFound(self,n=1):
      """Returns the H245 OLC message is found"""
      result = False
      reqPacketList=[]
      for packet in self.packets:
         if packet.item_exists('h245.openLogicalChannel'):
             result =  True
      return result

 # 33111 This method was added as part of ticket 30817 in h323Only class. 
 # But it was incorrectly moved inside the class h245Only. Hence moved this
 # method inside h323Only class
  def getAllPackets(self,message):
      """Returns all the packets containing the message which is passed as input parameter
      message -- Name of the message Example: 'h225.admissionRequest'"""

      PacketList=[]
      for packet in self.packets:
        if packet.item_exists(message):
          PacketList.append(packet)

      return PacketList



# 29925 - Added new class to collect H245 Packets
class h245Only(PacketCollection):
  """ Collection of H245 packets and methods"""

  def __init__(self, packets):
    self.packets = packets

  def getPacket(self,message,n=1):
    """Returns the  nth packet for the message which is passed as input parameter
    message -- Name of the message Example: 'h245.terminalCapabilitySet'
    n       -- indicates the index for the packet. For example if more packets
               are found for the same message this method will return the packet based on
               the value of n. The default value of n is 1"""
    PacketList=[]
    reqList = message.split('.')

    # 36319 - Modified the filtering to be more specific
    for packet in self.packets:
      if packet.item_exists('h245.request'):
        request = packet.getFieldFirstShowName('h245.request').split(' ')
        if request[1] == reqList[1]:
            PacketList.append(packet)
      if packet.item_exists('h245.response'):
        response = packet.getFieldFirstShowName('h245.response').split(' ')
        if response[1] == reqList[1]:
            PacketList.append(packet)
      if packet.item_exists('h245.command'):
        command = packet.getFieldFirstShowName('h245.command').split(' ')
        if command[1] == reqList[1]:
            PacketList.append(packet)

    if (len(PacketList) >= n):
      return PacketList[n-1]
    else:
      return None

#PR 133010 - Count radius packets
class radiusOnly(PacketCollection):
    """
    Collection of radius packets and methods 
    """
    def __init__(self, packets):
       self.packets = packets
       self.log = logging.getLogger('nextestlog')

    # PR 134918 - Implement getPackt function
    def getPacket(self,method, n=1):
       """Returns the  nth packet for the message which is passed as input parameter
          message -- Name of the message Example: 'Accounting-Request'
          n       -- indicates the index for the packet. For example if more packets
                 are found for the same message this method will return the packet based on
                 the value of n. The default value of n is 1"""
       PacketList=[]
       temp=[]
       radpkts=self.packets 

       for pkt in radpkts:
          if not pkt.getFieldFirstShowName('icmp.code')and (pkt.getFieldFirstShowName('radius.code').__contains__(method)):
              PacketList.append(pkt)
    
       if (len(PacketList) >= n):
          return PacketList[n-1]
       else:
          return None

    # PR 134918 - Implement getAllPacket function
    def getAllPackets(self,method):
       """ Return the all the packets for the message passed as input parameter
       message -- Name of the message Example: 'Accounting-Request'
       """
       PacketList=[]
       pktList = []
       radpkts=self.packets 
       for pkt in radpkts:
           if not pkt.getFieldFirstShowName('icmp.code')and (pkt.getFieldFirstShowName('radius.code').__contains__(method)):
              PacketList.append(pkt)
       return PacketList

    #PR 133010 - Funtion to return count of radius packets iun a specified time
    def getRadiusPacketCount(self,timer=0):
       """
       This function returns the number of Accounting request messages
       received/sent by a specific ip in a specified amount of time
       timer= time specified in seconds
       """
       
       timelist=[]
       i=0
       count=0
       temp=[]
       radpkts=self.packets 
       # Remove the ICMP packets
       for pkt in radpkts:
          if not pkt.getFieldFirstShowName('icmp.code'):
              temp.append(pkt)
       # if no packets are captured return 0
       if len(temp)==0:
           return count
       # if timer is not specified, return all the Accounting request packets
       if timer==0:
           for pkt in temp:
	       if (pkt.getFieldFirstShowName('radius.code').__contains__('Accounting-Request')):
		   count = count+1
       else:
           for pkt in temp:
	       if (pkt.getFieldFirstShowName('radius.code').__contains__('Accounting-Request')):
                   v=pkt.getFieldFirstShowName('frame.time')
                   #Time is of the format:
                   #string="Arrival Time: Sep  4, 2009 08:43:04.119732000"
                   #Split the string by the ", "
                   m=v.split(", ")
                   # Split the substring"2009 08:43:04.119732000" by space 
                   # and pick the 1st element
                   a=m[1].split(" ")[1]
                   #Extract the time till the seconds and leave the milliseconds
                   time_1=a.split('.')[0]
                   #Convert the time to the hr,min,sec format
                   curr_time= time.strptime(time_1,"%H:%M:%S")
                   timelist.append(curr_time[5])
           start=timelist[0]
           #end if the last value in the list+ timer specified
           end=int(timelist[0])+ int(timer)
           for i in timelist:
               if (i <= end):
                   count=count+1
       self.log.info("Count of Radius packets is %s" %count)
       return count
   
class utCaptures(unittest.TestCase):

   def test0(self):
       return
       print '- Test 0 -----------------------------------------------------------------'
       a = readCapture('/home/mepple/test/packetCapture/h323_3_1.pdml')
       a.printEndpoints()
       print '--------------------------------------------------------------------------'
       a.endpoints['sandiego'].h323.printPackets()
       print '--------------------------------------------------------------------------'
       self.assertEquals( a.endpoints['sandiego'].h323.checkTransaction ('admission', 1), 1, "Admission NOT OK")
       self.assertEquals( a.endpoints['sandiego'].h323.checkTransaction ('registration', 1), 1, "Registration NOT OK")
       #self.assertEquals( a.endpoints['sandiego'].h323.checkTransaction ('bla', 1), 1, "bla OK")
       self.assertEquals( a.endpoints['sandiego'].h323.callExists(), 1, "No Call found")
       self.assertEquals( a.endpoints['sandiego'].h323.callExists(2), 0, "unexpected Call found")
       self.assertEquals( a.endpoints['sandiego'].h323.isCallSuccessful(), True, "Not all expected Messages found for call")

       call = a.endpoints['sandiego'].h323.getCall( 1 )
       call.printPackets()

   def test1(self):
       return
       print '- Test 1 -----------------------------------------------------------------'
       a = readCapture('/home/mepple/test/packetCapture/sipsip.pdml')
       print '--------------------------------------------------------------------------'
       a.printEndpoints()
       print '--------------------------------------------------------------------------'
       a.endpoints['tt2'].sip.printPackets()
       print '--------------------------------------------------------------------------'
       self.assertEquals( a.endpoints['tt2'].sip.getTransactionResults('INVITE', 1), [100, 200], "Invite doesn't get 100 and 200 response") 
       self.assertEquals( a.endpoints['tt2'].sip.getTransactionFinalResult('INVITE', 1), 200, "Invite doesn't get 200 response") 

   def test2(self):
       return
       print '- Test 2 -----------------------------------------------------------------'
       a = readCapture('/home/mepple/test/packetCapture/sipsip.pdml')
       self.assertEquals( a.endpoints['tt2'].sip.getTransactionResults('INVITE', 3), [100, 200], "Invite doesn't get 100 and 200 response") 
       self.assertEquals( a.endpoints['tt2'].sip.callExists(), 1, "No call found")

   def test3(self):
       return
       print '- Test 3 -----------------------------------------------------------------'
       a = readCapture('/home/mepple/test/packetCapture/sipsip.pdml')
       print a.filterPacket({ 'ip.src_host':['192.168.192.121'], 'ip.dst_host':['192.168.192.130'] })

   def test4(self):
       return
       print '- Test 4 -----------------------------------------------------------------'
       a = readCapture('/home/mepple/test/packetCapture/sipsip.pdml')
       result, resultStr = a.PacketList[0].assertFields({ 'ip.src_host':['192.168.192.121'], 'ip.dst_host':['192.168.192.130'] })
       self.assert_(result, resultStr)

   def test5(self):
       return
       print '- Test 5 -----------------------------------------------------------------'
       a = readCapture('/home/mepple/test/packetCapture/sipsip1.pdml')
       a.printEndpoints()
       print '--------------------------------------------------------------------------'
       a.endpoints['miami'].sip.printPackets()
       print '--------------------------------------------------------------------------'
       self.assertEquals( a.endpoints['miami'].sip.getTransactionResults('INVITE'), [100, 180, 200], "Invite not ok") 
       self.assertEquals( a.endpoints['miami'].sip.getTransactionFinalResult('INVITE'), 200, "Invite not ok") 
       print '--------------------------------------------------------------------------'
       call = a.endpoints['miami'].sip.getCall( 1 ) 
       call.printPackets()
       print '--------------------------------------------------------------------------'
       acks = SipOnly (call.filterPacket( {'sip.Method' : ['ACK'] } ) )
       acks.printPackets()
       print '--------------------------------------------------------------------------'

   def test6(main):
       return
       print '- Test 5 -----------------------------------------------------------------'
       #a = readCapture('/var/opt/nextest/tdb/results/20090904_0842/production_components-rad_accounting-regression-01_pkttrace_g0_g1.pdml')
       #timelist=[]
       #i=0
       #timer=5
       #count=0
       ##a.printEndpoints()
       #radpkts = a.endpoints['radiusprimary'].radius.getPacketCount()
       #print radpkts
       #if len(radpkts)!=0:
       #     for pkt in radpkts:
       #         v=pkt.getFieldFirstShowName('frame.time')
       #         #string="Arrival Time: Sep  4, 2009 08:43:04.119732000"
       #         m=v.split(" ")
       #         time_1=m[6].split('.')[0]
       #         a= time.strptime(time_1,"%H:%M:%S")
       #         timelist.append(a[5])
       #     print '--------------------------------------------------------------------------'
       #     print timelist         
       #     start=timelist[0]
       #     end=timelist[0]+1
       #     for i in timelist:
       #	        if (i <=end):
       #             count=count+1
       #     print count
       #else:
       #    count = 0
        #print timelist 
          
        #if pkt.getFieldFirstShowName('radius.code').__contains__('Accounting-Request'):
        #    print pkt.getFieldFirstShowName('ip.dst').__contains__(secondaryradiussvr.addr)

        #print '--------------------------------------------------------------------------'
       #a = readCapture('/root/bug/eng_test-aaa-aaa-03_pkttrace_g0_g1.pdml')
       a = readCapture('temp.pdml')
       radpkts = a.endpoints['10.201.1.211'].radius_count.getPacket("Accounting-Request")
       print radpkts.getFieldFirstValue('ip.src')
       
       radpkts = a.endpoints['10.201.1.211'].radius_count.getAllPackets("Accounting-Request")
       print radpkts
       count = a.endpoints['10.201.1.215'].radius_count.getRadiusPacketCount()
       print count
       count = a.endpoints['10.201.1.211'].radius_count.getRadiusPacketCount('100')
       print count
       count = a.endpoints['10.201.1.212'].radius_count.getRadiusPacketCount('100')
       print count
       
       #count = a.endpoints['10.201.1.211'].radius_count.getRadiusPacketCount('10')
       #count = getRadiusPacketCount(radpkts,'0')
       #print count
       #mswip = gethostbyname('mymsw')
       #print radpkts
       #ind = 0
       #for pkt in radpkts:
	   #print pkt
        #   if pkt.getFieldFirstShowName('radius.code').__contains__('Accounting-Request'):
         #      pkt.assertFields({'radius.NAS_IP_Address'     : [mswip],
          #                      'radius.Calling_Station_Id' : ['12345'],
           #                     'radius.Called_Station_Id'  : ['32141']})
           #ind += 1
       #print ind



   def test8(self):
 
       a= readCapture("/var/trial.pcap")
       a.printEndpoints()
       radpkts = a.endpoints['radiusprimary'].radius
       print radpkts
       tList=[]
       tstamp=""
       for pkt in radpkts:
           if pkt.getFieldFirstShowName('radius.code').__contains__('Access-Request') and not pkt.getFieldFirstShowName('icmp.code'):
				   
               tstamp = pkt.getFieldFirstValue('frame.time_relative')
               tList.append(tstamp)
               frNum = int(pkt.getFieldFirstValue('frame.number'))
       print len(tList)
       print tList
       #test.assertEquals(len(tList),4,"No. of retries is not equal to Retry value of 4 on MSX")

       for i in range(0,3):
           t1 = float(tList[i])
           t2 = float(tList[i+1])
           if not((round(t2-t1)==5) or (round(t2)-round(t1)==5)):
               value = False
										   
								   
   def test7(self):
       return
       print '- Test 7 -----------------------------------------------------------------'
       a = readCapture('/root/eng_test-aaa-aaa-07_pkttrace_g0_g1.pdml')
       snmppkts = a.endpoints['10.206.25.10'].snmp
       pkt=snmppkts[0]
       print pkt.getFieldFindShow('Value: OBJECTID: 1.3.6.1.4.1.7684.2.5.0.13')
       for pkt in snmppkts:
           val=pkt.getFieldFindShow('Value: OBJECTID: 1.3.6.1.4.1.7684.2.5.0.13')
           a = pkt.getFieldFindShowValue('Value: OBJECTID: 1.3.6.1.4.1.7684.2.5.0.13')
	   if (a !=None):
	       print a
	       b='0x'+a
	       x=a.upper()
	       #print oct(b)
	       m = eval(b)
	       print m
	       p = str(a)
	       print p 
	       
	       import binascii
	       print binascii.a2b_hex(p)
	   #print "%d" %int(b)
           #print "%o" %(int(pkt.getFieldFindShowValue('Value: OBJECTID: 1.3.6.1.4.1.7684.2.5.0.13')))
	   if (val != None) and (val==True):
	       print "Found Primary Server Status"
	       print pkt.getFieldFirstShowName('ip.src')
   	       #print pkt.getFieldAllShow('Value: OCTET STRING: 10.206.25.10')
	   #print pkt.getFieldFirstShow('Value: OBJECTID: 1.3.6.1.4.1.7684.2.5.0.13')
	   #.__contains__('1.3.6.1.4.1.7684.2.5.0.13'):
			   
       #print snmppkts
       
  

if __name__ == '__main__':
    unittest.main()

