"""
Information about and access to the MSW for automated testing.
"""
import cdr
import logging
import os
import pexpect
from   Queue import *
import signal
import socket
import string
from   threading import *
import time
from nxConfigInterface import *
from session import *
# Fix for Ticket #26365, a mailer module is added in nextest.
import mailer
# 29725 -  Global timer Values 
import globalVar

import pdb

class MSWError(Exception):
    "General MSW exception"

class MSWInfo(object):
    """
    An object containing information about an MSW.

     -- the name or IP address of the MSW
    """
    def __init__(self, name):
        """
        Get information from the MSW.

        The information obtained includes IP address (if the name
        argument is a host name), CDR configuration info, and other
        bits.

        Note that a no-password login to root is required so that
        configuration information can be obtained.  The class is
        responsible for setting up and tearing down the SSH
        connection.
        """
        # Connect to logging started earlier
        self.log = logging.getLogger('nextestlog')
        self.user = 'root'
	# 29725 -  Global timer Values 
	self.timeout = int (globalVar.sshTimeout)
        self.connectMSW(name)
        #self.checkIserver()
        self.coreCount = 0
        self.iVersion, self.nVersion = self.getVersions()
        self.getLatestJava()
        # 18524
        login=self.user + '@' + name
        self.mswSession = SSH([login])
        #38747 - Removed hardcoded value 
        self.mswConf = MswConfig(name) 
        self.cdrdict = self.getCDRDict()
        self.cdrpath, self.cdrfile, self.calllegscdrfile,self.interimcdrfile, self.cdrcurrent, self.calllegscdrcurrent, self.interimcdrcurrent = self.getCDRPaths()


        self.log.debug("Cdrpath set as %s" % self.cdrpath)
        self.log.debug("Cdrfile set as %s" % self.cdrfile)
        self.log.debug("Calllegscdrfile set as %s" % self.calllegscdrfile)
        self.log.debug("Cdrcurrent set as %s" % self.cdrcurrent)
        self.log.debug("Calllegscdrcurrent set as %s" % self.calllegscdrcurrent)
        self.log.debug("CallInterimFile CallInterimCurrent set as %s" %self.interimcdrcurrent)
        self.log.debug("CallInterimFile as %s" %self.interimcdrfile)


        self.dbglogpath =  self.getDbglogPath()
        self.etherMap = self.getInterfaces()
        self.ostype = self.getOS()
        # 43832 Checking if it a NSF setup
        self.nsf = self.checkNSF()
        self.fwname = self.getFirewallName()
        # 27718 Getting the path for the error log
        self.errlogpath = self.getErrlogPath()

        #36909 - Checking for the presence of cdr_decode.pl
        if (os.path.isfile('/tmp/cdr_decode.pl') == False):
            #Copying cdr_decode.pl and cdrdict.xml to /tmp directory
            cmd = 'scp -q root@%s:/opt/nextone/etc/cdr_decode.pl /tmp' %self.ipaddr
            os.system(cmd)
            cmd = 'scp -q root@%s:/usr/local/nextone/bin/cdrdict.xml /tmp' %self.ipaddr
            os.system(cmd)
            #Changing the permission and replacing path of cdrdict.xml in cdr_decode.pl
            os.system('sudo chmod 777 /tmp/cdr_decode.pl')
            cmd = "perl -pi -e s/'\/usr\/local\/nextone\/bin\/'/'\/tmp\/'/ \/tmp\/cdr_decode.pl"
            os.system(cmd)

        else:
            #Comparing the versions of cdr_decode.pl in GEN and MSW
            localShell = session.LocalShell()
            localShell.spawnProc.sendline('grep pfs /tmp/cdr_decode.pl')
            localShell.spawnProc.expect(localShell.prompt)
            localShell.spawnProc.expect(localShell.prompt)
            output = localShell.spawnProc.before
            output = output.strip(localShell.promptChunk)
            self.mswSession.spawnProc.sendline('grep pfs /opt/nextone/etc/cdr_decode.pl')
            self.mswSession.spawnProc.expect(self.mswSession.prompt)
            self.mswSession.spawnProc.expect(self.mswSession.prompt)
            output1 =  self.mswSession.spawnProc.before
            output1 = output1.strip(self.mswSession.promptChunk)
            #if different version then copying cdr_decode.pl from MSW to GEN
            if output != output1:
                 #Copying cdr_decode.pl and cdrdict.xml to /tmp directory
                 cmd = 'scp -q root@%s:/opt/nextone/etc/cdr_decode.pl /tmp' %self.ipaddr
                 os.system(cmd)
                 cmd = 'scp -q root@%s:/usr/local/nextone/bin/cdrdict.xml /tmp' %self.ipaddr
                 os.system(cmd)
                 #Changing the permission and replacing path of cdrdict.xml in cdr_decode.pl
                 os.system('sudo chmod 777 /tmp/cdr_decode.pl')
                 cmd = "perl -pi -e s/'\/usr\/local\/nextone\/bin\/'/'\/tmp\/'/ \/tmp\/cdr_decode.pl"
                 os.system(cmd)


        # 36319 - Introduce new variables to store the HK information
        self.hkMAC = ['','']
        self.hkIP = ['','']
         
        self.log.debug('MSWInfo.__init__: MSWInfo %s created' % name)

    def __del__(self):
        """Close the SSH session if it is open.

        If, for some reason, the constructor never reached the point
        of creating an SSH session, this destructor will catch the
        AttributeError and exit gracefully.
        """
        try:
            self.disconnectMSW()
           #14000
        except AttributeError,e:
            self.log.info('Exception %s - destructor: no ssh session to tear down' % str(e))

    # 43832
    def checkNSF(self):
        """Check if its is a NSF setup and return True or False
        
        Currently the only way to determine for NSF setup is by querying for
        nsf_linux rpm package
        """
        self.ssh.sendline('rpm -qa | grep nsf_linux')
        self.ssh.expect(self.prompt, self.timeout)
        out = self.ssh.before.split('\r\n')
        del out[0]
        if out:
            if out[0].__contains__('nsf_linux'):
                return True
            else:
                return False
        return False


    def checkIserver(self):
        """Verify that iserver process is running.  Start if not."""
        
        self.ssh.sendline('pgrep -x gis')
	#29725
        self.ssh.expect(self.prompt, self.timeout)
        out = self.ssh.before.split('\r\n')
        self.log.debug('MSWInfo.checkIserver: out = "%s"' % out)
        del out[0] # remove first line
        self.log.debug('MSWInfo.checkIserver: out = "%s"' % out)
        if (out[0] != ''):
            self.log.debug('MSWInfo.checkIserver: pid %s running on %s' %
                           (out[0], self.ipaddr))
        else:
            self.log.debug('MSWInfo.checkIserver: starting...')
            self.ssh.sendline('iserver all stop')
            self.ssh.expect(self.prompt)
            time.sleep(5)
            self.ssh.sendline('iserver all start')
            self.ssh.expect(self.prompt)
            time.sleep(5)
            self.log.debug('MSWInfo.checkIserver: %s started' % self.ipaddr)

    def connectMSW(self, name):
        """
        Resolve the MSW IP address and establish an SSH session.
        """
        try:
            self.ipaddr = ip = socket.gethostbyname(name)
        except socket.gaierror, exc:
            errnum, errstr = exc
            #14000
            raise MSWError('Exception: %s -  Error retrieving address for %s' %(str(exc),name))
        if ip != name:
            self.hostname = name
        else:
            self.hostname = None
        try:
	    # 29725
            login = self.user + '@'  + ip
            self.ssh = pexpect.spawn('ssh %s' % login)
            self.ssh.expect('[$#] ', self.timeout)
            self.ssh.sendline('')  # to avoid getting "Last Login" junk
            self.ssh.expect('[$#] ', self.timeout)
            self.prompt = self.ssh.before + self.ssh.after
            self.log.debug('ssh prompt: "%s"' % self.prompt)
        except Exception, exc:
            raise MSWError('Unable to connect to %s: %s' % \
                           (login, str(exc)))
        self.log.debug('MSWInfo.connectMSW: self.hostname: %s, self.ipaddr: %s'
                       % (self.hostname, self.ipaddr))

    def disconnectMSW(self):
        s = self.ssh
        if not s.isalive(): return
        s.sendline('exit')
        s.kill(9)  # have to do this - exit is unpredictable
        # self.mswSession.disconnect()

    def getCDRDict(self):
        """
        Obtain CDR configuration information.

        This includes the CDR dictionary and the location of the CDR
        directory.  Also get the type of CDR information that is being
        collected and the names of today's CDR files.
        """
        cdrDictPath = "/usr/local/nextone/bin/cdrdict.xml"
        self.log.debug('MSWInfo.getCDRDict: getting from path: %s'
                       % cdrDictPath)
        tmpPath = "/tmp/cdrdict.xml%s" % os.getpid()
        self.log.info('MSWInfo.getCDRInfo: fetching CDR dictionary')
        self._fetchFile(cdrDictPath, tmpPath)
        try: 
            cdrdict = cdr.CDRDictionary(tmpPath)
        except Exception, exc:
            raise MSWError('error parsing %s: %s' % (tmpPath, str(exc)))
        os.remove(tmpPath)
        return cdrdict

    def getCDRPaths(self):

        """ Bug Fix: 6722
         If SetiServerConfig failed to get the CDR path. Exception should be raised
         and further test execution stopped.

         using os.popen instead of pexpect will solve the problem associated with
         "java.net.UnknownHostException". When pexpect is used, it considers the exception
         thrown by application also as  CDR path whereas file object return by os.popen
         doesnt.


        """
        cdrPath = self.mswConf.getMSWConfig(self.mswSession,'Directory')
        self.log.debug('MSWInfo.getCDRPath: CDR path: %s' %cdrPath)
        self._validateCDRPath(cdrPath)

        # Special CDRpath problem. Gis's pwd is different than ours when 
        # we ssh as root, so we need to force this:
        self.log.debug('MSWInfo.getCDRPath: Checking for special CDR path problem. cdrPath = %s' % cdrPath)
        if cdrPath == ".":
            cdrPath = "/usr/local/nextone/bin"
            self.mswConf.setMSWConfig(self.mswSession,'Directory',cdrPath)
            self.log.debug('MSWInfo.getCDRPath: Changing NexTest CDR path to gis pwd: %s' % cdrPath)

	#Now get the CDR file type and file format
        cdrType = self.mswConf.getMSWConfig(self.mswSession,'CdrType')
        # From MSW 4.2 on, cdrtype will be returned as a string
        if ((cdrType == '1') or (cdrType.lower() == 'fixed')):
            self.log.debug('MSWInfo.getCDRPaths: Fixed CDR files in use')
            cdrFile = 'DATA.CDR'
            callLegsCdrFile = 'DATA.CTR'
            callInterimCdrFile = 'DATA.CIR'
        else:
            self.log.debug('MSWInfo.getCDRPaths: Daily CDR files in use')
            #Ticket 34248
            #Fetch Date from MSW rather than from GEN
            self.ssh.sendline('date +%Y%m%d')
            self.ssh.expect(self.prompt)
            DateName = self.ssh.before.split()[2]
            cdrFile = 'D' + DateName + '.CDT'
            callLegsCdrFile = 'D' + DateName + '.CTT'
            callInterimCdrFile = 'D' + DateName + '.CIT'
        cdrCurrent = cdrPath + '/' + cdrFile
        callLegsCdrCurrent = cdrPath + '/' + callLegsCdrFile
        callInterimCdrCurrent = cdrPath + '/' + callInterimCdrFile
        self.log.debug('MSWInfo.getCDRPaths: Consolidated CDR File path: %s' % cdrCurrent)
        self.log.debug('MSWInfo.getCDRPaths: Call Legs CDR File path: %s' % callLegsCdrCurrent)
        self.log.debug('MSWInfo.getCDRPaths: Call Interim CDR File path: %s' % callInterimCdrCurrent)
        return cdrPath, cdrFile, callLegsCdrFile, callInterimCdrFile , cdrCurrent, callLegsCdrCurrent, callInterimCdrCurrent

    def getDbglogPath(self):
        path =  self.mswConf.getMSWConfig(self.mswSession,'sLogDebugPath')
        self.log.debug('MSWInfo.getDbglogPath: DbgLog path: %s' % path)
        return path
        #c.close() was not being called
        c.close()

    # 27718
    def getErrlogPath(self):
        """
           Get the MSWConfig error log path information and 
           return the same
        """
        path =  self.mswConf.getMSWConfig(self.mswSession,'sLogErrPath')
        self.log.debug('MSWInfo.getErrlogPath: ErrLog path: %s' % path)
        return path


    def getInterfaces(self):
        """
        Get Ethernet information using gen module function and helper.
        """
        helper = 'getethers'
        local = '/opt/nextest/bin/' + helper
        remote = '/tmp/' + helper
        os.system('scp -q %s root@%s:%s' % (local, self.ipaddr, remote))
        self.ssh.sendline(remote)
        self.ssh.expect(self.prompt)
        input = self.ssh.before.split()
        del input[0]  # the command line
        addrmap = {}
        for item in range(0, len(input), 2):
            addrmap[input[item]] = input[item+1]
        return addrmap

    def getOS(self):
        "Get the operating system type"
        s = self.ssh
        s.sendline('uname')
        try:
	# 29725
            match = s.expect(['SunOS', 'Linux'], self.timeout)
        except pexpect.TIMEOUT:
            raise MSWError('Unable to determine MSW operating system')
        if match == 0:
            o = 'SunOS'
        elif match == 1:
            o = 'Linux'
	# 29725
        s.expect(self.prompt,self.timeout)
        return o
    
    def getVersions(self):
        "Get the version numbers for iServer and NSF driver"
        s = self.ssh
        # 58638 - Change to support the name change to GENBAND 
        s.sendline("cli -v  | grep 'Command Line Provisioning Utility' | awk '{print $6}' | tr -d 'v,'")
        #s.expect(self.prompt, timeout)
        s.expect('\r\n')
        s.expect('\r\n')
        iserver = s.before 
        s.sendline("modinfo | grep NSF    | awk '{print $9}' | tr -d 'v)'")
        #s.expect(self.prompt, timeout)
        s.expect('\r\n')
        s.expect('\r\n')
        nsf = s.before
        # Eliminate the output of this command from appearing in the next expect
	# 29725
        s.expect([self.prompt,pexpect.TIMEOUT],self.timeout) 
        return iserver, nsf
        
    def getFirewallName(self):
        "Get the firewall Name iServer is using"
        fwname = self.mswConf.getMSWConfig(self.mswSession,'FirewallName') 
        self.log.debug('MSWInfo.getFirewallName: Firewall: %s' % fwname)
        return fwname
        
    def _fetchFile(self, remote, local):
        "Fetch a file from the MSW with scp."
        err = os.system('scp -q root@%s:%s %s' %  \
                        (self.ipaddr, remote, local))
        if err != 0:
            errmsg = 'error retrieving %s from %s: %s' % \
                     (remote, self.ipaddr, os.strerror(err))
            self.log.debug(errmsg)
            raise MSWError(errmsg)

    def _validateCDRPath(self,name):
        """ Validate captured CDR path name.
          Throw exception if the Path is NONE or contains
          string 'Unknown'

        """
        if name is  None or name == ""  or name.find("Unknown")!=-1 :
            errmsg = 'Got Invalid CDR Path name [%s] from %s.\n \
                 Check  MSW is reachable and Services are running ' % \
                     (name, self.ipaddr)
            self.log.debug(errmsg)
            raise MSWError(errmsg)

    def getLatestJava(self):
        """
        Get latest .jar file(s) corresonding to current jServer.
           - jServer.jar used by SetiServerConfig()
        """
        if (self.compareiServerVersion('4.2') >= 0):
            self.log.debug('jServer.jar file is not available on 4.2 and later iserver versions')
            return
        remoteJarPath = "/usr/local/nextone/bin/jServer.jar"
        localTmpPath  = "/tmp/jServer.jar"
        localJarPath  = "/opt/nextest/lib/java/jServer.jar"
        # Remove the .jar file that came with the distrinution of NexTest
        os.system('sudo rm %s' %  (localJarPath))
        # Get the latest one from the MSW
        self._fetchFile(remoteJarPath, localTmpPath)
        # Now move in into place listed in CLASSPATH
        err = os.system('sudo mv %s %s' %  (localTmpPath, localJarPath))
        if err != 0:
            errmsg = 'error moving %s to %s: %s' % \
                     (localTmpPath, localJarPath, os.strerror(err))
            self.log.debug(errmsg)
            raise MSWError(errmsg)
        os.system('sudo chown bin:bin %s' %  (localJarPath))

    def compareiServerVersion(self,relVersion):
        """
        Compare the iServer version numbers. The number of levels of comparison will depend
        on the input Release version string. For example, if 4 is entered, then only the first version 
        number will be compared, if 3.1.1 is entered then the first three levels would be 
        individually compared. 
        Release name is passed as the argument and it takes values as 4.0, 4.0c3-10, 4.2, 4.2c1-3 etc.
        MSW Version is currently running on msw is of form 4.2 or 4.2.c1-10 etc, which
        we get with command "gis -v"

        Returns 0 if the versions match, 1 if the MSW version is greater than the 
        the given Release version, -1 if the MSW version is less than the given Release version
        and -99 if there was an error
        
        relVersion -- Release version string against which the MSW iServer version is to be compared  
        """
        # 28762
        # c-releases being the customer release given the value -1, the highest value 
        # t-releases being the trial version given the value of -2
        # and d-releases the developer release given the value of -3. as d<t<c
        
        # The supplied release number with characters can be of form 4.2d1-3, 4.2t1-3,4. 2c1-3 etc.
        # with values -, d, t and c in release name are replaced by '.', '.-1.', '.-2.' and '.-3.' resp.
        # A release name can't be of form 4.2.d1-3 etc. 
        # Ticket 37941 to handle m builds 
        relVersion = relVersion.replace('-','.').replace('rc','.-5.').replace('c','.-1.').replace('t','.-2.').replace('d','.-3.').replace('m','.-4.')
       
	#Changes for 8.1.N and 8.1B releases
        relVersion = relVersion.replace('N','').replace('B','').replace('T','')
 
        # The msw version number with characters can be of form 4.2.d1-3, 4.2.t1-3, 4.2.c1-3 etc.
        # Values -, d, t and c in msw version number are replaced by '.', '-1.', '-2.' and '-3.' resp.
        # A msw version number can't be of form 4.2d1-3 etc. 
        mswVersion = self.iVersion
        mswVersion = mswVersion.replace('-','.').replace('rc','.-5.').replace('c','-1.').replace('t','-2.').replace('d','-3.').replace('m','-4.')
	
	#Changes for 8.1.N and 8.1B releases
        mswVersion = mswVersion.replace('N','').replace('B','').replace('T','')
	
	# Using the split method for splitting the  msw version and release version with '.' as splitter
        verInputList = relVersion.split('.')
        verList = mswVersion.split('.')
        result = 0
        try:
            # Compare the MSW Version with Release Version number
            for i in range(len(verInputList)):
                if (int(verList[i]) < int(verInputList[i])):
                    self.log.debug('checkiServerVersion: Release Version %s is greater than iServer Version %s' %(relVersion,mswVersion))
                    result = -1
                    break
                elif (int(verList[i]) > int(verInputList[i])):
                    self.log.debug('checkiServerVersion: Release Version %s is less than iServer Version %s' %(relVersion,mswVersion))
                    result = 1
                    break
           # Handle the case when the input Release version contains lesser number
           # of numeric values compared to actual. Example: 4.2 and 4.2.1
            if (result==0):
                if (i+1) <= (len(verList)-1):
                    if int(verList[i+1]) > 0:
                       self.log.debug ('checkiServerVersion: iServer Version %s is greater than Release Version %s' %(mswVersion,relVersion))
                       return 1
                self.log.debug ('checkiServerVersion: iServer Version %s matches Release Version %s' %(mswVersion,relVersion))

            return result


        except IndexError:
            # If the version matched in the comparison made so far,then return 
            # -1. This is because, in this case the actual version is less than
            # the supplied Release version and they are not equal. 
            # For ex: 4.2(actual) is less than 4.2.1(supplied) and not equal
            if result == 0:
                return -1
            else: 
                return result
        
        
        
        except ValueError:
            # If the iServer Version if something like 4.1.m4 and the input string is 3.1.2, then while comparing
            # the third level, an Exception will be thrown as m4 is not an integer. Process such errors.
            self.log.error("Error in checkiServerVersion: The Release version %s supplied is wrong"  %relVersion)  
            return -99 


        except Exception,e:
            # To catch any other exception
            self.log.error("ERROR comparing iServer versions - %s" %str(e))
            return -99 

    # 36319 - Added a new function to get the HK information from MSW
    def getHKInfo(self):
        """
        Gets the IP address and MAC address of the the first two ports of
        Hotknife from MSW using statclient commands. The function does not take
        any input and does not return any value. It sets the value of the member
        variables, self.hkMAC[0], self.hkMAC[1], self.hkIP[0] and self.hkIP[1].
        """

        try:
            # Clear the previous prompts
            clear = False
            while(clear == False):
                res = self.ssh.expect([self.prompt,pexpect.TIMEOUT],.5)
                if (res == 1):
                    clear = True

            # Find the HK MAC Addresses using statclient command 
            self.ssh.sendline("statclient showethif | awk '{print $6}'")
            self.ssh.expect(self.prompt,60)
            hkMACStr = self.ssh.before
            hkMACList = hkMACStr.split('\r\n')
            if hkMACList[0].__contains__('| awk'):
                hkMACList.pop(0)

            self.hkMAC[0]=hkMACList[0]
            self.hkMAC[1]=hkMACList[1] 

            # Find the HK IP Addresses using statclient command
            self.ssh.sendline("statclient showipif | awk '{print $2}'")
            self.ssh.expect(self.prompt,60)
            hkIPStr = self.ssh.before
            hkIPList = hkIPStr.split('\r\n')
            if hkIPList[0].__contains__('| awk'):
                hkIPList.pop(0)

            self.hkIP[0]=hkIPList[0]
            self.hkIP[1]=hkIPList[1]

        except Exception,e:
            self.log.error('getHKInfo: %s' %str(e))
            print str(e) 
            self.hkMAC[0]=''
            self.hkMAC[1]=''
            self.hkIP[0]=''
            self.hkIP[1]=''

class CoreWatcher(Thread):
    """Thread object that terminates testing if a core file is seen.

    This object will run in the background during testing, checking at regular
    intervals for files named "core*" on the specified host.

    host -- the name or IP address of the host to watch
    #38747 
    context -- the variable holding userconfig parameters

    engine -- a QMTest ExecutionEngine object

    If a core file is detected, the exection engine will be requested to stop.
    """
    # Watcher states

    INIT = "INITIALIZED"
    CONNECTED = "CONNECTED"
    STOPPING = "STOPPING"
    DISCONNECTED = "DISCONNECTED"
    # Fix for Ticket #26365 
    # Ticket 28643: Inclusion of the argument 'stopOnCore' to control
    # further testcase execution upon core detection.
    #34036 - Changed the default value of stopOnCore as String instead of Boolean
    #since the value of userConfig parameters are returned as string
    # For ticket 34247 parameters login and password are added for user authentication 
    # while sending mails.
    
    #38747 - Added input paramter context
    def __init__(self, host, context,engine=None,toaddrs=None,fromaddr=None,\

                 mailserver=None,stopOnCore='True',login=None, passwd=None):


        """
        Initialization function of CoreWatcher
        
        The Arguments are

        host -- the name or IP address of the host to watch
        context -- context variable having userconfig parameters
        engine -- a QMTest ExecutionEngine object
        tomaddr -- Recipients addresses
        fromaddr -- Sender address
        mailserver -- name of the mailserver
        login      --  Login name for user authentication while sending mail
        passwd    --  Password for the above given login name.
        """   
 
        Thread.__init__(self, name="core_watch")
        self.log = logging.getLogger('nextestlog')
        self.loglevel = self.log.getEffectiveLevel()
        self.host = host
        #43909 
        self.hostaddrs = None
        hostname, hostnames, self.mymswip = socket.gethostbyaddr(self.host) 

        self.engine = engine
        self.interval = 5
        self.q = Queue()
        self.state = self.INIT
        # Fix for Ticket #26365,object of mailer is created and three
        # parameters are passed to mailer. 
        # two more parameters login and passwd  added for user authentication 
        # for ticket 34247
        self.mailObj=mailer.Mailer(toaddrs,fromaddr,mailserver,login,passwd)
        # The mswinfo RESOURCE has not been created yet, so create an mswinfo
        # object temporarily so as to obtain the OS type:
        # For Ticket #26365 mswinfo changed to self.mswinfo
        #38747 - Removed hardcoded value
        self.mswinfo = MSWInfo(host)
        #34036 Intializing the path of the core based on iserver versions 
        self.verCheck_3_0 = self.mswinfo.compareiServerVersion('3.0')
        self.verCheck_4_0 = self.mswinfo.compareiServerVersion('4.0')
        if ((self.verCheck_3_0 >= 0) and (self.verCheck_4_0 < 0)):
            self.corepath = '/opt/core/' 
        else:
            self.corepath = '/var/core/'
        self.logpath  = '/var/log/'
        self.sympath  = '/root/nextone/builds/'
        # Ticket 28643: Flag for controlling testcase execution 
        # upon core detection
        self.stopOnCore = stopOnCore
        # Ticket 28643: Variable to contain the latest generated core file
        self.lastCoreFile = None
        # 34036 - Intialization  
        #38747  - Removed hardcoded value
        login = 'root' + '@' + self.host
        self.msw  = SSH([login]) 
        #34951 - Removed the hardcoded path and used the member variable
        self.initCoreCount = self.msw.filter('ls %s | wc -l'%self.corepath)
        self.initCoreCount = self.initCoreCount.strip('|')
        self.newCoreCount = self.initCoreCount
        self.cores=''
        self.listcmd = "ls -lrt %s | awk '{print $9}'" %self.corepath
        self.origCoreFiles = self.msw.filter(self.listcmd)
        #38747
        self.context = context


    def request(self, msg):
        "Put a request into the input queue"
        if self.state == self.CONNECTED:
            self.q.put(msg)
        else:
            self.log.info("CoreWatcher: state %s, ignoring request" % self.state)
            
    def run(self):
        """Main thread code.

        After connecting to the host with SSH, enter a loop.  The loop
        monitors the /var/core directory on the host at regular intervals.  If
        any file appears that starts with "core", ask the QMTest execution
        engine to stop and terminate the loop.

        If no core files are found, process messages in the input queue (stop
        is the only message currently used) and go to sleep.  When all tests
        have finished, he caller (QMTest cmdline module) must request a STOP.

        Regardless of the method of loop termination, the remote shell will be
        disconnected prior to exiting the thread.
        """        
        self._connect()
        msg = 'monitoring %s at %d second intervals' % (self.host,
                                                        self.interval)
        self.log.info('CoreWatcher: %s' % msg)
        while self.state == self.CONNECTED:
            try:
                core = self._checkCoreFile()
            #14000
            except OSError,e:
                # For some reason, after tests are finished, the sendline()
                # in checkCoreFile() fails with:
                #
                # File "...site-packages/pexpect.py", line 439, in send
                # return os.write(self.child_fd, str)
                # OSError: [Errno 9] Bad file number
                #
                # The ssh connection is still up but we've lost track of it.
                # This may be something to do with NexTest tearing down the
                # logicial IP interfaces on Solaris?  Anyway, hack for now:
	        # get out of the loop and shut down the connection.
                #14000 
                self.log.debug('CoreWatcher: Exception: %s - caught OSError, shutting down' % str(e))
                break
                
            if core:
                # Ticket 28643: Stop the execution engine only if the parameter
                # stop_on_core is set to True in userConfig.cfg file
                if (self.stopOnCore == 'True'):
                    self.log.error('CoreWatcher: requesting execution termination')
                    print("\n****** STOPPING THE EXECUTION  ******\n")
                    if self.engine:
                        self.engine.RequestTermination()
                        # 43909 Stopping the corewatcher thread if stopOnCore is True
                        if self.engine.watcher_bkup:
                            self.engine.watcher_bkup.request('STOP')
                        if self.engine.watcher:
                            self.engine.watcher.request('STOP')
                    self.state = self.STOPPING
                    self._disconnect()
                    

                ###
                # Fix for Ticket #26365, 
                # calling the sendMail function of that Mailer class.Also defining
                # subject of the mail and enclosed message as the argument
                # of send function.
                ###
                subject = "Core Detected"
                version,nfs = self.mswinfo.getVersions()
                # Fix for ticket #27628 to add more info to the mail
                #34036 
                #38747 - Changed mymsw to self.host
                msg = "Hi,\r\n\r\nCore detected in the release %s of iServer.\
                      \r\nHere is more info:\r\n\r\nSUT IP Address:%s\r\nGEN IP Address:%s\
                      \r\nCore file location:%s\r\nCore file name:%s\r\nTime core was generated:%s\
                      \r\niserver.log location:%s\r\nsymbol table is in:%s%s\r\n\r\nRegards\
                      \r\nSIT Team"%(version,socket.gethostbyname(self.host)\
                      ,socket.gethostbyname('mygen'),self.corepath,self.cores\
                      ,time.asctime(),self.logpath,self.sympath,version)
                self.mailObj.sendMail(subject,msg)

                # Ticket 28643: If parameter stop_on_core is set to False in 
                # userConfig.cfg file, then allow gis to be restarted and
                # continue with testcase execution
                if (self.stopOnCore == 'False'):
                   #38747 Enabling swap Flag during the presence of core 
                   if (self.context['nextest.scm_configuration'] == 'ON'): 
                       sleep(30)
                       self.ssh.sendline('pidof gis')
                       self.ssh.expect(self.bashPrompt, 3)
                       out = self.ssh.before.split('\r\n')
                       del out[0] # deleting the command send
                       # If gis is not running, swap the MSW and BKUPMSW objects
                       # 43909 - Added code to check whether the core has been 
                       # generated on the active MSX 
                       if out[0] =='' and (self.hostaddrs[0] == self.mymswip[0]):
                           self.engine.swap = True  
                           if (os.path.isfile('/etc/hosts_scm') == True):
                               self.engine.revertBack = True
                           else:
                               self.engine.hostsFile = False                               
                               self.engine.bkupObj = None
                               self.engine.revertBack = False
                   else:
                       # Wait for some time to allow pm to restart gis
                       sleep(60)
                       #38747 Since the command pgrep -l gis returns the output
                       # for provesses gis and gis_sa modified the following code
                       self.ssh.sendline('pidof gis')
                       self.ssh.expect(self.bashPrompt, 3)
                       out = self.ssh.before.split('\r\n')
                       del out[0] # deleting the command send
                       # If gis has not been restarted, restart the iserver
                       if out[0] == '':
                           self.ssh.sendline('iserver all stop')
                           self.ssh.expect(self.bashPrompt,40)
                           self.ssh.sendline('iserver all start')
                           self.ssh.expect('Nextone iServer is being started',90)
                           self.ssh.expect(self.bashPrompt, 2)
                           time.sleep(5)
                           #38747 Since the command pgrep -l gis returns the output
                           # for provesses gis and gis_sa modified the following code
                           self.ssh.sendline('pidof gis')
                           self.ssh.expect(self.bashPrompt, 3)
                           out = self.ssh.before.split('\r\n')
                           del out[0] # deleting the command send
                           if out[0] == '':
                               self.log("gis is not running")
                               raise MSWError("gis is not running")

                continue
            try:
                msg = self.q.get_nowait()
            #14000
            except Empty, e:
                self.log.debug("CoreWatcher:Exception: %s -  no messages to process" % str(e))
            else:
                # only one kind of message for now: STOP
                self.log.info("CoreWatcher: processing message %s" % msg)
                self.state = self.STOPPING
                continue
            time.sleep(self.interval)

        # Loop complete.  Clean up.
        self._disconnect()
            
    def _connect(self):
        "Connect to the remote host with ssh."
        time.sleep(5)   # Some kind of intermittent startup problem
        sshConnect = "ssh %s@%s" % ('root', self.host)
        self.bashPrompt = "[$#] "
        
        self.ssh = pexpect.spawn(sshConnect)
        try:
            self.ssh.expect(self.bashPrompt,int ( globalVar.sshTimeout))
        except pexpect.TIMEOUT:
            msg = "CoreWatcher: failed to connect to %s" % self.host
            self.log.error(msg)
            raise Exception(msg)
        
        self.state = self.CONNECTED
        self.log.info("CoreWatcher: connected to %s" % self.host)
        
    def _disconnect(self):
        "Disconnect from remote host and kill pexpect process."
        
        if self.state != self.DISCONNECTED:
            try:
                self.ssh.sendline('exit')
            #14000
            except OSError,e:
                self.log.debug("CoreWatcher: Exception: %s - problems disconnecting" % str(e))
                self.ssh.kill(signal.SIGKILL)
            self.state = self.DISCONNECTED
            self.log.info("CoreWatcher: disconnected from %s" % self.host)


    def _checkCoreFile(self):
        """Tell the caller if a core file is found by looking at contents of
        var/core on remote host.
        """
        #34951 - Added to Clear the buffer so that the output of the
        # previous command is eatenup
        self.msw.assertCommand('')
        #34036 - Modified this method to check for the latest core file
        #which is compatible on all the versions of iserver
   
        #34951 - Removed the hardcoded path and used the member variable
        self.newCoreCount = self.msw.filter('ls %s | wc -l'%self.corepath)
        self.newCoreCount = self.newCoreCount.strip('|')
        if int(self.newCoreCount) > int(self.initCoreCount):
            newCoreStr = self.msw.filter(self.listcmd)
            modCoreStr = newCoreStr
            # On Linux, . is also present in the output which needs to be removed
            tmpStr = self.origCoreFiles.rstrip('.\r\n')
            tmpStr = tmpStr.rstrip('\r\n')
            #34951 Added code to remove the .\r\n which is present
            tmpStr = tmpStr.replace('..\r\n','$$')
            tmpStr = tmpStr.replace('.\r\n','')
            tmpStr = tmpStr.replace('$$','..\r\n')
            # Remove the old core files from the string to find out the name(s) of the
            # new core files
            newCoreStr = newCoreStr.replace(tmpStr,'')
            newCoreFilesList = newCoreStr.split('\r\n')

            for coreFile in newCoreFilesList:
                if coreFile.startswith('core') or coreFile.startswith('gcore'):
                    self.cores = coreFile
                    hostname, hostnames, self.hostaddrs = socket.gethostbyaddr('mymsw')
                    #43909 - Added to print the IPAddress of MSX on which the core
                    #has been generated
                    self.log.error("CoreWatcher: ****** CORE DETECTED ON %s ******" %self.mymswip[0])
                    self.log.error('CoreWatcher: %s' % coreFile)
                    self.log.error('CoreWatcher: ***************************')
                    # 43909 Print the message on the screen if there is a core 
                    print "\n****** CORE FILE DETECTED ON %s ******\n" %self.mymswip[0]


            # Re-initialise the counters
            self.initCoreCount = self.newCoreCount.strip('|')
            self.origCoreFiles = modCoreStr

            # Ticket 28643: Additional display message for continuation
            if (self.stopOnCore == 'False'):
                print "\n****** CONTINUING WITH THE EXECUTION  ******\n"
            return True

        self.log.debug("CoreWatcher: no core files detected")
        return False
        
########################################################################
# Local Variables:
# mode: python
# indent-tabs-mode: nil
# fill-column: 78
# auto-fill-function: do-auto-fill
# End:
