import os
import pexpect
import signal
import socket
import string
import time
from session import *
from msw import *
import globalVar

class SessionException(Exception):
    "Generic exception for all sessions.  Accepts a string."
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class LeakWatcher(object):
    # Watcher states

    INIT = "INITIALIZED"
    CONNECTED = "CONNECTED"
    STOPPING = "STOPPING"
    DISCONNECTED = "DISCONNECTED"
    SSHCONNECTED = "SSHCONNECTED"
    MEMSTART = "mem_start"
    MEMSTOP = "mem_stop"
    REMOTE_RESULTS = "/tmp/malloc.results"
    LOCAL_RESULTS = "./malloc.results"
    # 27286 - Path for the scripts has been provided wrongly 
    # hence changed the path
    SCRIPTS = "/var/opt/nextest/tdb/negative.qms/protos.qms/scripts"
    telnetPrompt = "iServer >"
    bashPrompt = "[$#]"
    def __init__(self, host,resultdir=None):
        self.host = host
        self.state = self.INIT
        self.telnetstate = self.INIT
	if resultdir is not None:
		self.LOCAL_RESULTS = resultdir

    def initialize(self,verCheck4_2,scmConf=False):
        """
        To Do: Check whether dmalloc gis is there.
               Send a test message at host ip:5060, see if host is responding
        """
        self.verCheck = verCheck4_2 
        try:
            self._connect()		#connecting to MSW(SSH session)
        #14000    
        except Exception,exc:
            msg = "Exception Caught: %s" %str(exc)
            #34951 - Changed to fix the error generated during protos test
            self.log(msg)
            raise exc
        os.system('scp %s/* root@%s:/tmp' %(self.SCRIPTS,self.host))
        self.ssh.sendline('rm -r %s' %self.REMOTE_RESULTS)
        self.ssh.expect(self.bashPrompt)
        self.ssh.sendline('mkdir %s' %self.REMOTE_RESULTS)
        self.ssh.expect(self.bashPrompt)
        #os.system('rm -r %s' %self.LOCAL_RESULTS)
        #os.system('mkdir %s' %self.LOCAL_RESULTS)
        self.ssh.sendline('cd /tmp')
        self.ssh.expect(self.bashPrompt)
        self.ssh.sendline('iserver all stop')
        # 27286 - iserver versions greater than or equal to 
        # 4.0 requires more time to stop the iserver hence
        # increased the timeout value
        self.ssh.expect(self.bashPrompt,int(globalVar.iserverStopTimeout))
        self.ssh.sendline('source /tmp/dmlopt')
        self.ssh.expect(self.bashPrompt)
        self.ssh.sendline('iserver all start')
        # 27286 - iserver versions greater than or equal to
        # 4.0 requires more time to start the iserver hence
        # increased the timeout value

        self.ssh.expect('Nextone iServer is being started',int(globalVar.iserverStartTimeout))
        self.ssh.expect(self.bashPrompt, 2)
        time.sleep(5)
        self.ssh.sendline('pgrep -l gis')
        self.ssh.expect(self.bashPrompt, 3)
        out = self.ssh.before.split('\r\n')
        del out[0] # deleting the command send
        # given sufficient time for gis to start
        if string.find(out[0],"gis") == -1:
            self.log("gis is not running")
            raise SessionException("gis is not running")
        self.ssh.sendline('echo > /tmp/mymalloc.inuse')

        # 39531 - Restart secondary also so that primary will become active
        if (scmConf=="ON"):
            bkup = SSH(['root@bkupmsw']) 
            bkup.assertCommand('iserver all stop',timeout=int(globalVar.iserverStopTimeout))
            bkup.assertCommand('iserver all start',timeout=int(globalVar.iserverStartTimeout))
            time.sleep(5)
            bkup.disconnect()

        try:
            self._telnet()		#SSH to MSW and telnet to port 10005
        #14000
        except Exception,exc:
            msg = "Exception Caught: %s" %str(exc)
            #34951 - Changed to fix the error generated during protos test
            self.log(msg)
            raise exc
        self.getTsm()		#get TSM state and check for 0 call status
        self.sendDMcmd(self.MEMSTART)		#instruct dmalloc to start memory logging

    def getTsm(self):
        cmd = 'get tsm'
        # 39531 - Use 'get timers' command for 4.2 and later versions of iserver  
        if (self.verCheck >= 0):
            cmd = 'get timers'
        result = 'TSM invs=0, invc=0, byes=0, byec=0, cs=0, cc=0'

        if self.telnetstate == self.CONNECTED:
            self.telnet.sendline('')
            self.telnet.expect(self.telnetPrompt)
            self.telnet.sendline(cmd)
            match = self.telnet.expect([result,self.telnetPrompt],2)
            if (match == 0) and (self.verCheck < 0):
                # eat the prompt which was received along with the result
                self.telnet.expect(self.telnetPrompt,2)
                return 'OK'
            elif (match == 1) and (self.verCheck >= 0):
                timerOut = self.telnet.before
                if timerOut.__contains__('TXN'):
                    return 'TSMERROR'
                else:
                    return 'OK'
            else:
                return 'TSMERROR'
        else:
            self.log("LeakWatcher: telnetstate %s, ignoring request" % self.telnetstate)

    def sendDMcmd(self,cmd=None,expected="iServer >"):
        if self.telnetstate == self.CONNECTED:
            self.telnet.sendline('')
            self.telnet.expect(self.telnetPrompt)
            self.telnet.sendline(cmd)
            self.telnet.expect(expected,10)
        else:
            self.log("LeakWatcher: telnetstate %s, ignoring request" % self.telnetstate)

    def request(self, msg, start=0, stop=0):
        if self.telnetstate == self.CONNECTED and msg == 'GETRESULTS':
            os.system('mkdir %s/tests.%s-%s' %(self.LOCAL_RESULTS, start, stop))
            
            if self.getTsm() == 'TSMERROR':
                print "TSM ERROR OCCURED"
                os.system('touch  %s/tests.%s-%s/TSMERROR' %(self.LOCAL_RESULTS, start, stop))
                os.system('echo \'TSM state:: %s\' > %s/tests.%s-%s/TSMERROR' %(self.telnet.before,self.LOCAL_RESULTS,start,stop))
             
            self.sendDMcmd(self.MEMSTOP)
            time.sleep(1)
            self.ssh.sendline('cp /tmp/mymalloc.inuse %s/malloc.inuse' %self.REMOTE_RESULTS)
            self.ssh.expect(self.bashPrompt)
            self.ssh.sendline('cd /tmp')
            self.ssh.expect(self.bashPrompt,5)
            self.ssh.sendline('/tmp/dmallout.pl > %s/dmallout.txt' %self.REMOTE_RESULTS)
            self.ssh.expect(self.bashPrompt,5)
            time.sleep(3)
            os.system('scp -q root@%s:%s/*  %s/tests.%s-%s' %(self.host,self.REMOTE_RESULTS,self.LOCAL_RESULTS, start, stop))
            self.ssh.sendline('echo > /tmp/mymalloc.inuse')
            self.ssh.sendline('echo > %s/malloc.inuse' %self.REMOTE_RESULTS)
            self.ssh.sendline('echo > %s/dmallout.txt' %self.REMOTE_RESULTS)
            self.ssh.expect(self.bashPrompt)
            self.sendDMcmd(self.MEMSTART)

        elif msg == 'STOP':
            self._disconnect()
            if self.telnetstate == self.CONNECTED:
                self.telnet.sendline('bye')
                try:
                    match = self.telnet.expect("Connection closed by foreign host.",10)
                    if match == 0: 
                        self.telnet.expect(self.bashPrompt,2)
                    self.telnetstate = self.SSHCONNECTED
                except pexpect.TIMEOUT:
                    self.log("Leakwatcher: error exiting from telnet")
            if self.telnetstate == self.SSHCONNECTED:
                try:
                    self.telnet.sendline('exit')
                    while self.telnet.isalive():
                        self.telnet.kill(signal.SIGKILL)
                        time.sleep(1)
                    self.log("LeakWatcher: telnet(SSH) session disconnected from %s" % self.host)
                #14000
                except OSError,e:
                    self.log("LeakWatcher: Exception: %s - problems disconnecting" % str(e))
                    self.telnet.kill(signal.SIGKILL)
            self.telnetstate = self.DISCONNECTED
        else:
            self.log("LeakWatcher: request: invalid request")

    def log(self, message):
        print message

        
    def _telnet(self):
        "Connect to the remote host with ssh."
        
        sshConnect = "ssh %s@%s" % ('root', self.host)
        self.telnet = pexpect.spawn(sshConnect)
        try:
            self.telnet.expect(self.bashPrompt, 5)
            self.telnetstate = self.SSHCONNECTED
        except pexpect.TIMEOUT:
            raise SessionException("Leakwatcher:telnet: Error connecting to host %s" %self.host)
        time.sleep(1)
        # 27286 - Changed telnet to 127.0.0.1 instead of 0
        # Because it is not woking for iserver versions
        # greater than or equal to 4.0
        self.telnet.sendline('telnet 127.0.0.1 10005')
        try:
            self.telnet.expect(self.telnetPrompt, 5)
        except pexpect.TIMEOUT:
            raise SessionException("Leakwatcher: Error telnetting to host %s" %self.host)
        self.telnetstate = self.CONNECTED
        self.log("LeakWatcher: telneted to %s at port 10005" % self.host)

    def _connect(self):
        "Connect to the remote host with ssh."
        
        sshConnect = "ssh %s@%s" % ('root', self.host)
        self.bashPrompt = "[$#]"
        self.ssh = pexpect.spawn(sshConnect)
        try:
       	    self.ssh.expect(self.bashPrompt, 5)
        except pexpect.TIMEOUT:
            raise SessionException("Leakwatcher: Error connecting to host %s" %self.host)
        self.state = self.CONNECTED
        self.log("LeakWatcher: connected to %s" % self.host)
        
    def _disconnect(self):
        "Disconnect from remote host and kill pexpect process."
        
        if self.state != self.DISCONNECTED:
            try:
                self.ssh.sendline('exit')
                while self.ssh.isalive():
                    self.ssh.kill(signal.SIGKILL)
                    time.sleep(1)
            #14000
            except OSError,e:
                self.log("LeakWatcher: Exception: %s - problems disconnecting" %str(e))
                self.ssh.kill(signal.SIGKILL)
            self.state = self.DISCONNECTED
            self.log("LeakWatcher: disconnected from %s" % self.host)

        
########################################################################
# Local Variables:
# mode: python
# indent-tabs-mode: nil
# fill-column: 78
# auto-fill-function: do-auto-fill
# End:
