"Manage interaction with a command line interpreter or remote shell"

from dlog import *
import logging
import os
import pexpect
import re
import signal
import string
import sys
import tempfile
import threading
import time
import globalVar
import mswSCMConfigInterface


CTRL_C = '\x03'

class SessionException(Exception):
    "Generic exception for all sessions.  Accepts a string."
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)
        
class SessionCommandError(Exception):
    "Error sending or executing a command."
    def __repr__(self):
        return "The session prompt was not seen in the output."
    
class Session(object):
    """Abstract base class for session operations.  Although the public
    methods are implemented, the session specific private methods must
    be defined by descendents of Session.
    """
    def __init__(self, command, args, prompt, parent=None, timeout=0 ,context=None ):
        """
        Construct a new session by 'connecting' to a command via
	pexpect and then doing whatever negotiations are necessary to
        establish positive contact.

        
        command  -- command or path to command that the session will run

        args     -- command line options and arguments

        prompt   -- the prompt that precedes each user input

        parent   -- the session object that contains the spawned
                    expect process that this new session will attach to

        timeout  -- default timeout for expect() calls [30 seconds]

        WARNING  do not use the args argument when calling this class if
        WARNING  you are running the call gens.  pexpect is doing
        WARNING  something weird with the arguments and, since the gens
        WARNING  are primitive in their handling of argument strings,
        WARNING  best to create all of them in a fixed string and pass
        WARNING  that in as the command to run.  args should be an empty
        WARNING  list [].
        """
        self.log = logging.getLogger('nextestlog')
        if parent:
            self.spawnProc = parent.spawnProc
            self.isChild = True
        else:
            self.isChild = False
        self.context = context
        self.command = command
        self.args = args
        self.prompt = prompt
	# 29725
        self.sshTimeout = int ( globalVar.sshTimeout)
	if (timeout != 0) :
	    self.sshTimeout = timeout
        try:
            self._connect()
            
            # fix for ticket 15827 (EOF problem)
            # sleeping 1 second to give control to other processes
            time.sleep(2)

            # Checking if the spawned process lives. It is observed that the
            # spawned process for gen dies because of TIME_WAIT problem 
            # If the process had died, sleep for 60 secs so that the socket
            # is closed or binding is released (BSD implementation) 
            # Try spawning the process again, this time it should get thru.

            #Commenting as this leads to failure in sipp-PR 184675
            #if not self.spawnProc.isalive():
            #    self.log.error("Child not alive!!! TCP TIME_WAIT problem")
            #    time.sleep(60)
            #    self._connect()
            
	    self._postConnect()
        except pexpect.EOF:
            if self.spawnProc.isalive():
                self.log.error("got EOF but child is still alive!")
                raise SessionException("error starting %s" % command)
            else:
                self.log.warning("got EOF! will retry")
                self._postConnect()
        except Exception, e:
            msg = "session error: %s" % e
            self.log.error(msg)
            self.disconnect()
            raise e

    def assertCommand(self,command, expected=None, timeout = 0,
                      message=None):
        """
        Send a command to the process spawned by pexpect and wait for
        the expected output.

        If no expectation is provided, the prompt will be expected and
        any intervening output will be disregarded.
        
	The timeout value if passed as argument by the caller is 
	overridden, else the value of the assertTimeout variable
	specified in the userConfig.cfg is taken as default
       
        If the timeout is reached before the expected output is
        seen, AssertionError is raised and the assertion is false.
        If no exception is raised, then the assertion is assumed to be
        true.

        If the 'expected' argument is specified, a separate expect()
        must be issued to consume the next prompt.  If we don't do this,
        subsequent use of this method causes the command output to lag -
        the current call picks up the previous call's output.
        """
        self.log.debug('session.assertCommand: %s' % command)

        # 29725 - timeout check added
	# timeout variable being replaced by assertTimeout
	assertTimeout = int (globalVar.assertTimeout)
	if (timeout != 0) :
	    assertTimeout = timeout
	
        p = self.spawnProc
        eatPrompt = True
        if not expected:
            eatPrompt = False
            expected = self.prompt

            # 29006 - Eat the prompts of the previous commands
            clear = False
            while(clear == False):
                res = p.expect([self.prompt,pexpect.TIMEOUT],.5)
                if (res == 1):
                    clear = True
                else:
                    self.log.debug("assertCommand: Cleared output " + \
                                     "of previous command %s" %p.before)

        p.sendline(command)
        try:
            # 29725 - timeout variable being replaced by assertTimeout
            p.expect(expected, assertTimeout)
            self.log.debug('session.assertCommand: COMMAND: %s  ; RESULT_BEFORE: %s' %(command,p.before))
            self.log.debug('session.assertCommand: COMMAND: %s  ; RESULT_AFTER: %s' %(command,p.after))
            # 29725 - timeout variable being replaced by assertTimeout
            if eatPrompt: p.expect(self.prompt, assertTimeout)
        except pexpect.TIMEOUT:
            if not message:
                message = 'command "%s" timed out waiting for %s' % \
                          (command, expected)
            self.log.debug('session.assertCommand TIMEOUT: COMMAND: %s  ; RESULT_BEFORE: %s' %(command,p.before))
            self.log.debug('session.assertCommand TIMEOUT: COMMAND: %s  ; RESULT_AFTER: %s' %(command,p.after))
            raise AssertionError(message)
        return p.before
        # self._checkError()   see comments in _checkError()

    def issueCommand(self,command, timeout=3,
                      message=None):
        """
        Send a command to the process spawned by pexpect and and do
        not wait for anything.

        This command should not be used unless really necessary
        """
        self.log.debug('session.issueCommand: %s' % command)
        p = self.spawnProc
        p.sendline(command)
        # self._checkError()   see comments in _checkError()

    def assertOutput(self, expected=None, timeout=0, message=None):
       """
       Wait for the expected output from the spawned pexpect process.
       
       The timeout value if passed as argument by the caller is 
       overridden, else the value of the assertTimeout variable
       specified in the userConfig.cfg is taken as default
       
       This method sends nothing to the process but expects output;
       useful in cases where some event other than direct command input
       is causing the process to react.

       If expect times out, an AssertionError will be raised
       """
       
       self.log.debug('session.assertOutput: %s' % expected)
       # 29725 - timeout check added
       # timeout variable being replaced by assertTimeout
       assertTimeout = int (globalVar.assertTimeout)
       if (timeout != 0) :
	    assertTimeout = timeout
	    
       p = self.spawnProc
       if not expected:
           expected = self.prompt
       try:
           # 29725 - timeout variable being replaced by assertTimeout
           p.expect(expected, assertTimeout)
       except pexpect.TIMEOUT:
           if not message: message = 'timed out waiting for %s' % expected
           self.log.debug('session.assertOutput: p.before = %s' %p.before)
           raise AssertionError(message)

    def assertOutputList(self, expected=[], timeout=0, message=None):
       """
       Wait for one of the elements in the expected output list from the 
       spawned pexpect process.

       The timeout value if passed as argument by the caller is 
       overridden, else the value of the assertTimeout variable
       specified in the userConfig.cfg is taken as default

       Returns the index of the element that matched the output from the 
       spawned process. 
       If expect times out, an AssertionError will be raised.
       """

       self.log.debug('session.assertOutputList: %s' % expected)
       # 29725 - timeout check added
       # timeout variable being replaced by assertTimeout
       assertTimeout = int (globalVar.assertTimeout)
       if (timeout != 0) :
	    assertTimeout = timeout

       p = self.spawnProc
       if not expected:
           expected = self.prompt
       try:  
           # 29725 - timeout variable being replaced by assertTimeout
           return p.expect(expected, assertTimeout)
       except pexpect.TIMEOUT:
           if not message: message = 'timed out waiting for %s' % expected
           self.log.debug('session.assertOutputList: p.before = %s' %p.before)
           raise AssertionError(message)
        
    # 36319 - Added a new default parameter to omit the MAC address check for some cases
    def assertMedia(self, endpoint, timeout=0, msg=None, nat=None, checkHKipnat=True,checkNullMAC=True,checkBkup=False):
        """Verify that media is flowing.

        This method can check for media flow in two places.  The first place
        is locally, on the endpoints themselves.  This is accomplished by
        querying the endpoint with the 'mstat' command.  The second place is
        on the MSW.  This is accomplished by querying the system with ipnat or
        another mechanism for Hot Knife (TBD).
        """
        # Check for system override of media check

        # 29725 - timeout check added
        # timeout variable being replaced by mediaTimeout
        mediaTimeout = int (globalVar.mediaTimeout)
        if (timeout != 0) :
	     mediaTimeout = timeout
	    
        checkMedia = True
        if self.context.has_key('nextest.verify_media'):
            if self.context['nextest.verify_media'] == 'OFF':
                checkMedia = False
        if not checkMedia: return

        # 10409 - Update the endpoint member variable
        endpoint.verifyMedia = True

        #Assert the NAT translation for media calls on MSW
 
        mymswinfo = self.context['mswinfo']
        p = self.spawnProc
        ip=endpoint.addr
        rtpport=0

        # 36319 - Do not perform media verification on the endpoint, if its not gen/sgen
        if (endpoint.proto == 'sip' or endpoint.proto == 'h323'):
            rtpport=endpoint.getValue('mediaport')
            nataddr=endpoint.getValue('nataddr')
            if not nataddr:
                nataddr=endpoint.addr
            rtcpport=rtpport+1
            self.log.info("assertMedia: checking endpoint media on %s" % ip)

            # assert media on call gens using mstat Rx command

            gencmd="mstat Rx"
            mstatresult ="[1-9][0-9]+ *bytes"
            expectstr2=re.compile(mstatresult)
            if not msg:
                more_msg = ip
            else:
                more_msg = "%s(%s)" % (ip, msg)
            genmsg = "No media is received by %s" % (more_msg)
            # Handle the exceptions so that the script execution will not be stopped
            try:
                # 29725	
                endpoint.assertCommand(gencmd, expectstr2, timeout = mediaTimeout, message=genmsg)
            except Exception,e:
                self.log.error(genmsg)
                self.log.error("Exception - %s" %str(e))
                endpoint.mediaResult.append(False)
                return
            self.log.info('assertMedia: endpoint media OK for %s' % ip)
        
        # check media on MSW, only if specifically requested and not hotknife

        # 43832 Media Verification on NSF setup
        if (mymswinfo.nsf and mymswinfo.fwname == "MS" and checkHKipnat):
            self.assertNsfMedia(endpoint,msg,mediaTimeout,nat)
            return
        
        if (mymswinfo.nsf and checkHKipnat) or (nat and mymswinfo.fwname != "HKNIFE" and mymswinfo.fwname !="MS"):
            self.log.info('assertMedia: checking e1000g media with "ipnat"')
            cmd="ipnat -l"
            
            if mymswinfo.nsf:
                if (endpoint.proto != 'ohphone'):		
                    baseMatch = "rdr *eth[45],?e?t?h?[45]? *[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\/32 *port *[0-9]+ *-> *eth[45] *%s *port *%s *udp"
                    checkRtp = baseMatch % (ip,rtpport)
                    checkRtcp = baseMatch % (ip,rtcpport)
                    checkRedir="RDR *%s *[0-9]+ *<- *-> *[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ *[0-9]+ *\[[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ *[0-9]+\]" %nataddr
                else: 
                    baseMatch = "rdr *eth[45],?e?t?h?[45]? *[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\/32 *port *[0-9]+ *-> *eth[45] *%s *port *[0-9]+ *udp"
                    checkRtp = baseMatch % (ip)
                    checkRtcp = baseMatch % (ip)

                    checkRedir="RDR *%s *[0-9]+ *<- *-> *[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ *[0-9]+ *\[[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ *[0-9]+\]" %endpoint.addr
            else:
                baseMatch = "rdr *e1000g[23] *[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\/32 *port *[0-9]+ *-> *%s *port *%s *udp"
                checkRtp = baseMatch % (ip,rtpport)
                checkRtcp = baseMatch % (ip,rtcpport)
                checkRedir="RDR *%s *DNT *[0-9]+ *<- *-> *[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ *[0-9]+" %nataddr

            rtp=re.compile(checkRtp)
            rtcp=re.compile(checkRtcp)
            redir=re.compile(checkRedir)
    		
            if not msg:
                more_msg = ip
            else:
                more_msg = "%s(%s)" % (ip, msg)
            natmsg = "No media NAT found for %s" % (more_msg)

            p.sendline(cmd)
	    # 29725
            # timeout variable being replaced by mediaTimeout
            p.expect(self.prompt, mediaTimeout)
            # Handle the exceptions so that the script execution will not be stopped
            try:
                self.assertCommand(cmd, rtp, message=natmsg)
                self.assertCommand(cmd, rtcp, message=natmsg)
                self.assertCommand(cmd, redir, message=natmsg)
            except Exception,e:
                self.log.error(natmsg)
                self.log.error("Exception - %s" %str(e))
                endpoint.mediaResult.append(False)
                return
            self.log.info('assertMedia: MSW media OK in both directions')

        # Ticket 25862 changes (similar to ticket 8854)
        elif (((mymswinfo.fwname == "HKNIFE") or (mymswinfo.fwname == "MS")) and checkHKipnat) and not mymswinfo.nsf:
            self.log.info('assertMedia: checking media on HK with "statclient"')
            # 36319 - Removed unused code
            # 29937 - Media verification should be done on NAT IP and port instead of 
            # endpoint IP for NAT feature.Hence modified this code
            if nat:
                ip = nataddr

            # 40746 - dumpRedir command will not work on Cavium cards
            # Re-initialise the HK MAC and IP if its empty
            if (mymswinfo.hkIP[0] == '' or mymswinfo.hkIP[1] == ''):
                mymswinfo.getHKInfo()

            # Error check
            if (mymswinfo.hkIP[0] == '' or mymswinfo.hkIP[1] == ''):
                self.log.error('Failed to find the HK IP and MAC!')
                endpoint.mediaResult.append(False)
                return

            hkmsg = "HK media check failed"
            if self.context.has_key('userConfig.media_card') and self.context['userConfig.media_card'] == 'Cavium':
                cmd = 'statclient hkipnat | grep %s/' %ip 
                # S9 : if statement to avoid exact validation
                # It was done because there are four media interfaces in S9. Two for public and two for private. Any one of those two interfaces can be used in a media call.
                if self.context['userConfig.automation'] == 's9':
                     patt1 = re.compile('RDR  *')
                     patt2 = re.compile('RDR  *')
                else:
                     patt1 = re.compile('RDR  hk[01],[01].*%s.*->.*hk[01],[01].*%s.*' %(mymswinfo.hkIP[0],ip))
                     patt2 = re.compile('RDR  hk[01],[01].*%s.*->.*hk[01],[01].*%s.*' %(mymswinfo.hkIP[1],ip))

                mediaStr = self.filter(cmd)
                mediaStr = mediaStr.strip('|')
                if patt1.match(mediaStr) or patt2.match(mediaStr):
                    endpoint.mediaResult.append(True)
                    return
                else:
                    # In some cases like OBP, there are two entries
                    mediaStrList = mediaStr.split('\r\n')
                    if len(mediaStrList) >= 2: 
                        if patt1.match(mediaStrList[1]) or patt2.match(mediaStrList[1]):
                            endpoint.mediaResult.append(True)
                            return  
                        #54804 - removed If statement for NAT to make it generic case for more than two redirects
                        # This also cover cases in which multiple m-line presents which result multiple redirects
                        for i in range(0,len(mediaStrList)):
                            if patt1.match(mediaStrList[i]) or patt2.match(mediaStrList[i]):
                                endpoint.mediaResult.append(True)
                                return
                    self.log.error(hkmsg)
                    endpoint.mediaResult.append(False)
                    return

            # Handle the exceptions so that the script execution will not be stopped
            try:
                # Verify whether the HK media IP,HK MAC are 
                # present in the statclient dumpRedir output
                # Also verify whether all the MAC addresses are resolved

                # Pad 0's to all the ips
                ipList = [ip,mymswinfo.hkIP[0],mymswinfo.hkIP[1]]
                for i in range(0,len(ipList)):  
                    tmpList = ipList[i].split('.')
                    for j in range(0,len(tmpList)):
                        tmpList[j] = tmpList[j].zfill(3) 

                    ipList[i] = '.'
                    ipList[i] = ipList[i].join(tmpList)

                # 41405 - Get the statclient output for the endpoint
                mediaStr = self.filter('statclient dumpRedir | grep %s' %ipList[0])

                if checkNullMAC:
                    # Check whether all the MAC addresses are resolved
                    chk2 = (mediaStr.count('00:00:00:00:00:00') == 0)
                else:
                    chk2 = True

                # Check whether HK IP is present
                chk3_1 = (mediaStr.count(ipList[1]) != 0)
                chk3_2 = (mediaStr.count(ipList[2]) != 0)
                chk3 = (chk3_1 or chk3_2)

                # Check whether HK MAC is present  
                if checkBkup:
                    bkinfo = self.context['bkupinfo']
                    # Re-initialise the HK MAC and IP if its empty
                    if (bkinfo.hkIP[0] == '' or bkinfo.hkIP[1] == ''):
                        bkinfo.getHKInfo()

                    # Error check
                    if (bkinfo.hkIP[0] == '' or bkinfo.hkIP[1] == ''):
                        self.log.error('Failed to find the HK IP and MAC on Backup MSW!')
                        endpoint.mediaResult.append(False)
                        return

                    chk4_1 = (mediaStr.count(bkinfo.hkMAC[0]) != 0)
                    chk4_2 = (mediaStr.count(bkinfo.hkMAC[1]) != 0)
                else:
                    chk4_1 = (mediaStr.count(mymswinfo.hkMAC[0]) != 0)
                    chk4_2 = (mediaStr.count(mymswinfo.hkMAC[1]) != 0)
                chk4 = (chk4_1 or chk4_2)
                if not (chk2 and chk3 and chk4):
                    self.log.error('statclient dumpRedir check on HK failed')
                    endpoint.mediaResult.append(False)
                    return
                

            except Exception,e:
                self.log.error(hkmsg)
                self.log.error("Exception - %s" %str(e))
                endpoint.mediaResult.append(False)
                return
            self.log.info('assertMedia: MSW HK media OK')

        # 10409 - No errors and hence append True to the mediaResult list 
        endpoint.mediaResult.append(True)

    #43832 Function to check media on MSW NSF setup
    def assertNsfMedia(self,endpoint,msg,mediaTimeout,nat):
        """Verify that media is flowing on NSF setup.

        This method checks for media flow on the MSW
        This is accomplished by querying the system with ipnat.
        """
        self.log.info('assertMedia: checking  NSF media with "ipnat" on MSW')
        ip=endpoint.addr
        nataddr=endpoint.getValue('nataddr')
        if not nataddr:
            nataddr=endpoint.addr
        cmd="ipnat -l"

        baseMatch = "rdr *eth[45],?e?t?h?[45]? *[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\/32 *port *[0-9]+ *-> *eth[45] *%s *port *[0-9]+ *udp"
        checkRtp = baseMatch % (ip)
        checkRtcp = baseMatch % (ip)
        if nat:
            checkRedir="RDR *%s *DNT *[0-9]+ *<- *-> *[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ *[0-9]+ *\[[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ *[0-9]+\]" %nataddr
        else:
            checkRedir="RDR *%s *[0-9]+ *<- *-> *[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ *[0-9]+ *\[[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ *[0-9]+\]" %nataddr

        rtp=re.compile(checkRtp)
        rtcp=re.compile(checkRtcp)
        redir=re.compile(checkRedir)

        if not msg:
            more_msg = ip
        else:
            more_msg = "%s(%s)" % (ip, msg)
        natmsg = "No media NAT found for %s" % (more_msg)
        p = self.spawnProc
        p.sendline(cmd)
        p.expect(self.prompt, mediaTimeout)
        # Handle the exceptions so that the script execution will not be stopped
        try:
            self.assertCommand(cmd, rtp, message=natmsg)
            self.assertCommand(cmd, rtcp, message=natmsg)
            self.assertCommand(cmd, redir, message=natmsg)
        except Exception,e:
            self.log.error(natmsg)
            self.log.error("Exception - %s" %str(e))
            endpoint.mediaResult.append(False)
            return
        self.log.info('assertMedia: MSW NSF media OK in both directions')
        endpoint.mediaResult.append(True)

    def assertCliSCM(self, totStat=0, pendStat=0, sentStat=0, errStat=0, timeout=0, msg=None):
        """
	Assert the cli SCM output
	
        The timeout value if passed as argument by the caller is 
        overridden, else the value of the cliTimeout variable
        specified in the userConfig.cfg is taken as default
	
	"""
	
        # 29725 - timeout check added
        # timeout variable being replaced by assertTimeout
        cliTimeout = int (globalVar.cliTimeout)
        if (timeout != 0) :
	     cliTimeout = timeout
	    
        p = self.spawnProc
            
        cmd="cli scm"
        #str1="SCM Total States                %s\nSCM Pending States              0\nSCM States successfully sent    %s\nSCM States failed               0" % (totalStates, totalStates)
        str1="SCM Total States                %s" % (totStat)
        str2="SCM Pending States              %s" % (pendStat)
        str3="SCM States successfully sent    %s" % (sentStat)
        str4="SCM States failed               %s" % (errStat)
        expectstr1=re.compile(str1)
        expectstr2=re.compile(str2)
        expectstr3=re.compile(str3)
        expectstr4=re.compile(str4)

        if not msg:
            msg = "cli scm output is not correct."

        p.sendline(cmd)
        # 29725 - timeout check added
        p.expect(self.prompt, cliTimeout)
        self.assertCommand(cmd,expectstr1,timeout = cliTimeout, message=msg)
        self.assertCommand(cmd,expectstr2,timeout = cliTimeout, message=msg)
        self.assertCommand(cmd,expectstr3,timeout = cliTimeout, message=msg)
        self.assertCommand(cmd,expectstr4,timeout = cliTimeout, message=msg)
      
    def filter(self, subcommand, pattern=None, check=False, delim=None):
        """
        Send a command and return filtered output.

        The check argument was an afterthought and is not used.
        """
        # 43731: Added new default argument
        self.log.debug(["session filter, error check set to", str(check)])
        self.log.debug(["filter command:", subcommand])
        # 22412 - Clear the buffer so that the output of the previous command(s) is
        # eaten up
        clear = False
        #43816 added new default arg delim
        if (not delim):
            prompt = self.prompt
        else:
            prompt = delim
        while(clear == False):
            res = self.spawnProc.expect([prompt,pexpect.TIMEOUT],.5)
            if (res == 1):
                clear = True
            else:
                self.log.debug("filter: Cleared output of previous command %s" %self.spawnProc.before)

        #43816 added arg delim
        output = self._sendAndTrim(subcommand,delim)
        output = self._applyFilter(output, pattern)
        if check: self._checkError()
        self.log.debug(output)
        return output


    # Function added to when large commands are spawned on the SBC
    #This modification was done for Sandy Bridge platform
    def filterLarge(self, subcommand, pattern=None, check=False, delim=None):
        """
        Send a command and return filtered output.

        The check argument was an afterthought and is not used.
        """
        # 43731: Added new default argument
        self.log.debug(["session filter, error check set to", str(check)])
        self.log.debug(["filter command:", subcommand])
        subcommand = subcommand+' >abc.txt;cat abc.txt'
        self.log.debug(["filter command after modification:", subcommand])
        # 22412 - Clear the buffer so that the output of the previous command(s) is
        # eaten up
        clear = False
        #43816 added new default arg delim
        if (not delim):
            prompt = self.prompt
        else:
            prompt = delim
        while(clear == False):
            res = self.spawnProc.expect([prompt,pexpect.TIMEOUT],.5)
            if (res == 1):
                clear = True
            else:
                self.log.debug("filter: Cleared output of previous command %s" %self.spawnProc.before)

        #43816 added arg delim
        output = self._sendAndTrim(subcommand,delim)
        output = self._applyFilter(output, pattern)
        if check: self._checkError()
        self.log.debug(output)
        return output






    
    def disconnect(self):
        """
        Disconnect from the session.  If we are a subsession, close
        the spawned pexpect process.  This method assumes the
        subsession has sent whatever commands necessary to end itself,
        so we expect an EOF here before the close.

        Expect the process to be closing or already closed, which
        generates an EOF.  Look # for a 2-second timeout also.

        If no spawnProc is defined, return quietly so that callers don't
        have problems when calling disconnect() more than once.
        """
        self.log.debug("Session: disconnect: ready to mop up")
        if not self.spawnProc:
            return
        
        p = self.spawnProc
        try:
	# 29725
            p.expect([pexpect.EOF], self.sshTimeout)
        #14000
        except OSError,e:
            self.log.error('Session disconnect: Exception: %s - caught OSError, sending SIGKILL' % str(e))
            p.kill(signal.SIGKILL)
            self.cleanUp()
        except pexpect.TIMEOUT:
            self.log.error('Session: disconnect: expect timeout, sending SIGKILL')
            p.kill(signal.SIGKILL)
            self.cleanUp()
        except Exception, exc: 
            self.log.error('Session: disconnect: caught %s ; sending SIGKILL' % exc)
            p.kill(signal.SIGKILL)
            self.cleanUp()
        self.log.debug('Session: disconnect: complete')
        self.cleanUp()
        
    def cleanUp(self):
        """Clean up all the resource created during the session creation"""
        self.isConnected=False
        self.spawnProc=None
        self.log.debug('Session: cleanUp: Session disconnected and resources cleaned up')

    def checkSCMStatus(self,bkupMSW):
        """ 
	Check whether the MSW is up and start the MSW if not.
        Verify whether the primary MSW is active, if not, restart the
        Back up MSW, so that the primary will become active 
	"""
        # 29725 timeout variable changed
        iserverStartTimeout = int (globalVar.iserverStartTimeout)
        iserverStopTimeout = int (globalVar.iserverStopTimeout)
	
        status = self.filter("iserver all status | grep -i 'no such process'")
        if status.lower().__contains__('no such process'):
            mswSCMConfigInterface.restartSCM(self)
            #bkupMSW.assertCommand('iserver all stop',timeout=iserverStopTimeout)
            #self.assertCommand('iserver all stop',timeout=iserverStopTimeout)
            #time.sleep(5)
            #self.assertCommand('iserver all start',timeout=iserverStartTimeout)
            #bkupMSW.assertCommand('iserver all start',timeout=iserverStartTimeout)
            #time.sleep(5)

        scmStat = True

        # 27597 - Verify whether the SCM stats show 0
        try:
            if ((self.getSCMStat('SCM States successfully sent') != 0) or \
                (self.getSCMStat('SCM Pending States') != 0) or \
                (bkupMSW.getSCMStat('SCM States successfully sent') != 0) or \
                (bkupMSW.getSCMStat('SCM Pending States') != 0)):
                scmStat = False

        except Exception,e:
            mswSCMConfigInterface.restartSCM(self)
            #bkupMSW.assertCommand('iserver all stop',timeout=iserverStopTimeout)
            #self.assertCommand('iserver all stop',timeout=iserverStopTimeout)
            #time.sleep(5)
            #self.assertCommand('iserver all start',timeout=iserverStartTimeout)
            #bkupMSW.assertCommand('iserver all start',timeout=iserverStartTimeout)
            #time.sleep(5)

            if ((self.getSCMStat('SCM Pending States') != 0) or \
                (bkupMSW.getSCMStat('SCM Pending States') != 0)):
                scmStat = False

        # 27597 - if not stop both the primary and secondary MSW and start them both
        #if not scmStat:
        if not scmStat:
            mswSCMConfigInterface.restartSCM(self)
            #self.assertCommand("iserver all stop",timeout=iserverStopTimeout)
            ##bkupMSW.assertCommand("iserver all stop",timeout=iserverStopTimeout)
            #time.sleep(5)
            #self.assertCommand("iserver all start",timeout=iserverStartTimeout)
            #bkupMSW.assertCommand("iserver all start",timeout=iserverStartTimeout)
            #time.sleep(5)

        # 27597 - Verify cli scm output
        priscmState = self.filter("cli scm")
        secscmState = bkupMSW.filter("cli scm")
        if ((not priscmState.lower().__contains__('active')) or \
            (not secscmState.lower().__contains__('standby'))):
            mswSCMConfigInterface.restartSCM(self)
            #bkupMSW.assertCommand("iserver all stop",timeout=iserverStopTimeout)
            #time.sleep(5)
            #bkupMSW.assertCommand("iserver all start",timeout=iserverStartTimeout)

        time.sleep(10)
    
    def getSCMStat(self, counterName):
        fil = self.filter('cli scm | grep "' + counterName + '"')
        statstr = fil.strip('|' + counterName)
        if counterName == 'Signaling State':
            statstr = statstr.strip('\t')
            statstr = statstr.strip('\n')
            statstr = statstr.strip('\r') 
            return statstr
        else:
            return int(statstr)


    def getUsedVPorts(self):
        """ Run the cli lstat command on the MSW session and return the number of used VPORTS"""
        usedvports = self.filter('cli lstat | grep "Used VPORTS"')
        usedvports = usedvports.strip('|')
        usedvports = usedvports.strip('Used VPORTS') 
        usedvports = usedvports.strip(' ')
        usedvports = usedvports.strip('\r')
        return int(usedvports)

    def getPrivatePorts(self, ep_ip, out):
        """ Run the cli lstat command on the MSW session and return the number of used VPORTS"""
        ports = []
        for line in out.split("\n"):
                if line.find(ep_ip) != -1:
                        m = re.search('(?<=port )\d+\s+\w+',line)
                        n = re.search('^\d+',m.group(0))
                        ports.append(n.group(0))
        return ports


    def getTxnHashTableCount(self):
        """ Run the cli cache info command on the MSW session and return the number of elements in glbHashTable"""
        cmd  = 'cli cache info /tmp/txnct1 2<&1 > /dev/null'
        cmd2 = 'grep glbhash /tmp/txnct1'
        self.assertCommand(cmd)
        output = self.filter(cmd2)
        o = output.split('[')
        hashcount =  o[1].split(']')[0]
        cmd3 = 'rm -f /tmp/txnct1'
        self.assertCommand(cmd3)
        return int(hashcount)

    def getIcmpCacheCount(self):
        """ Run the cli cache info command on the MSW session and return the number of elements in icmpCache"""
        cmdicmp  = 'cli cache info /tmp/icmpct1 2<&1 > /dev/null'
        cmdicmp2 = 'grep ICMP /tmp/icmpct1'
        self.assertCommand(cmdicmp)
        output = self.filter(cmdicmp2)
        o = output.split('[')
        icmpcount =  o[1].split(']')[0]
        cmdicmp3 = 'rm -f /tmp/icmpct1'
        self.assertCommand(cmdicmp3)
        return int(icmpcount)

    # 36553 
    def getVPorts(self,counterName):
        """
        Function used to find the value of the Vport counters returned by
        cli lstat command.
 
        counterName - Name of the 'cli lstat' counter(Total VPORTS,Available VPORTS
                      Used VPORTS,Total Media Routed VPORTS, Available Media Routed VPORTS,
                      Used Media Routed VPORTS)
 
        Returns the value of the vport value and returns -99 if any error is encountered.
        """
 
        try:
            vportsStr = self.filter('cli lstat | grep "' + counterName + '"')
            vportsStr = vportsStr.strip('|').strip(counterName)
            vportsStr = vportsStr.strip(' ').strip('\r')
            return int(vportsStr)
        except Exception,e:
            self.log.error('getPorts: Unable to find the value of counter %s' %counterName)
            return -99


             
        
    ############################################################
    # Internal methods below - may be overridden by descendents
    ############################################################
    def _applyFilter(self, input, pattern=None):
        """
        If a regular expression is supplied, apply it to the input
        string.  If not, just pass the input to the output.

        Currently does not do anything.  Override if necessary.
        """
        self.log.debug('session _applyFilter')
        # Not sure the regular expression handling should be in this
        # module.  Might be better left to other classes.
        if not pattern:
            return input
        
    def _checkError(self):
        """Get the status of the last command.

        TODO  Fix pexpect so this method works!
        TODO  pexpect's handling of compiled regular expressions appears
        TODO  to be broken.  Although the re works, it doesn't return
        TODO  expected results: try using the pattern '[0-9]+' to search
        TODO  for a sequence of one or more digits.  Works fine in the
        TODO  Python interpreter - gets all digits in a single match
        TODO  object group - but expect returns one digit at a time.
        """
        p = self.spawnProc
        cmd = 'echo $?'
        p.sendline('echo $?')
        regex = re.compile('^[0-9]+',re.M)
        p.expect(regex, 2)
        if p.after != '0':
            pass # raise some assertion here
        
    def _connect(self):
        """
        Run the command or spawn the process that is the basis for the
        session.  If we are a parent session, then create the new
        spawned process.  If we are a child, send the command to the
        existing subprocess.

        """
        # 29725 timeout variable changed
        if not self.isChild:
            self.log.debug('session._connect: command: "%s"' % self.command)
            self.log.debug('session._connect: args: "%s"' % self.args)
            msg = "Session._connect: failed to spawn %s%s" % (self.command, self.sshTimeout)
            try:
                self.spawnProc = pexpect.spawn(self.command,
                                               self.args,
					       self.sshTimeout)
		if not self.spawnProc:
                    self.log.error(msg)
                    raise SessionException(msg)
		self.log.debug('Session:Connect: Successfully spawned a process')
		self.isConnected = True
	    except pexpect.TIMEOUT:
                self.log.error("Timeout while " + msg)
		raise SessionException("Timeout while " + msg)
            except Exception, exc:
                self.log.error('Session._connect: caught %s' % exc)
		raise SessionException('Session._connect: caught %s' % exc)
        else:
            cmdline = self.command + ' ' + string.join(self.args,' ')
            self.spawnProc.sendline(cmdline)
	    self.isConnected = True

    def _extractPChunk(self, line):
        """ Extract the prompt from the program output.  This is for
        use with (expect) functions that determine end-of-output by
        waiting for the command prompt.  The problem is that the
        prompt (or a piece of it) is left in the output.  The
        extracted prompt chunk is used later in the trim functions.
        
        There was an attempt made at filtering out control characters
        embedded in the prompt but this code was removed.  Instead, it
        is advised that control characters be removed from the prompt on
        remote test systems."""
        self.log.debug('session _extractPChunk')
        chunk = string.split(line,'\n')[1]
        #pat='([^' + string.printable + '])'
        #chunk = re.sub(pat,'', chunk)  # remove non-printing chars
        self.promptChunk = chunk
        self.log.debug(['chunk:', self.promptChunk])

    def _postConnect(self):
        """ Do whatever expect operations necessary to establish
        positive contact with the command after connecting.  If
        overriding in a descendent, this method must set the
        promptChunk variable if using the default _sendAndTrim().
        """
        self.log.debug('session _postConnect')
        p = self.spawnProc
        msg = "Session._postConnect: failed to get prompt"
        try:
            # 29725 timeout variable changed
            match = p.expect([self.prompt, pexpect.EOF], self.sshTimeout)
        except pexpect.TIMEOUT:
            self.log.error(msg)
            raise pexpect.TIMEOUT
        
        if match ==0:
            # got a prompt, want to save the prompt chunk so we can use
            # it later to trim command output.  do this by sending a
            # \r and cultivating the bare prompt.
            p.sendline("")
            p.expect(self.prompt)
            self._extractPChunk(p.before)
        else:
            self.log.error(msg)
            raise SessionException(msg)
    
    def _sendAndTrim(self, command,delim=None):
        """
        General-purpose method that will send the command and trim
        the prompt from the output.  Override for subclasses that deal
        with non-prompting commands like call generators.
        """
        #43816 added new default arg delim
        if (not delim):
            prompt = self.prompt
        else:
            prompt = delim

        self.log.debug('session _sendAndTrim')
        p = self.spawnProc
        p.sendline(command)
        self.log.debug('session._sendAndTrim: sent %s' % command)
        self.log.debug('session._sendAndTrim: expect %s' % delim)
        try:
            p.expect(prompt)
        except pexpect.TIMEOUT:
            self.log.debug('session._sendAndTrim: no delim or prompt found')
            self.log.debug('    before expect: %s' % p.before)
            self.log.debug('     after expect: %s' % p.after)
            raise SessionException(
                'no delim or prompt after sending command %s' % command)
        
        # at this point, we have the output but also the command and
        # part of the prompt.  get rid of the prompt chunk.  do it in
        # 2 steps, crude but ok for now.
        # TODO: make this a single pass substitution.  The Python
        # Cookbook has such a single pass thing but it's a bit of a
        # monster.  I think it can be done with a more sophisticated
        # re.sub() but not important now.
        #43816
        if (not delim):
            promptChunk = self.promptChunk
        else:
            promptChunk = delim
        output = re.sub(promptChunk, '', p.before)
        output = re.sub(command+'\r\n', '', output)
        return output

    def checkDynamicEndpointExists(self,ipAddr,phoneNo):
        """Verifies if a dynamic endpoint exists with the given IP address is present in the MSW database"""
        # Find whether an endpoints with the given ip address exists
        filterOutput1 = self.assertCommand("cli iedge lkup %s | egrep -e 'IpAddr|State'" %ipAddr)
        if ((filterOutput1.find(ipAddr)!=-1) and (filterOutput1.find("Dynamic")!=-1)):
            return True
        else:
            return False


    
class SSH(Session):
    """Set up an SSH session.

    Note that brackets ("[", "]") are NOT ALLOWED in the prompt string
    on the target host.  Brackets will screw up the trim functions
    because they are list operators in Python.  Beware of any other
    characters in the prompt that might confuse this class.

    The prompt MUST end with '$' or '#', followed by a space.  This is a
    typical default for most shells, except maybe the C-shell varieties,
    which are not endorsed by The Creator."""
    def __init__(self, args, parent=None,ctxt=None):
        if not args: args = []
        if type(args) is StringType:
            args = [args]
        self.longComand = None
        # 22412 - MSW should have # as the prompt and not $ because some of the cli commands
        # use $ and hence will return incorrect results
        if args[0].__contains__('mymsw'):
            super(SSH, self).__init__("ssh", args, "# ", parent,context=ctxt)
        else:
            super(SSH, self).__init__("ssh", args, "[#$] ", parent,context=ctxt)
        
    def disconnect(self):
        """Send an exit to the remote shell and give it a chance to
        finish up before calling the parent disconnect, which closes
        the pexpect subprocess."""
        self.log.debug('SSH: disconnect')
        p = self.spawnProc
        p.sendline("exit")
        super(SSH, self).disconnect()

    def runLong(self, command):
        """Run a command that is expected to run for a long time,
        like 'tail -f'."""
        self.longCommand = command
        self.spawnProc.sendline(command)

    def stopLong(self, reject=False):
        """Stop a command started by runLongCmd.

        Returns any output generated by the command or a timeout
        string.  If reject is true, bail out after the command is
        stopped. 

        TODO  The '^C' string does not occur in terminal output on
        TODO  Linux, therefore the regex substitution will fail to find
        TODO  a match and you'll get the prompt in the output.  This can
        TODO  be fixed for Linux by doing a uname check and modifying
        TODO  the trailingJunk string accordingly.

        TODO  The output is not completely clean.  Tests have shown a
        TODO  leading space and a trailing newline.  Callers can
        TODO  strip() the output, so not a high priority.  Caveat
        TODO  emptor!
        """
        if self.longCommand:
            self.log.debug(['stopLong: stopping', self.longCommand])
            p = self.spawnProc
            self.log.debug('stopLong: sending ctrl-c')
            p.send(CTRL_C)
	# 29725
            match = p.expect([self.prompt,
                              pexpect.TIMEOUT], self.sshTimeout)
            if match == 0:
                self.log.debug('stopLong: got prompt')
                if reject: return
                self.log.debug('stopLong: parsing output')
                trailingJunk = '\^C' + '\r\n' + self.promptChunk
                self.log.debug('stopLong: trailing: %s' % trailingJunk)
                output = re.sub(self.longCommand+'\r\n', '', p.before)
                output = re.sub(trailingJunk, '', output)
                return output
            else:
                return "timed out"

    def _postConnect(self):
        """Do the SSH-specific expect stuff needed for a variety of
        SSH connection scenarios."""
        # 29725 timeout variable changed
        p = self.spawnProc
        try:
            match = p.expect(
                [self.prompt,
                 "ssh:",
                 "password: ",
                 "\? ",
                 "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@",
                 pexpect.EOF], self.sshTimeout 
                )

            if match == 0:    #prompt
                # got a prompt, want to save the prompt chunk so we can use
                # it later to trim command output.  do this by sending a
                # \r and cultivating the bare prompt.
                p.sendline("")
                p.expect(self.prompt)
                self._extractPChunk(p.before)
            elif match == 1:  # ssh error message
                # TODO: send the ssh error text in the exception
                raise SessionException, "ssh error"
            elif match == 2:  # passwd prompt
                raise SessionException, "ssh password required"
            elif match == 3:  # connect confirmation prompt
                p.sendline("yes")
                if p.expect(self.prompt):
                    raise SessionException, "ssh login confirmation problem"
                self._extractPChunk(p.before)
            elif match == 4:  # 
                raise SessionException, "ssh detected remote host identification change: check mymsw in ~/.ssh/known_hosts"
            elif match == 5:  # 
                raise SessionException, "ssh got unexpected prompt, did not establish connection"
        except pexpect.TIMEOUT:
            raise SessionException('ssh to %s timed out' % self.args)
        except Exception, exc:
            raise SessionException('SSH connect: %s' % str(exc))

class Python(Session):
    """
    A Python command interpreter session.
    """
    def __init__(self, args=[], parent=None):
        super(Python, self).__init__("python", args, ">>> ", parent)

    def disconnect(self):
        self.spawnProc.sendeof()

class LocalShell(Session):
    """Set up an local shell session.

    The prompt MUST end with '$' or '#', followed by a space.  This is a
    typical default for most shells, except maybe the C-shell varieties,
    which are not endorsed by The Creator."""
    def __init__(self):
        super(LocalShell, self).__init__('bash', [], '[#$] ', None, context=None)
        self.log.debug('localShell: connected')
        
    def disconnect(self):
        """Send an exit to the remote shell and give it a chance to
        finish up before calling the parent disconnect, which closes
        the pexpect subprocess."""
        self.log.debug('localShell: disconnect')
        self.spawnProc.sendline("exit")
        super(LocalShell, self).disconnect()


class CallGenError(SessionException):
    "An exception for the call gen session."

class CallGen(Session):
    """NexTone call gen session.

    The CallGen class is responsible for configuring, controlling, and
    providing statistical access to a protocol generator.

    TODO  The inheritance structure has become bad.  Main concern is
    TODO  that the superclass constructor is called by a method other
    TODO  than the subclass constructor - namely, it is called by go().
    TODO  This introduces problems.  E.g., attributes declared in the
    TODO  superclass constructor do not exist at certain times during
    TODO  the life of a subclass object!  This entire module should
    TODO  probably be reorganized and made more pure.
    """
    
    classInfo = { }
    def __init__(self, properties):
        """
        Create a gen object.  Do not start it yet but get config info.

        TODO  All configuration parameters stored in the commonConf and
        TODO  protoConf dictionaries in this class (and descendents)
        TODO  should be moved to external files.  As it sits now, this
        TODO  class is completely data driven; if you add a new key to
        TODO  one of the config dictionaries, that key is instantly
        TODO  available to your tests and to the H.323 config.val file.
        TODO  This is nice and flexible but, ideally, the key
        TODO  definitions should be moved to an external file so as not
        TODO  to require code modifications when new keys are added.
        """
        self.isConnected = False  # this should be in superclass see TODO
        self.commonConf = {
            'mode': 		None, # send or receive
            'regid':		None, # registration ID (not H.323 ID)
            'srcnum':   	'555',# starting phone number of caller
            'destnum':		'666',# starting phone number of callee
            'srcaddr': 		None, # source name or IP of outgoing calls
            'gateway':		None, # destination gateway name or IP
            'gwport':		None, # dest gateway port
            'numcalls':		  '1',# number of calls to make
            'symmetric':   None, # symmetric media ports
            'media':		None, # enable or disable
            'mediaport':	49200,# starting port number for mgen
            'response':		None, # cause code from when listening
            'origtrunkgroup':	None, # originating trunk group
            'desttrunkgroup':	None, # destination trunk group
             # 32141
            'maxcalls':         None, # number of max calls
        }
        self.configure(properties)
        self.pid = 0

    def assertConnected(self, timeout=0):
        """
        Determine if the endpoint is connected by waiting for the
        connect stat to go above zero.

        If timeout is reached, an AssertionError is raised.
        """
        # The algorithm is probably a rookie hack but it works.  The
        # trick is to declare tooLate as a global both to this method
        # AND the nested timedOut() function.  Otherwise, its not truly
        # global. This is a Python compiler subtlety; see 'Function
        # Gotchas' in the Learning Python book.
        global tooLate
        # 29725 - timeout check added
	# timeout variable being replaced by genTimeout
	genTimeout = int (globalVar.genTimeout)
	if (timeout != 0) :
            genTimeout = timeout
	    
        def timedOut():
           global tooLate
           tooLate = True
        t = threading.Timer(genTimeout, timedOut)
        t.start()
        tooLate = False
        while 1:
            time.sleep(2)
            stats = self.getStats()
            if self._getRecvCount(stats) > 0:
                t.cancel()
                return
            if tooLate:
                raise AssertionError('timed out waiting for connection')

    def configure(self, properties):
        """
        Set up the necessary things to prepare for running a gen.

        This may involve building command line arguments, writing a
        configuration file, etc.  It is up to the descendents of this
        class to do what is right.  This class only cares that the
        details are taken care of somehow.
        """
        # Make two passes.  First get all global keys, and remove them
        # as we go.  The rest of the keys go in proto config.
        self.log.debug('gen configuration change:')
        for key in properties.keys():
            if key in self.commonConf.keys():
                self.log.debug('    setting common %s to %s' % (key, properties[key]))
                self.commonConf[key] = properties[key]
                del properties[key]
        for key in properties.keys():
            if key not in self.protoConf.keys():
                raise CallGenError('invalid configuration "%s"' % key)
            self.log.debug('    setting proto %s to %s' % (key, properties[key]))
            self.protoConf[key] = properties[key]

    def disconnect(self):
        """
        Send an interrupt to the call gen.

        On Solaris, sending the hex code for Control-C does not seem to
        generate an interrupt in the spawned process (it does on Linux).
        A more portable solution is to send SIGINT, which is what this
        method does.

        TODO  do we need a delay after first interrupt to give SIP calls
        TODO  time for UDP packets to traverse and clean up?
        TODO  Delays suck.  They slow the whole process down.  Will the
        TODO  quit command on the gens remove the need for sleep()?
        """
        self.log.debug('CallGen:disconnect entered...')
	
        if not self.isConnected:
            self.log.debug('CallGen:disconnect: Already disconnected')
            return
	
        try:
            p = self.spawnProc
            self.log.debug('CallGen:disconnect: sending first sigint, expect %s' %
                 self.disconnectStr)
            p.kill(signal.SIGINT)
            time.sleep(2)
	    # 29725
            match = p.expect([self.disconnectStr, pexpect.EOF], self.sshTimeout)
            if match == 0:
                self.log.debug('got disconnect string')
            elif match == 1:
                self.log.debug('pexpect got %s' %pexpect.EOF)
                tries = 1
                while (p.isalive() and tries <= 10):
                    self.log.debug('CallGen:disconnect: Received EOF but process is still alive. Sending SIGINT #%' % tries)
                    p.kill(signal.SIGINT)
                    time.sleep(1)
                    tries = tries+1
                if p.isalive():
                    p.kill(signal.SIGKILL)
                    self.log.debug('CallGen:disconnect: All else has failed, send SIGKILL')

                self.log.debug('CallGen: disconnect: complete')
                self.cleanUp()
                return
            
            tries=1
            while (p.isalive() and tries <= 10):
                self.log.debug('CallGen:disconnect: sending final interrupt, expect EOF')
                p.kill(signal.SIGINT)
                time.sleep(1)
                tries=tries+1
            if p.isalive():
                p.kill(signal.SIGKILL)
                self.log.debug('CallGen:disconnect: All else has failed, send SIGKILL')

            self.log.debug('CallGen:disconnect: finally disconnected')
            # expecting an EOF here does not work.  why?
            self.cleanUp()
        except pexpect.TIMEOUT:
            self.log.debug('CallGen:disconnect:TIMED OUT: WARNING: process may still be alive')
            tries=1
            while (p.isalive() and tries <= 10):
                self.log.debug('CallGen:disconnect: Sending SIGINT #%s' % tries)
                p.kill(signal.SIGINT)
                time.sleep(1)
                tries=tries+1
            if p.isalive():
                p.kill(signal.SIGKILL)
                self.log.debug('CallGen:disconnect: All else has failed, send SIGKILL')
            self.log.debug('CallGen:disconnect: finally disconnected')
            self.cleanUp()
        self.log.debug('disconnect: complete: closing file descriptor')
        try:
            p.close()
            self.log.debug('CallGen:disconnect: complete: file descriptor closed')
        #14000
        except OSError,e:
            self.log.error('CallGen: disconnect: Exception: %s - OS error while closing the file descriptor' % str(e))
            pass
        
    def getValue(self, key):
        if key in self.commonConf.keys():
            return self.commonConf[key]
        elif key in self.protoConf.keys(): 
            return self.protoConf[key]
        else:
            return None
        
    def getStats(self):
        """Send a single carriage return to get the stats from the gen.
        Return a dictionary.  Use the dictionary to access the stat of
        your choice:

            stat = mygen.getStats()

        Key values are converted to integers.
        """
        self.log.debug('getStats: acquiring gen output')
        p = self.spawnProc
        p.send('\r')
	# 29725
        p.expect(['>(\r\n)'], int (globalVar.genTimeout))
        self.log.debug('getStats: acquisition complete')
        # convert the raw text into a list of lines, then split
        # each line using the colon as the delimiter.  make the
        # dictionary by assigning each value to the named key.
        # i think there's a built-in way to do this but where?
        # 39027 - On sgen, it is required to send more than one carriage
        # return to get the statistics
        # 41405 - On some test beds, the following output appears which needs
        # to be ignored
        if p.before == 'MICMPD: IcmpdInit(): terminating, errno = 9\r\n':
            p.expect(['>(\r\n)'], int (globalVar.genTimeout))
        if p.before == '':
            p.send('\r')
            p.expect(['>(\r\n)'], int (globalVar.genTimeout))
        if p.before == '':
            p.send('\r')
            p.expect(['>(\r\n)'], int (globalVar.genTimeout))
        text = p.before.split('\n')

        self.log.debug('    text to parse: %s' % p.before)
        stats = {}
        for line in text:
            line = line.strip().split(':')
            # Only process two-element lines.
            # sgen outputs a useless line about ICMP that includes
            # a colon; if we don't skip it, there will be an error
            if len(line) == 2 and not line[0].startswith('Icmp'):
                self.log.debug('getStats: parsing line: %s' % line)
                stats[line[0].strip()] = int(line[1].strip())
            else:
                self.log.debug('getStats: skipping junk: %s'% line)
        if not stats.keys():
            raise CallGenError("failed to get stats - use -T")
        self.log.debug('getStats: %s' % stats)
        return stats

    def go(self):
        """
        Start the call generator.

        Build the necessary configuration items needed: argument lists
        and config files and whatever else might be needed by the gen
        implementation.

        TODO  Define config rules as an aid to test development.
        TODO  Apply these rules to configurations prior to starting
        TODO  a generator so that configs likely to cause headaches
        TODO  will be caught prior to execution.
        TODO
        TODO  These rules are slowly creeping into _makeXConf() methods

        TODO  Running gens remotely (as a child of an SSH session)
        TODO  is now broken.  do we need it working?

        """
        self._makeCommonConf()
        self._makeProtoConf()
        self.log.debug('CallGen: go: %s' % self.cmd)
        super(CallGen, self).__init__(
            self.cmd, 		# executable path and args
            [],		# args to the exec (see warning in session)
            '>',		# prompt to expect
            None		# parent
            )
        self.isConnected = True
        self.pid = self.spawnProc.pid

    def getPID(self):
        return self.pid 

    ######################################################################
    # Private methods start here
    ######################################################################

    def _getRecvCount(self, stats):
        "This method must be overridden in descendents."
        raise NotImplementedError

    def _makeCommonConf(self):
        "Build common arguments used by both call gens."
        self.log.debug('CallGen: common config:')
        self.log.debug('    %s' % self.commonConf)
        c = self.commonConf
        cmd = self.path
        ############################################################
        # Mandatory parameters  (common rules are here)
        ############################################################
        if not c['gateway'] and c['mode'] == 'send':
            raise CallGenError('"gateway" must be specified in send mode')
        else:
            if c['gateway']: cmd += ' -g %s' % c['gateway']

        if c['mode'] == 'send' and c['response']:
            raise CallGenError('cannot specify reponse when sending')
        
        ############################################################
        # Optional parameters depending on mode
        ############################################################
        if c['mode'] == 'send': cmd += ' -t'
        if c['numcalls']:	cmd += ' -n %s' % c['numcalls']
        if c['srcnum']: 	cmd += ' -s %s' % c['srcnum']
        if c['destnum']:	cmd += ' -d %s' % c['destnum']
        cmd+= ' -L %s' %c['srcaddr']
        if c['symmetric']:   cmd += ' -R'
        if c['media'] == 'enable':
            cmd += ' -c'
            cmd += ' -m %s %s' %(c['srcaddr'], c['mediaport'])
        if c['response']:	cmd += ' -D %s' % c['response']
        if c['gwport']:		cmd += ' -p %s' % c['gwport']
        if c['origtrunkgroup']: cmd += ' -o %s' % c['origtrunkgroup']
        if c['desttrunkgroup']: cmd += ' -O %s' % c['desttrunkgroup']
        # 32141
        if c['maxcalls']:       cmd += ' -N %s' % c['maxcalls'] 
        self.cmd = cmd
        """Resetting optional parameter"""
        self.commonConf['symmetric']=None
        self.commonConf['media']=None
        self.commonConf['response']=None
        
        
    def _makeProtoConf(self):
        """
        Build necessary items unique to each call generator.

        This involves building command line arguments, creating a
        configuration file, etc.  It does NOT include setting up network
        interfaces or other system things.

        This method must be implemented in descendent classes.
        """
        raise NotImplementedError
    
    def _postConnect(self):
        """Special post-connection processing for the call gens.  They
        generate some output when they start but not a prompt."""
	# Ticket 29725
	timeout = int(globalVar.genTimeout)
        p = self.spawnProc
        match = p.expect(["AutoTestingMode"],timeout)
        if match == 0:
            p.expect('>(\r\n)',timeout)
        else:
            raise SessionException, "failed to connect to SIP call gen"

class H323Gen(CallGen):
    """
    Manage the H323 generator.

    TODO  when auto register on, verify registration confirm
    """
    tmp = None
    masterFile = 'h323-master.val'

    def __init__(self, properties, name=None):
        self.log = logging.getLogger('nextestlog')
        self.isConnected = False  # this should be in superclass see TODO
        self.path = 'gen -T'
        #self.cmd = self.path + ' -T'  # for parseable output
        self.disconnectStr = 'TotalCalls'
        self.inRegisterMode = 1
        if name:
            self.name = name
        else:
            self.name = "NoName"
        self.tmpConfig = None
        
        self.protoConf = {
            'file':		None, # name of gen config file
            'start':    	None, # fast, slow, fast-no-245
            'h323id':		None, # H.323 ID
            'fax':		None, # FAX call
            'gkaddr':	        None, # gatekeeper address
            'maxcalls': 	'20', # number of calls to run to?
            'disableh323id': '',
            'errorcode': None,
            'register': 'yes',
            'transferor':	None, # Call transfer transferor
            'q931port': None, # Q.931 signalling port 
            'rasport': None,  # RAS signalling port  
            # 32141
            'i': None,
            'burst' : None,
            #36553
            'timetolive': None, #Included to configure timetolive parmater in GEN 
            # 36319 - Added support for Singtel GEN
            'singtelIP' : None,
            'gkList'    : None,
            # 56479 - Added autoanswer
            'autoanswer': None,
            }
        if os.environ.has_key('NEXTEST_ETC'):
            self.masterFile = os.environ['NEXTEST_ETC']+'/'+self.masterFile
        else:
            self.masterFile = '/opt/nextest/etc/' + self.masterFile
        self.log.debug('H323Gen: config master is %s' % self.masterFile)

        super(H323Gen, self).__init__(properties)        

    def __del__(self):
        """Delete the temporary file created in _buildConfigFile() unless
        told not to by the user."""
        if not os.environ.has_key('NEXTEST_SAVE_TEMP') and self.tmpConfig:
            os.remove(self.tmpConfig)

    def _buildConfigFile(self):
        """Build RADVision configuration template file.

        This method builds a template from a template!  The RADVision
        configuration file is Neanderthal in design (and not really a
        template at all).  Therefore, this method's task is to make some
        simple keyword substitutions for auto-testing and let the
        RADVision software take it from there.

        We keep a local master copy of the template file with keywords
        delimited by '~'.  (This appears to be a safe delimiter since it
        is used no where else in the file.)  This method runs thru each
        line in the master and searches for the delimiter.   If found, it
        extracts the enclosed name and uses it as a key into the
        configuration dictionaries, writes the new value in place of the
        keyword (minus delimiters) and writes the output to a temporary
        file.

        The temporary template file - equivalent to RADVision's
        'config-template.val' - lives only for the duration of this
        object and is deleted in the destructor unless NEXTEST_SAVE_TEMP is on
        """
        self.log.debug('_buildConfigFile: starting RADVision config tweak')
        m = file(self.masterFile, 'r')
        master = m.readlines()
        m.close()

        # Create a temp file for RADVision config
	self.tmpConfig = "/tmp/h323-%s.%s" % (self.name,
                                              self.commonConf['mode'])        
        self.tmp = file(self.tmpConfig, 'w')

        regex = re.compile('~.*~')

        if self.protoConf['h323id'] == '':
            self.protoConf['disableh323id'] = '#'
        else:
            self.protoConf['disableh323id'] = ''
        # 36553 - If the timeToLive parameter is set to 0 in config file, then
        # GEN will not send the timeToLive parameter in RRQ.
        if self.protoConf['timetolive'] == '0':
            self.protoConf['timetolive'] = '#'

        def replaceKeyword(match):
            "A regex.sub() function that replaces keywords"
            key = match.group().strip('~')
            if key in self.commonConf.keys():
                self.log.debug('setting common key "%s" to "%s"' %
                     (key, self.commonConf[key]))
                return self.commonConf[key]

            if key in self.protoConf.keys():
                self.log.debug('setting protocol key "%s" to "%s"' %
                     (key, self.protoConf[key]))
                return self.protoConf[key]
            else:
                raise CallGenError(
                    'missing required key "%s" for H323 config' % key)

        for line in master:
            if line[0] != '#':
                if line.startswith('5     h323-ID') and self.protoConf['h323id'] == '':
                    self.log.debug('Resetting h323-ID in config template: %s' %line)
                    self.tmp.write('#5     h323-ID')
                #36553 - Added code to set the value of timeToLive passed as input parameter
                # in configure method.If the timeToLive value is 0 then commenting the line for
                # setting the timeToLive
                elif line.startswith('3   timeToLive') and self.protoConf['timetolive'] == '#':
                    self.log.debug('Resetting timeToLive in config template: %s' %line)
                    self.tmp.write('#3   timeToLive')
                elif line.startswith('3   timeToLive') and self.protoConf['timetolive'] != None:
                    self.tmp.write('3   timeToLive = %s' %self.protoConf['timetolive'])
                else:
                    self.tmp.write(regex.sub(replaceKeyword, line))

        # RADVision config file has been created; close it and save the name

        self.tmp.flush()  # prevent truncation!
        self.tmp.close()
        self.protoConf['file'] = self.tmpConfig
                
    def _getRecvCount(self, stats):
        "Get received call count from the TotalCallsRx number."
        return stats['TotalCallsRx']
        
    def _makeProtoConf(self):
        """
        Make the H.323 gen configuration file and arguments.

        Build command line arguments and the config file for the
        RADVision stack.  The config file is based on a master template
        that contains embedded keywords.  The keywords will be removed
        and replaced with values specified by the user or with defaults.
        """
        self.log.debug('H323Gen: config:')
        self.log.debug('    %s' % self.protoConf)

        ############################################################
        # Mandatory parameters (protocol-specific rules are here)
        ############################################################
        # there must be a configuration file. if not user-specified,
        # we will build from a template using configure() arguments
        # and defaults.
        # If the user didn't specify a gatekeeper, then use the gateway
        # address.  The gatekeeper is required in the config file??
        if not self.protoConf['gkaddr']:
            self.protoConf['gkaddr'] = self.commonConf['gateway']
        #if not self.protoConf['h323id']:
            #raise CallGenError('must specify an H.323 ID')
        
        ############################################################
        # Optional Parameters
        ############################################################
        cmd = self.cmd
        c = self.protoConf
        if c['start'] == 'slow':	cmd += ' -f'
        if c['start'] == 'fast-no-h245': cmd += ' -f+'
        if c['fax']: 			cmd += ' -x'
        if c['errorcode']:
            cmd += ' -y %s' % c['errorcode']

        ############################################################
        # Build the RADVision config file AFTER checking rules
        ############################################################
        if not self.protoConf['file']:
            self._buildConfigFile()
        cmd += ' -A %s' % self.protoConf['file']

        if self.protoConf['register'] == 'yes':
            cmd += ' -G'
            self.inRegisterMode = 1
        elif self.protoConf['register'] == 'no':
            self.inRegisterMode = 0

        # For call transferor - don't start 2nd call until told to
        if  self.protoConf['transferor']:
            cmd += ' -xf'

        # 30008 - Added Q.931 and RAS signalling ports parameters

        if self.protoConf['q931port']:
            cmd += ' -lq %s' %self.protoConf['q931port']
        if self.protoConf['rasport']:
            cmd += ' -lr %s' %self.protoConf['rasport']
        # 32141
        if self.protoConf['i']:
            cmd += ' -i %s' %self.protoConf['i']
        if self.protoConf['burst']:
            cmd += ' -b %s' %self.protoConf['burst']

        # 36319 - Modify gen to send given IP in ACF 
        if self.protoConf['singtelIP']:
            if self.protoConf['gkList']:
                cmd = 'gen -A %s -L %s -g %s -GK %s -Z %s' %(self.protoConf['file'],self.commonConf['srcaddr'],self.commonConf['gateway'],self.protoConf['gkList'],self.protoConf['singtelIP'])
            else:
                cmd = 'gen -A %s -L %s -g %s -GK -Z %s' %(self.protoConf['file'],self.commonConf['srcaddr'],self.commonConf['gateway'],self.protoConf['singtelIP'])

        # 56749 - Added autoanswer
        if self.protoConf['autoanswer']=='no':
            cmd += ' -y 9'

        self.cmd = cmd
        
        # Resetting protoConf back to old values
        self.protoConf['fax'] = None
        self.protoConf['start'] = None
        self.protoConf['errorcode'] = None
        self.protoConf['register'] = 'yes'
        self.protoConf['transferor'] = None

    def _postConnect(self):
        """Verify that the H323 gen is running properly.

        This involves checking for prompts and, depending on mode, various
        strings that indicate things are working.
        """
        msg = 'H323Gen._postConnect: %s'
        p = self.spawnProc
	# Ticket 29725
	timeout = int(globalVar.genTimeout)
        try:
            p.expect(['>'], timeout)
            self.log.info(msg % "gen starting")
        except pexpect.TIMEOUT:
            raise CallGenError(msg % "no start prompt")

        # 36319 - When run in GK mode, Registration Confirmed message will not be recd
        if (self.inRegisterMode == 1) and (self.protoConf['singtelIP'] == None):
            try:
                p.expect('Registration confirmed',timeout)
                self.log.info(msg % "registration confirmed")
            except pexpect.TIMEOUT:
                raise CallGenError(msg % "no registration confirmation")
            try:
                p.expect(['>(\r\n)'], timeout)
                self.log.info(msg % "second prompt received")
            except pexpect.TIMEOUT:
                raise CallGenError(msg % "no second prompt received")

        if self.commonConf['mode'] == 'send':
            try:
                p.expect('Starting calls', timeout)
                self.log.info(msg % "calls started")
            except pexpect.TIMEOUT:
                raise CallGenError(msg % "no calls started")
            try:
                p.expect(['>(\r\n)'], timeout)
                self.log.info(msg % "second prompt received")
            except pexpect.TIMEOUT:
                raise CallGenError(msg % "no second prompt received")

        self.log.info(msg % 'ready')
        
class SIPGen(CallGen):
    """
    Manage the SIP generator.
    """
    disconnectStr = 'Disconnected'
    
    def __init__(self, properties, name=None):
        """
        Constructor here allows definition of protoConf map.

        If that map is placed in the class header, it will become a
        class dictionary and therefore is shared by all objects, which
        is not good.
        """
        self.log = logging.getLogger('nextestlog')
        self.isConnected = False  # this should be in superclass see TODO
        if name: self.name = name
        self.path = 'sgen -T'
        #self.cmd = self.path
        self.protoConf = {
            'desturi':	None, # destination URI
            'srcuri':	None, # source URI
            'register': None, # register before call
            'unregisterwhenexit': None, # send unregistration request
            'duration': '3600', # register for this duration and send keep alive
            'fax': 	None, # fax mode
            'obp': 	None, # outbound proxy mode
            'ep': 	None, # run gen as terminal endpoint
            'manualaccept': None, #accept call manually, do not send 200 OK
            'nosdp': 	None, #Initiate Invite with no SDP
            'mgc':	None, # set SIP-T mode (ISUP or QSIG)
            'transferatt':	None, # Attended transfer expected - transferor only
            'transferee':	None, # Call transfer transferee
            #36909 - Added for provisioning local SIP signaling port
            'srcsigport':       None, # local SIP signaling port
            #40043
            'gatewayport':   None # port number of the gateway where messages will be sent
            }
        self.inRegisterMode = 0
        super(SIPGen, self).__init__(properties)
        
    def _makeProtoConf(self):
        """Make command line arguments for SIP call generator.

        All configuration rules are verified here.
        """
        self.log.debug('SIPGen: proto config:')
        self.log.debug('    %s' % self.protoConf)
        # listening address is implemented differently for each gen
        ############################################################
        # Mandatory Parameters  (protocol-specific rules are here)
        ############################################################
        
        ############################################################
        # Optional Parameters
        ############################################################
        if self.protoConf['register'] and self.protoConf['unregisterwhenexit']:
            self.cmd += ' -Gu %s' %self.protoConf['duration']
            self.inRegisterMode = 1
        elif self.protoConf['register']:
            self.cmd += ' -G %s' %self.protoConf['duration']
            self.inRegisterMode = 1

        if self.protoConf['fax']:   self.cmd += ' -x'
        if self.protoConf['obp']:   self.cmd += ' -obp %s' % \
                                                self.protoConf['obp']
        if self.protoConf['ep']:   self.cmd += ' -ep ' #took off -R option (was used only for NAT)
        if self.protoConf['desturi']:
            self.cmd += ' -u %s' %self.protoConf['desturi']
        if self.protoConf['manualaccept']:   self.cmd += ' -k'
        if self.protoConf['nosdp']:   self.cmd += ' -j'
        if self.protoConf['mgc']=='isup':
            self.cmd += ' -sti'
        elif self.protoConf['mgc']=='qsig':
            self.cmd += ' -stq'
        if self.protoConf['transferatt']:
            self.cmd += ' -xf'
        if self.protoConf['transferee']:
            self.cmd += ' -cm'
        #36909 - Added for provisioning local SIP signaling port
        if self.protoConf['srcsigport']:
            self.cmd += ' -l %s' %self.protoConf['srcsigport']
        #40043
        if self.protoConf['gatewayport']:
            self.cmd += ' -p %s' %self.protoConf['gatewayport'] 


        # Resetting protoConf back to old values
        self.protoConf['fax'] = None
        self.protoConf['ep'] = None
        self.protoConf['register'] = None
        self.protoConf['desturi'] = None
        self.protoConf['srcuri'] = None
        self.protoConf['obp'] = None
        self.protoConf['manualaccept'] = None
        self.protoConf['ep'] = None
        self.protoConf['nosdp'] = None
        self.protoConf['duration'] = '3600'
        self.protoConf['mgc'] = None
        self.protoConf['unregisterwhenexit'] = None
        self.protoConf['transferatt'] = None
        self.protoConf['transferee'] = None
        #36909 - Added for provisioning local SIP signaling port
        self.protoConf['srcsigport'] = None
 

    def _getRecvCount(self, stats):
        "Get connected calls from the ConnectedCalls number."
        return stats['ConnectedCalls']

    def disconnect(self):
        """
        Send Bye and exit. Check for the number of calls disconnected after sending Bye. Also 
        if you know about the receiving endpoint, confirm if it has received BYE
        """

        self.log.debug('SIPGen:disconnect entered...')
	
        if not self.isConnected:
            self.log.debug('SIPGen:disconnect: Already disconnected')
            return

        try:
            p = self.spawnProc
            if self.commonConf['mode']=='receive' and self.inRegisterMode==1:
                self.inRegisterMode=0
                self.disconnectStr = "bashPrompt"
                self.log.debug('SIPGen:disconnect: stopping sgen in registration mode')
                p.sendline('quit')
            else:
                self.disconnectStr = "Disconnected"
                p.sendline('quit')
                self.log.debug('SIPGen:disconnect: expect: %s' %self.disconnectStr)
                p.expect(self.disconnectStr,60)
                self.log.debug('SIPGen:disconnect: Bye transaction was complete')
            
            tries=1
            while (p.isalive() and tries <= 10):
                self.log.debug('SIPGen:disconnect: sending final SIGINT #%s, expect EOF' % tries)
                p.kill(signal.SIGINT)
                time.sleep(1)
                tries = tries+1
            if p.isalive():
                p.kill(signal.SIGKILL)
                self.log.debug('CallGen:disconnect: All else has failed, send SIGKILL')

            self.log.debug('SIPGen:disconnect: disconnect complete')
            self.cleanUp()
        except pexpect.EOF:
            self.cleanUp()
            self.log.debug('SIPGen:disconnect: EOF: Already disconnected')
            raise AssertionError(self.disconnectStr)
        except pexpect.TIMEOUT:
            self.cleanUp()
            self.log.debug('SIPGen:disconnect:TIMED OUT: WARNING: process may still be alive')
            tries = 1
            while (p.isalive() and tries <= 10):
                self.log.debug('SIPGen:disconnect: Sending SIGINT #%s' % tries)
                p.kill(signal.SIGINT)
                time.sleep(1)
                tries = tries+1
            if p.isalive():
                p.kill(signal.SIGKILL)
                self.log.debug('CallGen:disconnect: All else has failed, send SIGKILL')
            self.log.debug('SIPGen:disconnect: finally disconnected')
            raise AssertionError(self.disconnectStr)
        self.log.debug('SIPGen:disconnect: complete: closing file descriptor')
        try:
            p.close()
            self.log.debug('SIPGen:disconnect: complete: file descriptor closed')
        except OSError,e:
            self.log.error('Exception : %s - SIPGen:disconnect: OS error while closing the file descriptor' % str(e))
            pass



#Class added for PR 184675
class Sipp(CallGen):
    """
    Manage the Sipp call generator.
    """
    def __init__(self, properties, name=None):
        """
        Constructor here allows definition of configuration map.

        If that map is placed in the class header, it will become a
        class dictionary and therefore is shared by all objects, which
        is not good because every object will have its own configuration
        and hence this should be implemented as a member variable.
        """
        self.log = logging.getLogger('nextestlog')
        #18523 
        self.codec0 = ''
        self.codec1 = ''
        self.isConnected = False
        if name: self.name = name
        self.path = 'sudo /opt/nextest/bin/sipp'
        self.conf = {
             'calls':        None, # number of calls
             'gateway':      None, # gateway ip address
             'srcaddr':      None, # local ip address 
             'duration':     None, # duration of each call  
             'rate':         None, # calls per second
             'mgenmgmtip':   None, # mgen management ip address
             'mediaip':      None, # media ip address
             'xmlfile':      None, # xml file containing the SIP message flow
             'csvfile':      None, # csv file used to feed data to scenario file
             'genindexN':    None, # index of the signalling generator
             'totalgenT':    None, # total number of signalling generators
             'traceRespTime': None,# To enable logging of response time
             'gatewayport':   None,# port number of the gateway where messages will be sent
             'log':          None, # To enable message logging from Scenario files Ticket 31354
             'transport':    None, # 43494: transport protocol - possible values: t1,tn,u1,un
             'srcport':      None, # 43494: local port
             'gatewaytls':   None, # - Added code for tls remote ip addition
             'tlsport':      None, # - Added code for tls remote port addition
             'tlscert':      None, # - Added code for tls certificate for feature TLS
             'tlskey':      None,  # - Added code for tls private key for feature TLS
             'destnum':     None  # - Added code for any feature which invloves inclusion of -s option in Nxgen
            }
        self.configure( properties)

    def configure(self, properties):
        """
        Set up the necessary things for running Sipp
        """
        for key in properties.keys():
            try:
                self.conf[key] = properties[key]
                self.log.debug('Sipp: Setting configuration %s to %s' % (key, properties[key]))
            except Exception,e:
                msg = 'Exception : %s ' % str(e)
                self.log.error(msg)
                continue

    def go(self):
        """
        Start the Sipp call generator
        """
        # Verify whether Sipp is installed 
        if (pexpect.which('sipp') == None):
            raise CallGenError('Sipp is not installed!')    

        # Build the Command using the input parameters
        self.__makeConf()

        # Delete the Sipp csv log file if already present 
        os.system('rm -rf ' + self.logfilename)

        self.log.debug('Sipp: Command: %s' % self.cmd)
        super(CallGen, self).__init__(
            self.cmd,           # Command to be executed
            [],                 # args to the exec
            '',                 # prompt to expect
            None                # parent
            )

        self.isConnected = True
        self.pid = self.spawnProc.pid 

    def __makeConf(self):

        # Set the command to Sipp and append the arguments
        self.cmd = self.path

        ############################################################
        # Mandatory parameters
        ############################################################
        # Verify whether the Mandatory Parameters have been provided
        if self.conf['gateway']:    self.cmd += ' %s' % self.conf['gateway']
        # - Added code to provide TLS port no. at the time of providing the remote ip for TLS feature 
        elif self.conf['gatewaytls'] and self.conf['tlsport']:    self.cmd += ' %s:%s' % (self.conf['gatewaytls'],self.conf['tlsport']) 
        else: raise CallGenError('"gateway" must be specified')

        if self.conf['srcaddr']:    self.cmd += ' -i %s' % self.conf['srcaddr']
        else: raise CallGenError('"srcaddr" must be specified')

        if self.conf['xmlfile']:
            self.cmd += ' -sf %s' % self.conf['xmlfile']
            # Verify whether the specified Scenario file exists
            if not os.path.isfile(self.conf['xmlfile']):
                raise CallGenError('Unable to find scenario File %s!' % self.conf['xmlfile'])
        else:
            raise CallGenError('"xmlfile" must be specified')

        if self.conf['mgenmgmtip']:
            self.cmd += ' -mmi %s' % self.conf['mgenmgmtip']

        if self.conf['mediaip']:
            self.cmd += ' -mi %s -mgen' % self.conf['mediaip']

        # Build the other Command Line arguments, if specified
        if self.conf['csvfile']:
            self.cmd += ' -inf %s' % self.conf['csvfile']
            # Verify whether the specified data file exists
            if not os.path.isfile(self.conf['csvfile']):
                raise CallGenError('Unable to find data File %s!' % self.conf['csvfile'])

        if self.conf['calls']:    self.cmd += ' -m %s' % self.conf['calls']   

        if self.conf['rate']:    self.cmd += ' -r %s' % self.conf['rate'] 

        if self.conf['duration']:    self.cmd += ' -d %s' % self.conf['duration']

        if self.conf['genindexN']:    self.cmd += ' -N %s' % self.conf['genindexN']

        if self.conf['totalgenT']:    self.cmd += ' -T %s' % self.conf['totalgenT']

        if (self.conf['traceRespTime'] == 'enable'):    self.cmd += ' -trace_rtt'

        #ticket 31354 : enable sipp log
        if (self.conf['log'] == 'enable'):    self.cmd += ' -trace_logs'

        if self.conf['gatewayport']:  self.cmd += ' -rsa %s:%s' %(self.conf['gateway'],self.conf['gatewayport'])

        # 43494: Local Port and Transport protocol
        if self.conf['srcport']:      self.cmd += ' -p %s' % self.conf['srcport']

        if self.conf['transport']:    self.cmd += ' -t %s' % self.conf['transport']
        
        # - Added code for any feature which invloves inclusion of -s option in Sipp 
        if self.conf['destnum']:    self.cmd += ' -s %s' % self.conf['destnum']

        # - Added code to include field for tls certificate for feature TLS
        if self.conf['tlscert']:    self.cmd += ' -tls_cert %s' % self.conf['tlscert']

        # - Added code to include field for tls private key for feature TLS
        if self.conf['tlskey']:    self.cmd += ' -tls_key %s' % self.conf['tlskey']

        # Append -bgi option so that Sipp will be run in background mode
        self.cmd += ' -bg'

        # Append -trace_stat and -stf option to output the Call Statistics to a file
        # Form the log file name by combining the Scenario File name with the name of the endpoint
        self.logfilename = self.conf['xmlfile'] + "_" + self.name + ".csv"
        self.cmd += " -trace_stat -stf %s" %self.logfilename
        self.sleepDuration = self.conf['duration']

    def _postConnect(self):
        """ 
        Make sure that Sipp has started by checking for the prompt
        """
        self.log.debug('Sipp: _postConnect')
        p = self.spawnProc
        msg = "_postConnect: Failed to get message 'Background mode' after starting Sipp"
	# Ticket 29725
	timeout = int(globalVar.genTimeout)
        try:
            # Verify whether the process started successfully by checking for the message 'Background mode'
	    # Ticket 29725
            match = p.expect(['Background mode', pexpect.EOF], timeout)
        except pexpect.TIMEOUT:
            self.log.error(msg)
            raise pexpect.TIMEOUT

        if match !=0:
            self.log.error(msg)
            raise CallGenError(msg)

    def disconnect(self):
        try:
            self.disconnectStr='please be patient, it may take a while for active calls to hang up ...'
            self.log.info("disconnect Sipp called")
            if self.isConnected:
		os.system("sudo pkill -9 sipp")
                self.log.debug('Sipp:disconnect: Transaction complete')
            
        except pexpect.EOF:
            self.cleanUp()
            self.log.debug('SIPGen:disconnect: EOF: Already disconnected')
        except pexpect.TIMEOUT:
            self.cleanUp()
            self.log.debug('SIPGen:disconnect:TIMED OUT: WARNING: process may still be alive')
        self.cleanUp()

    def isScenarioSuccessful(self,noofcalls):
        """ 
        Check from Sipp counters whether all the Calls were successful.
        Read the csv log file of Sipp and compare the value of the Successful
        Call Cumulative counter with the proposed number of calls.   
        """
        self.log.debug("Sipp: isScenarioSuccessful called")
        try:
            # Check whether the number of calls to be made/received by Sipp is configured 
            if ((noofcalls == -1) and (not(self.conf['calls']))):
                self.log.error("Number of calls to be generated by Sipp is not specified!")
                self.log.error("Configure property 'calls' for Sipp")
                return False
            elif noofcalls == -1:
                noofcalls = int(self.conf['calls'])
 
            f = open(self.logfilename, 'r')
            linelist = f.readlines()
            f.close()
 
            # The first line in the file would have names of the counter seperated by ;
            counternameslist = linelist[0].split(';')
        
            # The last line in the file would have the values of the counters at the 
            # end of the run seperated by a ;
            valuelist = linelist[len(linelist)-1].split(';')

            # Create a dictionary containing the counter name and its value
            countername_value = {}
            for i in range(0,len(counternameslist)):
                countername_value[counternameslist[i]] = valuelist[i]

            self.log.debug("Value of SuccessfulCall(C) counter from log file is %s" %countername_value["SuccessfulCall(C)"])

            return (int(countername_value["SuccessfulCall(C)"])==noofcalls)  
        except:
            self.log.error('ERROR reading csv statistics log file of Sipp!')
            return False  

    #Ticket - 33235 Method introduced to get Response Time between messages exchanges
    #Sipp scenario calculate time between two send or recv commands that have the start_rtd or rtd attributes.
    def getRTD(self):
        """
        Get from Sipp counters the value of RTD.
        Read the csv log file of Sipp. Read the RTD value
        """
        self.log.debug("Sipp: getRTD called")
        try:
            f = open(self.logfilename, 'r')
            linelist = f.readlines()
            f.close()

            # The first line in the file would have names of the counter seperated by ;
            counternameslist = linelist[0].split(';')

            # The last line in the file would have the values of the counters at the
            # end of the run seperated by a ;
            valuelist = linelist[len(linelist)-1].split(';')

            # Create a dictionary containing the counter name and its value
            countername_value = {}
            for i in range(0,len(counternameslist)):
                countername_value[counternameslist[i]] = valuelist[i]

            self.log.debug("Value of ResponseTime(C) counter from log file is %s" %countername_value["ResponseTime(C)"])
            #convert the time in seconds
            timelist= countername_value["ResponseTime(C)"].split(':')
            return (int(timelist[0])*3600 + int(timelist[1])*60 + int(timelist[2]))
        except:
            self.log.error('ERROR reading csv statistics log file of Sipp!')
            return -1
 

    def getResponseTimes(self):
        """ 
        Return the minimum, maximum and average response times 
        """
        pid = self.getPID()
        repStr = "_" + str(pid) + "_rtt.csv" 
        respTimeFileName = self.conf['xmlfile'].replace('.xml',repStr)

        self.log.info("Response Time Log File Name is %s" %respTimeFileName)

        linelist = []
        try:
            f = open(respTimeFileName, 'r')
            linelist = f.readlines()
            f.close()
        
            respTimeList = []
            tempList = []
            for tempstr in linelist[1:]:
                tempList = tempstr.split(';')
                respTimeList.append(round(string.atof(tempList[1])))
        
            totRespTime = 0.0
            avgRespTime = 0.0
            for respTime in respTimeList:
                totRespTime += respTime

            # Sort the response time list
            respTimeList.sort()
            avgRespTime = totRespTime/len(respTimeList)
        
            # Remove the csv log file
            os.system('rm %s' % respTimeFileName)
            self.log.info("Min,Max and Avg Response Times are %f %f %f" %(respTimeList[0],respTimeList[(len(respTimeList)-1)],avgRespTime))
            return respTimeList[0],respTimeList[(len(respTimeList)-1)],avgRespTime

        except Exception,e:
            self.log.error("CAUGHT EXCEPTION - %s - while parsing the Response Time log %s" %(str(e),respTimeFileName))
            return -1,-1,-1



class NxGen(CallGen):
    """
    Manage the NxGen call generator.
    """
    def __init__(self, properties, name=None):
        """
        Constructor here allows definition of configuration map.

        If that map is placed in the class header, it will become a
        class dictionary and therefore is shared by all objects, which
        is not good because every object will have its own configuration
        and hence this should be implemented as a member variable.
        """
        self.log = logging.getLogger('nextestlog')
        #18523 
        self.codec0 = ''
        self.codec1 = ''
        self.isConnected = False
        if name: self.name = name
        self.path = 'nxgen'
        self.conf = {
             'calls':        None, # number of calls
             'gateway':      None, # gateway ip address
             'srcaddr':      None, # local ip address 
             'duration':     None, # duration of each call  
             'rate':         None, # calls per second
             'mgenmgmtip':   None, # mgen management ip address
             'mediaip':      None, # media ip address
             'xmlfile':      None, # xml file containing the SIP message flow
             'csvfile':      None, # csv file used to feed data to scenario file
             'genindexN':    None, # index of the signalling generator
             'totalgenT':    None, # total number of signalling generators
             'traceRespTime': None,# To enable logging of response time
             'gatewayport':   None,# port number of the gateway where messages will be sent
             'log':          None, # To enable message logging from Scenario files Ticket 31354
             'transport':    None, # 43494: transport protocol - possible values: t1,tn,u1,un
             'srcport':      None, # 43494: local port
             'gatewaytls':   None, # - Added code for tls remote ip addition
             'tlsport':      None, # - Added code for tls remote port addition
             'tlscert':      None, # - Added code for tls certificate for feature TLS
             'tlskey':      None,  # - Added code for tls private key for feature TLS
             'destnum':     None,  # - Added code for any feature which invloves inclusion of -s option in Nxgen
             'tracemsg':    None,   # - To enable logging of received SIP messages
             'srcnum':      None,  # - Added code for any feature which invloves inclusion of -sl option in Nxgen
             'confile':     None,  # - Added config file for Nxgen
             'rtp_interval':     None  # - set rtp packet interval

            }
        self.configure( properties)

    def configure(self, properties):
        """
        Set up the necessary things for running Nxgen
        """
        for key in properties.keys():
            try:
                self.conf[key] = properties[key]
                self.log.debug('NxGen: Setting configuration %s to %s' % (key, properties[key]))
            except Exception,e:
                msg = 'Exception : %s ' % str(e)
                self.log.error(msg)
                continue

    def go(self):
        """
        Start the Nxgen call generator
        """
        # Verify whether Nxgen is installed 
        if (pexpect.which('nxgen') == None):
            raise CallGenError('Nxgen is not installed!')    

        # Build the Command using the input parameters
        self.__makeConf()

        # Delete the Nxgen csv log file if already present 
        os.system('rm -rf ' + self.logfilename)

        self.log.debug('Nxgen: Command: %s' % self.cmd)
        super(CallGen, self).__init__(
            self.cmd,           # Command to be executed
            [],                 # args to the exec
            '',                 # prompt to expect
            None                # parent
            )

        self.isConnected = True
        self.pid = self.spawnProc.pid 

    def __makeConf(self):

        # Set the command to Nxgen and append the arguments
        self.cmd = self.path

        ############################################################
        # Mandatory parameters
        ############################################################
        # Verify whether the Mandatory Parameters have been provided
        if self.conf['gateway']:    self.cmd += ' %s' % self.conf['gateway']
        # - Added code to provide TLS port no. at the time of providing the remote ip for TLS feature 
        elif self.conf['gatewaytls'] and self.conf['tlsport']:    self.cmd += ' %s:%s' % (self.conf['gatewaytls'],self.conf['tlsport']) 
        else: raise CallGenError('"gateway" must be specified')

        if self.conf['srcaddr']:    self.cmd += ' -i %s' % self.conf['srcaddr']
        else: raise CallGenError('"srcaddr" must be specified')

        if self.conf['xmlfile']:
            self.cmd += ' -sf %s' % self.conf['xmlfile']
            # Verify whether the specified Scenario file exists
            if not os.path.isfile(self.conf['xmlfile']):
                raise CallGenError('Unable to find scenario File %s!' % self.conf['xmlfile'])
        else:
            raise CallGenError('"xmlfile" must be specified')

        if self.conf['mgenmgmtip']:
            self.cmd += ' -mmi %s' % self.conf['mgenmgmtip']

        if self.conf['mediaip']:
            self.cmd += ' -mi %s -mgen' % self.conf['mediaip']

        # Build the other Command Line arguments, if specified
        if self.conf['csvfile']:
            self.cmd += ' -inf %s' % self.conf['csvfile']
            # Verify whether the specified data file exists
            if not os.path.isfile(self.conf['csvfile']):
                raise CallGenError('Unable to find data File %s!' % self.conf['csvfile'])

        if self.conf['calls']:    self.cmd += ' -m %s' % self.conf['calls']   

        if self.conf['rate']:    self.cmd += ' -r %s' % self.conf['rate'] 

        if self.conf['duration']:    self.cmd += ' -d %s' % self.conf['duration']

        if self.conf['genindexN']:    self.cmd += ' -N %s' % self.conf['genindexN']

        if self.conf['totalgenT']:    self.cmd += ' -T %s' % self.conf['totalgenT']

        if (self.conf['traceRespTime'] == 'enable'):    self.cmd += ' -trace_rtt'

        #ticket 177406: enable trace message
        if (self.conf['tracemsg'] == 'enable'):    self.cmd += ' -trace_msg'

        #ticket 31354 : enable nxgen log
        if (self.conf['log'] == 'enable'):    self.cmd += ' -trace_logs'

        if self.conf['gatewayport']:  self.cmd += ' -rsa %s:%s' %(self.conf['gateway'],self.conf['gatewayport'])

        # 43494: Local Port and Transport protocol
        if self.conf['srcport']:      self.cmd += ' -p %s' % self.conf['srcport']

        if self.conf['transport']:    self.cmd += ' -t %s' % self.conf['transport']
        
        # - Added code for any feature which invloves inclusion of -s option in Nxgen
        if self.conf['destnum']:    self.cmd += ' -s %s' % self.conf['destnum']

        # - Added code for any feature which invloves inclusion of -sl option in Nxgen
        if self.conf['srcnum']:    self.cmd += ' -sl %s' % self.conf['srcnum']

        # - Added code to include field for tls certificate for feature TLS
        if self.conf['tlscert']:    self.cmd += ' -tls_cert %s' % self.conf['tlscert']

        # - Added code to include field for tls private key for feature TLS
        if self.conf['tlskey']:    self.cmd += ' -tls_key %s' % self.conf['tlskey']

        if self.conf['confile']:
            self.cmd = self.path
            self.cmd += ' -cf %s' % self.conf['confile']
            if self.conf['csvfile']:      self.cmd += ' -inf %s' % self.conf['csvfile']
            if self.conf['genindexN']:    self.cmd += ' -N %s' % self.conf['genindexN']
            if self.conf['totalgenT']:    self.cmd += ' -T %s' % self.conf['totalgenT']
            if self.conf['rtp_interval']:    self.cmd += ' -P %s' % self.conf['rtp_interval']

        # Append -bgi option so that Nxgen will be run in background mode
        self.cmd += ' -bgi'




        # Append -trace_stat and -stf option to output the Call Statistics to a file
        # Form the log file name by combining the Scenario File name with the name of the endpoint
        self.logfilename = self.conf['xmlfile'] + "_" + self.name + ".csv"
        self.cmd += " -trace_stat -stf %s" %self.logfilename
        self.sleepDuration = self.conf['duration']

    def _postConnect(self):
        """ 
        Make sure that Nxgen has started by checking for the prompt
        """
        self.log.debug('Nxgen: _postConnect')
        p = self.spawnProc
        msg = "_postConnect: Failed to get message 'interactive mode' after starting Nxgen"
	# Ticket 29725
	timeout = int(globalVar.genTimeout)
        try:
            # Verify whether the process started successfully by checking for the message 'interactive mode'
	    # Ticket 29725
            match = p.expect(['interactive mode', pexpect.EOF], timeout)
        except pexpect.TIMEOUT:
            self.log.error(msg)
            raise pexpect.TIMEOUT

        if match !=0:
            self.log.error(msg)
            raise CallGenError(msg)

    def disconnect(self):
        try:
            self.disconnectStr='please be patient, it may take a while for active calls to hang up ...'
            self.log.info("disconnect Nxgen called")
            if self.isConnected:
                p = self.spawnProc
                p.sendline('q')
                #print "Sending q"
                if not self.sleepDuration :
                    sleepTime = 10
                else:
	            sleepTime = ((int(self.sleepDuration))/1000)+5
                time.sleep(sleepTime)
                p.expect(self.disconnectStr,10)
                self.log.debug('Nxgen:disconnect: Transaction complete')
            
        except pexpect.EOF:
            self.cleanUp()
            self.log.debug('SIPGen:disconnect: EOF: Already disconnected')
        #except pexpect.TIMEOUT,pexpect.EOF:
        except pexpect.TIMEOUT:
            self.cleanUp()
            self.log.debug('SIPGen:disconnect:TIMED OUT: WARNING: process may still be alive')
            tries=1
            while (p.isalive() and tries <= 10):
                self.log.debug('SIPGen:disconnect: sending final SIGINT #%s, expect EOF' % tries)
                #p.kill(signal.SIGINT)
                p.send(CTRL_C)
                time.sleep(1)
                tries = tries+1
            if p.isalive():
                p.kill(signal.SIGKILL)
                self.log.debug('NxgeGen:disconnect: All else has failed, send SIGKILL')
                #p.send(CTRL_C)
                #self.log.info("disconnect TIMEOUT Exception")
        self.cleanUp()

    def isScenarioSuccessful(self,noofcalls):
        """ 
        Check from Nxgen counters whether all the Calls were successful.
        Read the csv log file of Nxgen and compare the value of the Successful
        Call Cumulative counter with the proposed number of calls.   
        """
        self.log.debug("Nxgen: isScenarioSuccessful called")
        try:
            # Check whether the number of calls to be made/received by Nxgen is configured 
            if ((noofcalls == -1) and (not(self.conf['calls']))):
                self.log.error("Number of calls to be generated by Nxgen is not specified!")
                self.log.error("Configure property 'calls' for Nxgen")
                return False
            elif noofcalls == -1:
                noofcalls = int(self.conf['calls'])
 
            f = open(self.logfilename, 'r')
            linelist = f.readlines()
            f.close()
 
            # The first line in the file would have names of the counter seperated by ;
            counternameslist = linelist[0].split(';')
        
            # The last line in the file would have the values of the counters at the 
            # end of the run seperated by a ;
            valuelist = linelist[len(linelist)-1].split(';')

            # Create a dictionary containing the counter name and its value
            countername_value = {}
            for i in range(0,len(counternameslist)):
                countername_value[counternameslist[i]] = valuelist[i]

            self.log.debug("Value of SuccessfulCall(C) counter from log file is %s" %countername_value["SuccessfulCall(C)"])

            return (int(countername_value["SuccessfulCall(C)"])==noofcalls)  
        except:
            self.log.error('ERROR reading csv statistics log file of Nxgen!')
            return False  

    #Ticket - 33235 Method introduced to get Response Time between messages exchanges
    #Sipp scenario calculate time between two send or recv commands that have the start_rtd or rtd attributes.
    def getRTD(self):
        """
        Get from Nxgen counters the value of RTD.
        Read the csv log file of Nxgen. Read the RTD value
        """
        self.log.debug("Nxgen: getRTD called")
        try:
            f = open(self.logfilename, 'r')
            linelist = f.readlines()
            f.close()

            # The first line in the file would have names of the counter seperated by ;
            counternameslist = linelist[0].split(';')

            # The last line in the file would have the values of the counters at the
            # end of the run seperated by a ;
            valuelist = linelist[len(linelist)-1].split(';')

            # Create a dictionary containing the counter name and its value
            countername_value = {}
            for i in range(0,len(counternameslist)):
                countername_value[counternameslist[i]] = valuelist[i]

            self.log.debug("Value of ResponseTime(C) counter from log file is %s" %countername_value["ResponseTime(C)"])
            #convert the time in seconds
            timelist= countername_value["ResponseTime(C)"].split(':')
            return (int(timelist[0])*3600 + int(timelist[1])*60 + int(timelist[2]))
        except:
            self.log.error('ERROR reading csv statistics log file of Nxgen!')
            return -1
 

    def isMediaSuccessful(self,numberOfStreams):
        """
        Check whether media was successfully established for all the calls and whether
        packets were exchanged.
        Verify whether jitter is equal to 0 for all the calls and whether the number of packets
        transmitted/received parsed from the Nxgen Call Stat screen is non-zero.
        Also verify for the number of concurrent streams established.
        """
        try:
            # The first time the counters would be empty
            self._getScreen('5')

            # Get the output of MGEN System Statistics screen
            MGENSysStat = self._getScreen('')
            streams = self._getStreams(MGENSysStat)

            result = True

            if (int(streams) != numberOfStreams):
                self.log.error("Expected %s number of concurrent streams but Received %s" %(numberOfStreams,streams))
                result=False

            # Press 6 and Enter and c and Enter for Individual Call Stats mode
            temp = self._getScreen('6')
            time.sleep(.5)
            temp = self._getScreen('c')
            time.sleep(.5)

            # Get jitter,transmitted and received packets for the calls
            for callNum in range(0,numberOfStreams):
                time.sleep(.5)
                if callNum == 0:
                    jitter,Txdpkts,Rxdpkts,self.codec0 = self._getJitterTxdRxdPkts(callNum)
                if callNum == 1:
                    jitter,Txdpkts,Rxdpkts,self.codec1 = self._getJitterTxdRxdPkts(callNum) 
                #48768 - Added code in case of number of streams not passed as input parameter
                else:
                    jitter,Txdpkts,Rxdpkts,self.codec0 = self._getJitterTxdRxdPkts(callNum)
                if (int(jitter) >= 100):
                    self.log.error("Non-Zero jitter value %s for call %s" %(jitter,callNum))
                    result = False
                if (int(Txdpkts) == 0):
                    self.log.error("Zero packets Transmitted for call %s" %(callNum))
                    result = False
                if (int(Rxdpkts) == 0):
                    self.log.error("Zero packets Received for call %s" %(callNum))
                    result = False

            # Return back to the original screen
            time.sleep(.5)
            temp = self._getScreen('r')
            time.sleep(.5)
            temp = self._getScreen('1')
            return result

        except Exception,e:
            self.log.error('isMediaSuccessful: ERROR parsing Nxgen MGEN System Stat Screen 5 %s' %str(e))
            return False


    def _getStreams(self,MGENSysStat):

        # Check whether the screen contains the value of concurrent calls
        pos = MGENSysStat.find('concurrent streams')

        # Get the value against concurrent calls by parsing the string
        MGENSysStatList = MGENSysStat[pos:].split('|')

        # Remove the spaces and split on : to get the list as follows ['concurrentcalls', '0']
        concalllist = MGENSysStatList[0].replace(' ','').split(':')

        return concalllist[1]

    def _getJitterTxdRxdPkts(self,callNumber):

        # Get the Statistics for the call
        callStat = self._getScreen(str(callNumber))

        # Return the number of packets transmitted and received
        rxpos = callStat.find('RX')
        rxList1 = callStat[rxpos:].split('|')
        rxList2 = rxList1[1].split('pkts')

        txpos = callStat.find('TX')
        txList1 = callStat[txpos:].split('|')
        txList2 = txList1[1].split('pkts')

        # Check whether the screen contains the jitter value
        pos = callStat.find('jitter')

        # Get the value against concurrent calls by parsing the string
        callStatList = callStat[pos:].split('\n')

        # Remove the spaces and split on : to get the list as follows ['jitter', '0ms']
        jitterlist = callStatList[0].replace('\r','').replace(' ','').split(':')

        #18523
        return jitterlist[1].strip('ms'),txList2[0].strip(' '),rxList2[0].strip(' '),callStat


    def getResponseTimes(self):
        """ 
        Return the minimum, maximum and average response times 
        """
        pid = self.getPID()
        repStr = "_" + str(pid) + "_rtt.csv" 
        respTimeFileName = self.conf['xmlfile'].replace('.xml',repStr)

        self.log.info("Response Time Log File Name is %s" %respTimeFileName)

        linelist = []
        try:
            f = open(respTimeFileName, 'r')
            linelist = f.readlines()
            f.close()
        
            respTimeList = []
            tempList = []
            for tempstr in linelist[1:]:
                tempList = tempstr.split(';')
                respTimeList.append(round(string.atof(tempList[1])))
        
            totRespTime = 0.0
            avgRespTime = 0.0
            for respTime in respTimeList:
                totRespTime += respTime

            # Sort the response time list
            respTimeList.sort()
            avgRespTime = totRespTime/len(respTimeList)
        
            # Remove the csv log file
            os.system('rm %s' % respTimeFileName)
            self.log.info("Min,Max and Avg Response Times are %f %f %f" %(respTimeList[0],respTimeList[(len(respTimeList)-1)],avgRespTime))
            return respTimeList[0],respTimeList[(len(respTimeList)-1)],avgRespTime

        except Exception,e:
            self.log.error("CAUGHT EXCEPTION - %s - while parsing the Response Time log %s" %(str(e),respTimeFileName))
            return -1,-1,-1

    def _getScreen(self,screenNumber):
        """
        Send the screen number to Nxgen and get the output screen.
        """
        self.log.debug('Nxgen: Screen Number %s' % screenNumber)
        p = self.spawnProc
        p.sendline(screenNumber)
        try: 
            self.log.debug('Entered screen number')
            p.expect('generator', 5)
            self.log.debug('Nxgen Screen %s : RESULT_BEFORE: generator %s' %(screenNumber,p.before))
            self.log.debug('Nxgen Screen %s : RESULT_AFTER: %s' %(screenNumber,p.after))
        except pexpect.TIMEOUT,pexpect.EOF:
            self.log.error('Timedout waiting for message generator after sending the screen number')
            return ''
        return p.before    

    #18523
    def getCodec(self,numberOfStreams):
        """
        Get the codec for the stream
        """
        try:
            # The first time the counters would be empty
            if numberOfStreams == 0:
                callStat = self.codec0
            if numberOfStreams == 1:
                callStat = self.codec1
            codecPos = callStat.find("codec:")
            tempStr = callStat[codecPos:]
            newLinePos = tempStr.find('\n')
            finalStr = tempStr[:newLinePos]
            result = finalStr.strip('codec:')
            return result

        except Exception,e:
            self.log.error('getCodec: no codec found'+ str(e))
            return 'no codec found'


#18523 - Added this class of integrating OHPhone Application
class OhPhone(CallGen):
    """
    Manage the OhPhone call generator.
    """
    def __init__(self, properties, name=None):
        """
        Constructor here allows definition of configuration map.

        If that map is placed in the class header, it will become a
        class dictionary and therefore is shared by all objects, which
        is not good because every object will have its own configuration
        and hence this should be implemented as a member variable.
        """
        self.log = logging.getLogger('nextestlog')
        self.isConnected = False
        if name: self.name = name
        self.path = 'ohphone'
        self.outputString = ""
        self.conf = {
             'interfaceip':  None, # interface to bind to for incoming connections
             'gateway':      None, # gateway ip address
             'username':     None, # local alias name
             'calledparty':  None, # called party number
             'autoanswer':   None, # automatically answer incoming calls
             'usewavefile':  None, # use a Wav file as input instead of sound card
             'traceenable':  None, # enable trace
             'traceoutputfile':None, #trace output file name
             'listen':       None, # only listen for incoming calls
             'port' :        None, # listener port
             'codecsent':    None, # codec to sent
             'wavefile':     None, # Wave file to use
             # 36320 - added faststart
             'faststart':    None,
             #41488
             'nogatekeeper': None, # no gatekeeper
             #48768 - Added new parameter to set prohibited codec
             'prohibit': None, #Prohibited Codec
	     #57322 : No src address
	     'forwardAlways': None, #forward-always-party
            }

        self.configure( properties)

    def configure(self, properties):
        """
        Set up the necessary things for running Ohphone
        """
        for key in properties.keys():
            try:
                self.conf[key] = properties[key]
                self.log.debug('OhPhone: Setting configuration %s to %s' % (key, properties[key]))
            except:
                continue

    def go(self):
        """
        Start the Ohphone call generator
        """
        # Verify whether ohphone is installed
        if (pexpect.which('ohphone') == None):
            raise CallGenError('ohphone is not installed!')
        # Build the Command using the input parameters
        self.__makeConf()
        self.log.debug('Ohphone: Command: %s' % self.cmd)
        super(CallGen, self).__init__(
            self.cmd,           # Command to be executed
            [],                 # args to the exec
            '',                 # prompt to expect
            None                # parent
            )

        self.isConnected = True

    def __makeConf(self):

        # Set the command to ohphone and append the arguments
        self.cmd = self.path
        ############################################################
        # Mandatory parameters
        ############################################################
        # Verify whether the Mandatory Parameters have been provided
        if self.conf['gateway']:
            self.cmd += ' -g  %s' % self.conf['gateway']
        #41488 - Added option for no gatekeeper
        elif self.conf['nogatekeeper'] == 'yes':
            self.cmd += ' -n'
        else: raise CallGenError('"gateway" must be specified')

        self.cmd += ' -i %s' % self.conf['srcaddr']

        if self.conf['username']:
            self.cmd += ' -u %s' % self.conf['username']
        if self.conf['calledparty']:
            self.cmd += ' %s' % self.conf['calledparty']
        if self.conf['autoanswer']:
            self.cmd += ' -a'
        if self.conf['usewavefile']:
            self.cmd += ' --use-wav-file %s' % self.conf['usewavefile']
        if self.conf['traceenable']:
            self.cmd += ' %s' % self.conf['traceenable']
        if self.conf['traceoutputfile']:
            self.cmd += ' -o %s' % self.conf['traceoutputfile']
        if self.conf['listen']:
            self.cmd += ' -l'
        if self.conf['port']:
           self.cmd += ' --listenport %s' % self.conf['port']
        if self.conf['codecsent']:
            self.cmd += ' --prefer %s' % self.conf['codecsent']
        self.logfilename = self.conf['traceoutputfile']
        if self.conf['wavefile']:
            self.cmd += ' --use-wav-file %s' %self.conf['wavefile']
        if self.conf['faststart'] == 'disable':
            self.cmd += ' --fast-disable'
        #48768 - Added code to disable prohibited codec 
        if self.conf['prohibit']:
            self.cmd += ' --disable %s' %self.conf['prohibit']
	#57322 -Added code to always transfer the call
	if self.conf['forwardAlways']:
	    self.cmd += ' -F %s' %self.conf['forwardAlways']


    def _postConnect(self):
        """
        Make sure that Ohphone has started by checking for the prompt
        """
        self.log.debug('Ohphone: _postConnect')
        p = self.spawnProc
        msg = "_postConnect: Failed to get message 'established' after starting Ohphone"
        try:
            # Verify whether the process started successfully by checking for the message 'interactive mode'
            match = p.expect('Command ?', 5)
        except pexpect.TIMEOUT:
            self.log.error(msg)
            raise pexpect.TIMEOUT

        if match !=0:

            self.log.error(msg)
            raise CallGenError(msg)

    def isMediaSuccessful(self):
        if self.outputString.find("Packets Sent: 0") == -1 and self.outputString.find("Packets Rcvd: 0") == -1:
            return True
        else:
            return False

    def isCallSuccessful(self):
        if self.outputString.find("established") != -1 :
            return True
        else:
            return False

    def isCallTranscoded(self):
        startPos = self.outputString.find("Codec Sent: ")
        tmpStr = self.outputString[startPos:]
        startPos = tmpStr.find("Codec Sent: ")
        endPos = tmpStr.find("\n")
        codecSent = tmpStr[startPos+12:endPos]
        startPos = self.outputString.find("Codec Received: ")
        tmpStr = self.outputString[startPos:]
        startPos = tmpStr.find("Codec Received: ")
        endPos = tmpStr.find("\n")
        codecRcvd = tmpStr[startPos+16:endPos]
        #48768
        return codecSent,codecRcvd 

    def disconnect(self):
        try:
            self.log.info("disconnect Ohphone called")
            if self.isConnected:
                p = self.spawnProc
                if p.isalive():
                    p.sendline('q')
                else:
                    p.sendline('q')
                    print "CHILD is DEAD"
                p.expect('ended',5)
                self.outputString = p.before
                self.log.info("disconnect: %s" %self.outputString)
        except pexpect.TIMEOUT,pexpect.EOF:
                self.log.info("disconnect TIMEOUT Exception")
        self.cleanUp()

  

########################################################################
# Local Variables:
# mode: python
# indent-tabs-mode: nil
# fill-column: 78
# auto-fill-function: do-auto-fill
# End:
