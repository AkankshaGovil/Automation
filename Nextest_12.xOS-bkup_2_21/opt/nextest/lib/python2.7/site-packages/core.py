"""

"""
import os
import pexpect
from   Queue import *
import signal
import socket
import string
from   threading import *
import time
#34036
from session import *
from msw import *
#34951
import commands
import logging



class CoreWatcher(Thread):
    """Thread object that terminates testing if a core file is seen.

    This object will run in the background during testing, checking at regular
    intervals for files named "core*" on the specified host.

    host -- the name or IP address of the host to watch

    sem -- a Semaphore object which will be acquired by this thread and
    released when a core file is detected

    If a core file is detected, the semaphore will be released
    """
    # Watcher states

    INIT = "INITIALIZED"
    CONNECTED = "CONNECTED"
    STOPPING = "STOPPING"
    DISCONNECTED = "DISCONNECTED"
    
    def __init__(self, host, caller):
        Thread.__init__(self, name="core_watch")
        self.host = host
        self.caller = caller
        self.interval = 5
        self.q = Queue()
        self.state = self.INIT
        #34036 Intialization
        self.mswinfo = MSWInfo('mymsw')
        self.verCheck_3_0 = self.mswinfo.compareiServerVersion('3.0')
        self.verCheck_4_0 = self.mswinfo.compareiServerVersion('4.0')
        if ((self.verCheck_3_0 >= 0) and (self.verCheck_4_0 < 0)):
            self.corepath = '/opt/core/'
        else:
            self.corepath = '/var/core/'
        self.msw  = SSH(['root@mymsw'])
        #34951 - Removed the hardcoded path and used the member variable
        self.initCoreCount = self.msw.filter('ls %s | wc -l' %self.corepath)
        self.initCoreCount = self.initCoreCount.strip('|')
        self.newCoreCount = self.initCoreCount
        self.listcmd = "ls -lrt %s | awk '{print $9}'" %self.corepath

        self.origCoreFiles = self.msw.filter(self.listcmd)
        #34951
        self.nextestlog = logging.getLogger('nextestlog')

    def request(self, msg):
        "Put a request into the input queue"
        if self.state == self.CONNECTED:
            self.q.put(msg)
        else:
            self.log("CoreWatcher: state %s, ignoring request" % self.state)

    def log(self, message):
        print message
        #34951 - Added to put the log message in nextest log
        self.nextestlog.debug(message) 
        
        
    def run(self):
        """Main thread code.

        First, acquire the semaphore; this tells the caller that we are
        watching and everything is OK. After connecting to the host with SSH,
        enter a loop.  The loop monitors the /var/core directory on the host
        at regular intervals.  If any file appears that starts with "core",
        release the semaphore to signal the caller that a core has been
        detected. 

        If no core files are found, process messages in the input queue (stop
        is the only message currently used) and go to sleep.  When all tests
        have finished, the caller must request a STOP.

        Regardless of the method of loop termination, the remote shell will be
        disconnected prior to exiting the thread.
        """
        self._connect()
        msg = 'monitoring %s at %d second intervals' % (self.host,
                                                        self.interval)
        #self.log('CoreWatcher: %s' % msg)
        while self.state == self.CONNECTED:
            try:
                core = self._checkCoreFile()
            #14000
            except OSError,e:
                # For some reason, after tests are finished, the sendline()
                # in checkCoreFile() fails with:
                #
                # File "...site-packages/pexpect.py", line 439, in send
                # return os.write(self.child_fd, str)
                # OSError: [Errno 9] Bad file number
                #
                # The ssh connection is still up but we've lost track of it.
                # This may be something to do with NexTest tearing down the
                # logicial IP interfaces on Solaris?  Anyway, hack for now:
	        # get out of the loop and shut down the connection.
               #14000 
                self.log("CoreWatcher: Exception: %s - caught OSError, shutting down" % str(e))
                break
                
            if core:
                #self.log('CoreWatcher: releasing semaphore')
                self.caller.put('CORE')
                msg = self.q.get()
                # wait for caller message
                if msg == 'GO':
                    #34036 - Removed clear core method for not to remove the 
                    #corefile
                    self.log('CoreWatcher: continue')
                    continue
                elif msg == 'STOP':
                    #34036 - Removed clear core method for not to remove the
                    #corefile
                    print "All done"
                    self.state=self.STOPPING
                else:
                    print "got unknown message from caller"
            try:
                msg = self.q.get_nowait()
            except Empty:
                """
                Nothing to do
                """
                #self.log("CoreWatcher: no messages to process")
            else:
                # only one kind of message for now: STOP
                if msg == 'GO':
                    #print "CoreWatcher: deleting core file"
                    self.ssh.sendline
                if msg == 'STOP':
                    self.log('stopping')
                    self.state = self.STOPPING
            #self.log('sleeping')
            time.sleep(self.interval)

        # Loop complete.  Clean up.
        self._disconnect()

    def _clearCores(self):
        #34951 - Removed the hardcoded path and used the member variable
        self.ssh.sendline('rm -f %s/core*'%self.corepath)
        self.ssh.expect(self.bashPrompt)
        
    def _connect(self):
        "Connect to the remote host with ssh."
        
        sshConnect = "ssh %s@%s" % ('root', self.host)
        self.bashPrompt = "[$#]"
        self.ssh = pexpect.spawn(sshConnect)
        self.ssh.expect(self.bashPrompt, 3)
        self.state = self.CONNECTED
        self.log("CoreWatcher: connected to %s" % self.host)
        
    def _disconnect(self):
        "Disconnect from remote host and kill pexpect process."
        
        if self.state != self.DISCONNECTED:
            try:
                self.ssh.sendline('exit')
            #14000
            except OSError,e:
                self.log("CoreWatcher: Exception: %s - problems disconnecting" % str(e))
                self.ssh.kill(signal.SIGKILL)
            self.state = self.DISCONNECTED
            self.log("CoreWatcher: disconnected from %s" % self.host)

    def _checkCoreFile(self):
        """Tell the caller if a core file is found by looking at contents of
        var/core on remote host.
        """
        #34036 - Modified check core file to check for the latest core file
        #which is compatible on all the versions of iserver 
        #34951 - Added to Clear the buffer so that the output of the
        # previous command is eatenup
        self.msw.assertCommand('')
        #34951 - Removed the hardcoded path and used the member variable
        self.newCoreCount = self.msw.filter('ls %s | wc -l'%self.corepath)

        self.newCoreCount = self.newCoreCount.strip('|') 
        if self.newCoreCount > self.initCoreCount:
            newCoreStr = self.msw.filter(self.listcmd)
            modCoreStr = newCoreStr
            # On Linux, . is also present in the output which needs to be removed 
            #34951 Added code to remove the .\r\n which is present
            tmpStr = self.origCoreFiles.rstrip('.\r\n')
            tmpStr = tmpStr.rstrip('\r\n')
            tmpStr = tmpStr.replace('..\r\n','$$') 
            tmpStr = tmpStr.replace('.\r\n','')
            tmpStr = tmpStr.replace('$$','..\r\n')
            # Remove the old core files from the string to find out the name(s) of the
            # new core files
            newCoreStr = newCoreStr.replace(tmpStr,'')
            newCoreFilesList = newCoreStr.split('\r\n')
            for coreFile in newCoreFilesList: 
                if coreFile.startswith('core') or coreFile.startswith('gcore'):
                    self.log("CoreWatcher: ****** CORE DETECTED ******")
                    self.log('CoreWatcher: %s' % coreFile)
                    self.log('CoreWatcher: ***************************')
                    print "\n****** CORE FILE DETECTED  ******\n"
                    #34951 - Added code to kill the java process c07-sip-r2.jar
                    #so that current iteration will be stopped once core file is found
                    command = 'pgrep -x java'
                    pidStr = commands.getoutput(command)
                    pidList = pidStr.split('\r\n')
                    for i in pidList:
                        msg = "ps -fp %s" %str(i)
                        res = commands.getoutput(msg)
                        if res.__contains__('c07-sip-r2.jar'):
                            str1 = "kill -9 %s" %str(i)
                            os.system(str1)
                            break
 

            # Re-initialise the counters
            self.initCoreCount = self.newCoreCount.strip('|')
            self.origCoreFiles = modCoreStr
            return True

        #self.log("CoreWatcher: no core files detected")
        return False
        
########################################################################
# Local Variables:
# mode: python
# indent-tabs-mode: nil
# fill-column: 78
# auto-fill-function: do-auto-fill
# End:
