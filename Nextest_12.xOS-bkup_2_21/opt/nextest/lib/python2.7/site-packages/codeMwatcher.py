import os
import pexpect
import signal
import socket
import string
import time
import logging
from session import *
from msw import *
import commands



mswinfo = MSWInfo('mymsw')
verCheck_4_3 = mswinfo.compareiServerVersion('4.3')


class SessionException(Exception):
    """Generic exception for all sessions.  Accepts a string."""
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class CodeMemWatcher(object):
    """  Codenomicon Memory Watcher """

    INIT = "INITIALIZED"
    CONNECTED = "CONNECTED"
    STOPPING = "STOPPING"
    DISCONNECTED = "DISCONNECTED"
    SSHCONNECTED = "SSHCONNECTED"
    MEMSTART = "mem_start"
    MEMSTOP = "mem_stop"
    REMOTE_RESULTS = "/usr/local/nextone/bin"
    telnetPrompt = "iServer >"
    bashPrompt = "[$#]"

    def __init__(self, host,resultdir=None):
        """ Initializing variables """
        self.host = host
        self.state = self.INIT
        self.telnetstate = self.INIT
        self.logg = logging.getLogger('nextestlog')

    def start(self):
        """
        Connect to MSW and telnet to port 10005 and start memory logging.
        """
        try:
            self._connect()		#connecting to MSW(SSH session)
            self._telnet()		#SSH to MSW and telnet to port 10005
        except Exception,exc:
            raise exc

        self.getTsm()                   #get TSM state and check for 0 call status     
        self.sendDMcmd(self.MEMSTART)   #instruct dmalloc to start memory logging

    def getTsm(self):
        """
        Execute get tsm command
        """ 
        cmd = 'get tsm'
        # ticket 39281 - output of "get tsm" command for 4.3 builds and up is empty
        if (verCheck_4_3 >= 0):
            Exp_result = ''
        else:
            Exp_result = 'TSM invs=0, invc=0, byes=0, byec=0, cs=0, cc=0'
        running = True
        while running:
            if self.telnetstate == self.CONNECTED:
                self.ssh.sendline('')
                self.ssh.expect(self.telnetPrompt)
                self.ssh.sendline(cmd)
                self.ssh.expect(self.telnetPrompt,10)
                Rec_Result = self.ssh.before
                if Rec_Result.__contains__(Exp_result):
                    running = False
            else:
                self.log("CodyMemoryWatcher: telnetstate %s, ignoring request" % self.telnetstate)

    def sendDMcmd(self,cmd=None,expected="iServer >"):
        """
        Instruct dmalloc to start or stop the memory logging.
        """
        if self.telnetstate == self.CONNECTED:
            self.ssh.sendline('')
            self.ssh.expect(self.telnetPrompt)
            self.ssh.sendline(cmd)
            self.ssh.expect(expected,10)
        else:
            self.log("CodeMemoryWatcher: telnetstate %s, ignoring request" % self.telnetstate)
    
    def _telnet(self):
        """ Establish Telnet session on 127.0.0.1 10005 """
        
        self.ssh.sendline('telnet 127.0.0.1 10005')
        try:
            self.ssh.expect(self.telnetPrompt, 5)
        except pexpect.TIMEOUT:
            raise SessionException("CodeMemoryWatcher: Unable to telnet to host %s on 127.0.0.1 10005" %self.host)
        self.telnetstate = self.CONNECTED

    def request(self, msg, COUNT):
        """ Copy gis_malloc.inuse, stack_trace.txt, iserver.log files to files_count """

        if self.telnetstate == self.CONNECTED and msg == 'GETRESULTS':
            
            self.sendDMcmd(self.MEMSTOP)
            time.sleep(1)
            self.ssh.sendline('quit')
            time.sleep(1)  
            self.ssh.expect(self.bashPrompt)

            try:
                self.ssh.sendline('cd %s ' %self.REMOTE_RESULTS)
                self.ssh.expect(self.bashPrompt)
                self.ssh.sendline('dmallout.pl > gis_malloc.inuse')
                self.ssh.expect(self.bashPrompt)
                dmall_success = self.ssh.before
                self.ssh.sendline('cd')
                if not dmall_success.__contains__('Excess command line arguments ignored'):
                    self.log('Error executing dmallout.pl') 
                    return None
                self.ssh.sendline('cp %s/gis_malloc.inuse %s/gis_malloc.inuse_%s' %(self.REMOTE_RESULTS,self.REMOTE_RESULTS,COUNT))
                self.ssh.expect(self.bashPrompt)
                self.ssh.expect(self.bashPrompt)
                self.ssh.sendline('cp %s/stack_trace.txt %s/stack_trace.txt_%s' %(self.REMOTE_RESULTS,self.REMOTE_RESULTS,COUNT))
                self.ssh.expect(self.bashPrompt)
                st_success = self.ssh.before
                if st_success.__contains__('No such file or directory'):
                    self.log('Error - stack_trace.txt_%s file is not created' %COUNT)
                self.ssh.sendline('cp /var/log/iserver.log /var/log/iserver.log_%s' %COUNT)
            except Exception,e:
                msg = "file error: %s" % str(e)
                self.log("Error copying Result File(s)")
                self.logg.error(msg)  

            ## Blank out iserver.log, stack_trace.txt. gis_malloc.inuse

            self.ssh.sendline('echo > /var/log/iserver.log')
            self.ssh.sendline('echo > %s/stack_trace.txt' %self.REMOTE_RESULTS)
            self.ssh.sendline('echo > %s/gis_malloc.inuse' %self.REMOTE_RESULTS)
            self.ssh.expect(self.bashPrompt)

        elif msg == 'STOP':
            if self.telnetstate == self.CONNECTED:
                self.ssh.sendline('bye')
                try:
                    match = self.ssh.expect("Connection closed by foreign host",10)
                    if match == 0: 
                        self.ssh.expect(self.bashPrompt,2)
                    self.telnetstate = self.SSHCONNECTED
                except pexpect.TIMEOUT:
                    self.logg.error("CodeMemoryWatcher: Error exiting from telnet")

            self._disconnect()

        else:
            self.logg.error("CodeMemoryWatcher: request: invalid request")

    def log(self, message):
        print message

    def _connect(self):
        """ Establish an SSH session with the remote Host """
        
        sshConnect = "ssh %s@%s" % ('root', self.host)
        self.bashPrompt = "[$#]"
        self.ssh = pexpect.spawn(sshConnect)
        try:
       	    self.ssh.expect(self.bashPrompt, 60)
        except pexpect.TIMEOUT:
            raise SessionException("CodeMemoryWatcher: Error connecting to host %s" %self.host)
        self.state = self.CONNECTED
        self.logg.error("CodeMemoryWatcher: connected to %s" % self.host)
        
    def _disconnect(self):
        "Disconnect from remote host and kill pexpect process."
        
        if self.state != self.DISCONNECTED:
            try:
                self.ssh.sendline('exit')
                while self.ssh.isalive():
                    self.ssh.kill(signal.SIGKILL)
                    time.sleep(1)
            except OSError:
                self.logg.error("CodeMemoryWatcher: problems disconnecting")
                self.ssh.kill(signal.SIGKILL)
            self.state = self.DISCONNECTED
            self.logg.error("CodeMemoryWatcher: disconnected from %s" % self.host)
 
    def copyfiles(self):
        """ Copy dmallout.pl and mymalloc.inuse files to host machine """

        try:
            os.system('scp -q /var/opt/nextest/tdb/negative.qms/codenomicon.qms/dmallout.pl root@mymsw:/usr/local/nextone/bin/dmallout.pl')
            os.system('scp -q /var/opt/nextest/tdb/negative.qms/codenomicon.qms/mymalloc.inuse root@mymsw:/usr/local/nextone/bin/mymalloc.inuse')
        except Exception, e:
            msg = "file error: %s" % str(e)
            self.log("Error copying files to MSW")
            self.logg.error(msg)

        
########################################################################
# Local Variables:
# mode: python
# indent-tabs-mode: nil
# fill-column: 78
# auto-fill-function: do-auto-fill
# End:
