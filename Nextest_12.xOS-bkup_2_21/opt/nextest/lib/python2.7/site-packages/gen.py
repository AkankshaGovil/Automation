"""
Protocol generation module.

This module is a departure from the call gen control used in the first
demo of the product.  That system assumed both the MSW *and* the
callgen were remote systems.  For this new pass, we're assuming that
the test system is colocated with the call gens on a Solaris box.

The gens here are not being controlled via an ssh channel, which makes
things somewhat simpler.
"""

from   dlog import *
import os
import session
import posix
from   types import *
from   warnings import *
import logging

# 54705: Added These two classes to get userConfig values without passing context dictionary

from   qm.test.context import Context
from   qm.test.readUserConfig import UserConfig

# global variables used by tests for persistent storage
mediaport=49200

# Portability switch
LINUX = 'Linux'
SOLARIS = 'SunOS'
ostype = posix.uname()[0]

class EndpointError(Exception):
    "An endpoint error occurred."

class Endpoint(object):
    """
    An IP endpoint with optional VOIP protocol generators.

    This class is responsible for managing the network configuration
    of an endpoint and for providing a bridge between the tests and
    the call generator implementations.

    Note that he system commands used to set up and tear down logical
    Ethernet interfaces are supported on Solaris only.

    The constructor accepts the following arguments:

    addr -- the address of the endpoint on the local system.  If this address
    does not already exist on the local system, a new logical interface will
    be created.  Addresses may not be specified for remote systems yet.

    mask -- the network mask for the new address

    eth -- the Ethernet interface that the address is associate with.  There
    is no check to verify that an existing address matches the eth supplied by
    the caller.
    """
    def __init__(self, addr, mask, eth, name=None):
        """
        Associate the new endpoint with an IP address.

        This constructor gets a list of Ethernet interfaces on the
        local system and then tries to determine if the requested IP
        address already exists.
        """
        self.log = logging.getLogger('nextestlog')
        self.log.debug('Endpoint: addr: %s mask: %s eth: %s' % (addr, mask, eth))
        if name: 
            self.name = name
        else:
            self.name = "NoName"
        import time
        time.sleep(1)
        self.addrMap = getIFAddrs()
        self.addr = addr
        if addr not in self.addrMap.values():
            msg = 'address %s is not configured for %s' % (addr, name)
            self.log.error(msg)
            raise EndpointError(msg)
        self.mask = mask
        self.eth = eth
        self.createdIF = False
        self._gen = None
        self.proto = None
        self.configValues = {
            'ipaddr': addr,
            'mask': mask,
            'ifname': eth,
            'priority' : '',
            'callingplan': '',
            'extn': '',
            'realm': '',
        }
        # 10409 - Initialize the Media variables
        self.verifyMedia=False
        self.mediaResult=[]  
        
    def __del__(self):
        "Remove the interface if created by _bindInterface()."
        self.log.debug('gen: destructor called for %s' % self.configValues['ipaddr'])
        self.cleanup()

    def assertConnected(self):
        """hmm. gen methods are sneaking in here because i wanted _gen to
        be protected... maybe not wise"""
        try:
            self._gen.assertConnected()
        except Exception, exc:
            self.log.debug("Endpoint.assertConnected: caught %s" % str(exc)) 
            self.stop()
            raise EndpointError("%s: Endpoint connect: %s" % \
                                (self.addr, str(exc)))

    def cleanup(self):
        """
        Cleanup up call generator and logical interface.

        If the gen is running, stop it.
        """
        self._cleanupCallGen()
        
    def _cleanupCallGen(self):
        """
        Stop the call gen if it is there.
        """
        if type(self._gen) is not NoneType:
            self.log.debug('cleanup: stopping call generator')
            self.stop()
       
    def assertCommand(self, command, expected=None, timeout=3, message=None):
        """
        Send a command to the process spawned by pexpect and wait for
        the expected output.
        """
        try:
            self._gen.assertCommand(command, expected, timeout)
        #14000
        except Exception, e:
            msg = "Endpoint.assertCommand: Caught %s" %str(e) 
            self.log.error(msg)
            self.stop()
            if not message:
                message = '%s: "%s" failed ouput check: %s' %(self.addr, command, expected)
            raise EndpointError(message)

        # 54705 nxgen_confiure as a wrapper for configure of nxgen

    def nxgen_configure(self,scenariofile,datafile=None):
            """
            A Wrapper function only for nxgen, to be used by Engg for simplicity.
            takes in only the scenario file as input and makes one call
            """
            fdesc = open('/etc/hosts','r')
            fcont = fdesc.readlines()
            fdesc.close()
            public_rsa1 = None
            private_rsa1 = None
            ind = 0
            for cont in fcont:
                ind += 1
                if not cont.__contains__('#'):
                    if cont.__contains__('pub_rsa'):
                        public_rsa1 = cont
                        pubind = ind
                        if private_rsa1:
                            break
                    if cont.__contains__('prv_rsa'):
                        private_rsa1 = cont
                        prvind = ind
                        if public_rsa1:
                            break

            pub_rsaList = public_rsa1.split(' ')
            pub_realm = pub_rsaList[0]
            prv_rsaList = private_rsa1.split(' ')
            prv_realm = prv_rsaList[0]

            usrcfg = Context()
            userconfig_value = UserConfig(usrcfg)
            public_interface = usrcfg['userConfig.eth_pub_iface']
            private_interface = usrcfg['userConfig.eth_pri_iface']
            if self.eth=='eth%s'% public_interface:
                realm_rsa=pub_realm
            elif self.eth=='eth%s'% private_interface:
               realm_rsa=prv_realm

            if not datafile:
                self.configure('nxgen',
                              calls='1',
                              gateway=realm_rsa,
                              xmlfile=scenariofile,
                              )
            else:
                self.configure('nxgen',
                              calls='1',
                              gateway=realm_rsa,
                              xmlfile=scenariofile,
                              csvfile=datafile
                              )

    def assertOutput(self, expected=None, timeout=5, message=None):
        """
        Wait for the expected output from the spawned pexpect process.
        """
        try:
            self._gen.assertOutput(expected, timeout)
        #14000
        except Exception, e:
            msg = "Endpoint.assertOutput: Caught %s" %str(e)
            self.log.error(msg)
            self.stop()
            if not message:
                message = "%s: failed gen ouput check: %s" % (self.addr,
                                                              expected)
            self.log.error(message)
            raise EndpointError(message)
        self.log.info('endpoint "%s" assertion OK', self.name)

    def configure(self, proto, **properties):
        """
        Configure the endpoint for protocol generation.

        Instantiate the necessary call generator if it doesn't exist
        yet.  All properties except proto will be passed down to the gen
        implementation. 

            - mode --		send or receive

            - regid --		registration ID (not H.323 ID)
            
            - srcnum --		starting phone number of caller ['555']

            - destnum --		starting phone number of callee ['666']

            - srcaddr --		source name or IP of outgoing calls

            - gateway --		destination gateway name or IP

            - gwport --		dest gateway port

            - numcalls --		number of calls to make ['1']

            - media --		enable or disable

            - response --		cause code from when listening

            - mediastartport --	starting port for RTP

            - origtrunkgroup --	originating trunk group

            - desttrunkgroup --	destination trunk group

            
            Properties specific to H.323:
            
            - file --		 name of gen config file

            - start --		 fast, slow, fast-no-245

            - h323id --		 H.323 ID

            - fax --			 FAX call

            - gkaddr --		 gatekeeper address

            - maxcalls --		 number of calls to run to [20] ?

            - transferor --      call transfer transferor
            

            Properties specific to SIP:

            - desturi --		 destination URI

            - srcuri --		 source URI

            - register --		 register before call

            - transferatt --	attended call transfer expected

            - transferee --	call transfer transferee
            
       """

        #we used to reconfigure existing gens for new configuration but it lead
        #to problems when we used the same endpoint resource (read IP address)
        #to simulate SIP and thereafter H323 endpoint or vice versa. Reconfiguring
        #gens in this case meant that we were using SIP gens for H323 or vice versa.
        #Now we simple disconnect the older gens and create a new gen everytime. 
        #This also means that calling configure twice would wipe older configuration. 
        #This will not create problem for existing test cases.

        self.proto = proto
        if self._gen:
            self.log.debug('destroying existing gen on %s' % self.addr)
            # ignore proto.  hack.
	    self._gen.disconnect()
            self._gen = None

        # 10409 - Initialize the Media variables
        self.verifyMedia=False
        self.mediaResult=[] 

        # 36319 - Introduce a new variable to hold the check HVAL value
        self.checkHVal = False

        # 58451 - Introduce a new variable to hold the check hung value
        self.checkHung = False

        self.log.debug('configuring new gen on %s' % self.addr)
        properties['srcaddr'] = self.addr

        # 58451 - Check whether proto is not none
        if proto != " ":
            self.checkHung = True

        if proto == 'sip':
            self._gen = session.SIPGen(properties, self.name)
        elif proto == 'h323':
            self._gen = session.H323Gen(properties, self.name)
            # 36319 - Check the HVAL value only if the endpoint is of H323 type
            self.checkHVal = True
        #18523
        elif (proto == 'nxgen'):
            self._gen = session.NxGen(properties, self.name)
        elif (proto == 'sipp'):
            self._gen = session.Sipp(properties, self.name)
        elif (proto == 'ohphone'):
            self._gen = session.OhPhone(properties, self.name)
            # 36319 - Check the HVAL value only if the endpoint is of H323 type
            self.checkHVal = True
        else:
            raise EndpointError('unknown protocol for endpoint')

        self.log.info('endpoint "%s" configuration complete' % self.name)
        
    def setValue(self, key, value):
        self.configValues[key] = value

    def getValue(self, key):
        if key in self.configValues.keys():
            return self.configValues[key]
        else:
            return self._gen.getValue(key)

    def getInfo(self, key):
        """
        Get information about the state of the generator.

        This is closely tied to the implementation of the call gens in
        that the getStats() call returns a map with keys that are
        directly taken from the output of the NexTone generators.

        This is not necessarily undesirable: seeing the output of the
        gens lets developers knows exactly what to specify in their
        tests. 
        """
        stat = self._gen.getStats()
        return stat[key]
        
    def go(self, **properties):
        """
        Start the generator.
        """
        self.log.debug('Endpoint: gen go from %s' % self.addr)
        #self.log.debug('This is go method of Gen.py')

        if properties:
            self._gen.configure(properties)
        try:
            self._gen.go()
        except Exception, exc:
            msg = "Endpoint.go: %s" % exc
            self.log.error(msg)
            self.stop()
            raise EndpointError(msg)
        self.log.info('endpoint "%s" started' % self.name)
        
    def stop(self):
        """
        Disconnect all calls ...
        """
        if self._gen:
            self._gen.disconnect()
        else:
            self.log.debug("Endpoint: stop:Gen doesn't exist yet") 
        self.log.info('endpoint %s stopped' % self.name)

    def isScenarioSuccessful(self,noofcalls=-1):
        """Check for the exit message from SIPP.
        """
        return (((self.proto == 'sipp') or (self.proto == 'nxgen')) and (self._gen.isScenarioSuccessful(noofcalls)))

    #Ticket 33235 
    def getRTD(self):
        """Get ResponseTime from SIPP.
        """
        if (self.proto == 'nxgen'):
            return (self._gen.getRTD())
        else:
            return -1

    def isMediaSuccessful(self,numberOfStreams=0):
        """ 
        Check whether media was established successfully for all the calls and whether
        packets were transmitted and received by all calls.
        """
        #18523
        if (self.proto == 'nxgen') :
            return (self._gen.isMediaSuccessful(numberOfStreams))
        elif (self.proto == 'ohphone'):
            return (self._gen.isMediaSuccessful())

    #18523
    def getCodec(self,numCalls):
        return (self._gen.getCodec(numCalls))

    #18523
    def isCallTranscoded(self):
        return ((self.proto == 'ohphone') and (self._gen.isCallTranscoded()))

    #18523
    def isCallSuccessful(self):
        return ((self.proto == 'ohphone') and (self._gen.isCallSuccessful()))

    def getPID(self):
        return self._gen.getPID()

    #18523
    def sendQuit(self):
        if (self.proto == 'nxgen'):
            self._gen.sendQuit()

    def getResponseTimes(self):
        if (self.proto == 'nxgen'):
            return self._gen.getResponseTimes() 
        else:
            return -1,-1,-1

import commands
def getIFAddrs():
    """
    Get the IP addresses for all physical and logical Ethernet interfaces.

    This is a crude and non-portable thing that should be tossed out
    at some point - would be better to do this with ioctl() or some
    other library. 
    
    This function relies on an external program to retrieve the
    interface names and addresses.  It requires that the output be
    returned as a string in the format:

        'if_name if_addr \n if_name if_addr \n [...] '

    The line breaks are not required - any white space will do.

    This function will parse the line and return a dictionary of
    name/address pairs.
    """
    gifa_log = logging.getLogger('nextestlog')
    helper = 'getethers'   # external prog fetches I/F's and IP addrs
    if os.environ.has_key('NEXTEST_BIN'):
        helper = os.environ['NEXTEST_BIN']+'/'+helper
    stat, raw = commands.getstatusoutput(helper)
    if stat != 0:
        raise OSError('error running "%s" helper program' % helper)
    output = {}
    input = raw.split()
    for item in range(0, len(input), 2):
        output[input[item]] = input[item+1]
    gifa_log.debug('gen: getIFAddrs:')
    for key in output:
        gifa_log.debug('   interface: %-10s  addr: %s' % (key, output[key]))
    return output

########################################################################
# Local Variables:
# mode: python
# indent-tabs-mode: nil
# fill-column: 78
# auto-fill-function: do-auto-fill
# End:
