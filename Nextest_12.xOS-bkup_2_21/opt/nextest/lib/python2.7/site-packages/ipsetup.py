"User-oriented IP management functions for NexTest installation"
import gen
import os
import posix
import socket
import unittest

class IPManager(object):
    #PR 184675 Added resource eth2 and eth3 for sipp
    def __init__(self):
        self.localPublic = [
            ['mygen' 	, self.getDevAddr('eth0')],
            ['gnuGK'    , self.getDevAddr('eth0')],
            ['pub_nat'	, None],
            ['pub_ep'	, None],
            ['public1'	, None],
            ['public2'	, None],
            ['public3'	, None],
            ['public4'	, None],
            ['public5'	, None], 
            ['public6'	, None], 
            ['public7'	, None], 
            ['public8'	, None], 
            ['public9'	, None], 
            ['public10'	, None], 
            ['public11'	, None], 
            ['public12'	, None], 
            ['public13'	, None], 
            ['public14'	, None], 
            ['public15'	, None], 
            ['public16'	, None],
            ['public17' , None], 
            ['gatekeeper1' , None],
            ['nxgenIP1' , None],
            ['nxgenIP2' , None],
            ['sipproxy' , None],
            ['ast_sipproxy' , None],
            ['seattle'	, None],
            ['portland'	, None],
            ['newyork'	, None],
            ['boston'	, None],
            ['chicago'  , None],
            ['eth2'  , None],
            ['eth0'  , None],
            ['codenomicon1'  , None],
            ['codenomicon2'  , None],
            ['maryland' , None],
            ['radiusprimary'	, None],
            ['nat_public1', '192.168.0.100'],
            ['nat_public2', '192.168.0.101'],
            ['nat_public4', '192.168.0.102'],# 51398: Added public nat IP
            #Ticket-36225:
            ['codenomicon3', None],
            ['codenomicon4', None],
            # 38969: New NAT device
            ['pub_nat1'  , None],
            ['nat_public3', '192.168.2.100'],
            ]
        self.localPrivate = [
            ['prv_nat'	, None],
            ['prv_ep'	, None],
            ['private1'	, None],
            ['private2'	, None],
            ['private3'	, None], 
            ['private4'	, None], 
            ['private5'	, None], 
            ['private6'	, None], 
            ['private7'	, None], 
            ['private8'	, None], 
            ['private9'	, None], 
            ['private10', None], 
            ['private11', None], 
            ['private12', None], 
            ['private13', None], 
            ['private14', None],
            ['private15', None],
            ['private16', None],
            ['private17', None], 
            ['gatekeeper2', None],
            ['sandiego'	, None],
            ['phoenix'	, None],
            ['atlanta'	, None],
            ['miami'	, None],
            ['texas'    , None], 
            ['london'   , None],
            ['eth3'  , None], 
            ['eth0'  , None], 
            ['london'   , None],
            ['radiussecondary'	, None],
            ['nat_private1', '192.168.1.100'],
            ['nat_private2', '192.168.1.101'],
            ['nat_private3', '192.168.1.102'], # 51005: Added private nat IP
            ['nat_private4', '192.168.1.103'], # 51398: Added private nat IP
            ]
        self.remotePublic = [
            ['mymsw' 		, None], # MSW primary eth0
            ['staticrealm'	, None],
            # 29332 -- Need to add this entry during nextest installation
            ['pub_test.com'     , None],
            ['pub_rsa'		, None],
            ['pub_nat'		, None],
            ['enum_realm'       , None], # IP address to be assigned to the enum_realm
            ['rh_realm_c'       , None],  
            ['bkupmsw'          , None],
            ]
        self.remotePrivate = [
            ['dynamicrealm'	, None],
            ['qanextest.com'	, None],
            # 29332 -- Need to add this entry during nextest installation
            ['qanextest.com.'    , None],
            ['prv_rsa'		, None],
            ['prv_nat'		, None],
            ['rh_realm_psx'     , None]     
            ]
        self.hosts = { 'localpublic' 	: self.localPublic,
                       'localprivate'	: self.localPrivate,
                       'remotepublic'	: self.remotePublic,
                       'remoteprivate'	: self.remotePrivate
                       }
        
        #maps logical networks to physical interfaces
        self.networkMapping = { 'localpublic' 	: '0',
                                'localprivate'	: '1',
                                'remotepublic'  : '0',
                                'remoteprivate' : '1'
                              }

    def getAddr(self, name):
        try:
            addr = socket.gethostbyname(name)
            return addr
        #14000
        except socket.gaierror, e:
            print "Exception: %s" % str(e)
            return None
       
    def getNetwork(self, name):
        for network in self.hosts.keys():
            for host in self.hosts[network]:
                if name == host[0]:
                    return self.networkMapping[network]
        return '-1'

    def getDevAddr(self, device):
        "Get IP address for device"
        ipmap = gen.getIFAddrs()
        for dev in ipmap.keys():
            if dev == device: return ipmap[dev]
        return None
    
    def getDevice(self, addr):
        "Get Ethernet device for ip address.  Return None if not found"
        ipmap = gen.getIFAddrs()
        for eth in ipmap.keys():
            if ipmap[eth] == addr: return eth
        return None

    def getHosts(self, network):
        if network == 'all':
            all = []
            for net in self.hosts.keys():
                all.extend(self.hosts[net])
            return all
        
        return self.hosts[network]

    def makeAlias(self, ip, dev):
        MakeAlias(ip, dev)

    def promptIP(self, host, default = None):
        while True:
            if default:
                prompt = 'Enter IP for %s [%s]: ' % (host, default)
            else:
                prompt = 'Enter %s IP address: ' % host
            addr = raw_input(prompt)
            if default and addr == '':
                return default
            try:
                # validate and format the address
                addr = socket.gethostbyname(addr)
                return addr
            #14000
            except socket.gaierror,e:
                print "Exception: %s - Invalid IP address" % str(e)
        
    def resolve(self, network):
        """If name is not resolvable, prompt and add to /etc/hosts.
        """
        print
        print "---- Resolving %s IP addresses ----" % network
        print
        hosts = self.hosts[network]
        for host in range(len(hosts)):
            if hosts[host][1]:
                addr = hosts[host][1] # built-in default
            # 12502 - Display the appropriate default values for the ones that are common
            # prv_nat and prv_ep can share the ip - prv_nat = self.hosts['localprivate'][0][1]
            # dynamicrealm, prv_rsa and qanextest.com can share the ip - dynamicrealm = self.hosts['remoteprivate'][0][1]
            # 29332 -- Including the newly added entry 
            elif (hosts[host][0]=='qanextest.com' or hosts[host][0]=='prv_rsa'\
                  or hosts[host][0]=='qanextest.com.' \
                  or hosts[host][0]=='prv_ep'):
                addr = self.hosts[network][0][1]
            # staticrealm and pub_rsa can share the ip  
            # pub_nat and pub_ep can share the ip
            # 29332 -- Including the newly added entry
            elif (hosts[host][0]=='pub_rsa' or hosts[host][0]=='pub_ep' or hosts[host][0]=='pub_test.com'):
                addr = self.hosts[network][1][1]
            else:
                try:
                    addr = socket.gethostbyname(hosts[host][0])
                except socket.gaierror,e:
                    #14000
                    print "Exception: %s -  Error resolving address" % str(e)
                    addr = None
            addr = self.promptIP(hosts[host][0], addr)
            self.hosts[network][host][1] = addr

def MakeAlias(ip, dev):
    ostype = posix.uname()[0]
    if ostype == 'Linux':
        dev = 'eth%s' % dev
        add = 'sudo ip addr add %s/24 dev %s > /dev/null 2>&1' % (ip, dev)
    if ostype == 'SunOS':
        dev = 'e1000g%s' % dev
        add = 'sudo ifconfig %s addif %s/24 > /dev/null 2>&1' % (dev, ip)

    print "adding %s to %s device %s" % (ip, ostype, dev)
    os.system(add)

def EnableAll():
    "Enable all known Ethernet interfaces"
    ostype = posix.uname()[0]
    if ostype == 'Linux': return
    ipmap = gen.getIFAddrs()
    for eth in ipmap.keys():
        os.system('sudo ifconfig %s up' % eth)

class ipmTest(unittest.TestCase):
    def test1(self):
        ipm = IPManager()
        self.assert_(ipm.getNetwork('public1') == 'localpublic', 'public1 not on public network')

    def test2(self):
        ipm = IPManager()
        self.assert_(ipm.getNetwork('private1') == 'localprivate', 'public1 not on public network')

    def test3(self):
        ipm = IPManager()
        self.assert_(ipm.getNetwork('publica1') == '', 'publica1 is valid address')

if __name__ == '__main__':
    unittest.main()
