#!/usr/bin/env python
"""
Process CDRs and the CDR dictionary.
"""
#from   dlog import *
import pprint
import session
import string
from   time import *
from   types import *
import sys
import threading
import time
import unittest
import warnings
import msw
from   xml import sax
import logging

# If this ever changes, CDRDictionary will need to be updated
CDR_DICT = '/usr/local/nextone/bin/cdrdict.xml'

# This is only a backup for CDRReader - should come from iServer
# config
CDR_PATH = '/home/nextone/cdrs/'

iServerVersion = '3.1'

class CDRError(Exception):
    "General CDR exception"
    
class CDR(DictionaryType):
    """A single Call Detail Record.

    The CDR is stored in dictionary (or "map", to prevent confusion
    between the Python dictionary and a CDR dictionary) format.  The
    key names are a concatenation of the field number and field name
    because some fields have identical names (and different data
    types).
    """
    def __init__(self, cdict, line):
        """
        Constructor accepts a CDR dictionary and a single line taken
        from a CDR file. 

        First task is to build a convenient sequence of keys from the
        CDR dictionary, then decode each line and assign the value to
        the key.
        """
        self.log = logging.getLogger('nextestlog')
        self.cdrDict = cdict
        self.log.debug('CDR: text: \n%s' % line)
        if len(line) < 30:
            return None
        self._buildNameList()
        self._decode(line)

    def __repr__(self):
        "Format CDR for printing, sorted by field number."
        str = ''
        keys = self.keys()
        keys.sort()
        for key in keys:
            str += '%-38s : %s\n' % (key, self[key])
        return str

    def writeHTML(self, filename):
        "Write HTML representation of CDR to a file"
        f = open(filename, 'w')
        f.write('<html><head></head><body>%s</body></html>' % str(self))
        f.close
            
    def _buildNameList(self):
        """Build the list of keys for the CDR object.

        The key for each field is field number + field name.
        Necessary because Python dictionaries require unique key
        names.  CDR allows identical key names with different data
        types.

        A zero is prepended to field numbers for better sortability.
        """
        self.fieldNames = []
        for field in self.cdrDict:
            # prepend zero if less than 10
            if int(field['no']) < 10:
                fieldNum = '0' + field['no']
            else:
                fieldNum = field['no']
            fieldNum += '-'
            # build the new key
            if field.has_key('name'):
                key = fieldNum + field['name']
            else:
                key = fieldNum
            self.fieldNames.append(key)

    def _decode(self, line):
        """Parse the line, adding each field to the proper key.

        If the number of fields in the cdr is less than the
        dictionary size, a warning will be raised.  If its longer than
        the dictionary, the problem is more serious (?) and an
        exception is raised.
        """
        # 38681 - Sometimes, there is no semicolon at the end of the cdr. 
        # Because of this the value is processed with a carriage return.
        if line.endswith('\n'):
            line = line.strip('\n')

        values = line.split(';')
        for key, value in zip(self.fieldNames, values):
            self[key] = value
        # Check for problems.
        # If less fields in CDR than dictionary, issue warning
        # If more fields, error; we don't know what extra fields are
        us = len(self)
        them = len(self.cdrDict)
        message = 'CDR length %d, dictionary length %d' %  (us, them)
        if us < them:
            warnings.warn(message)
        elif us > them:
            raise CDRError(message)

class CDRTimeoutError(Exception):
    "The CDRReader timed out waiting for the expected number of CDRs"
    
class CDRReader(object):
    """Access CDR data on remote MSW.

    When instantiated with a session argument, the CDRReader object
    will connect to the session (assumed to be a shell connection to
    the MSW) and retrieve the CDR dictionary.

    When asked to capture, the reader will tail the CDT file for today
    and grab any new CDRs.  Use decode() to get a list of CDR objects.
    """
    def __init__(self, msw, timeout=30):
        """
        If the msw argument is a string, it will be treated as a file
        name.  This is for unit testing.  Otherwise it is assumed that
        the msw is a session.SSH object.

        msw -- MSW SSH session
        
        timeout -- time to wait if count is not reached

        TODO  replace hard-coded path with iserver config check
        """
        self.log = logging.getLogger('nextestlog')
        self.msw = msw
        self.timeout = timeout
        self.cdrList = []
        self.path = CDR_PATH
        self._buildCDRPath(self.path)
        self.cdict = CDRDictionary(msw)

    def abortCapture(self):
        "Something is wrong, client no longer cares"
        self.log.debug('CDRReader: aborting capture')
        self.msw.stopLong(reject=True)

    def decode(self):
        """
        Decode whatever CDRs were retrieved.

        Returns a list of CDR objects.  If no valid CDR lines were
        read, an empty list is returned."""
        for line in self.rawCdr.split('\n'):
            if len(line) != 0:
                c = CDR(self.cdict, line)
                if c: self.cdrList.append(c)
        return self.cdrList

    def decodeSingle(self, raw):
        return CDR(self.cdict, raw)

    def getCount(self):
        "Get the number of CDRs after calling decode()."
        return len(self.cdrList)
    
    def showLast(self):
        """
        Extract the most recent CDR and display it.
        """
        self.log.debug('CDRReader: getLast')
        self.rawCdr = self.msw.filter('tail -1 ' + self.path)
        self.decode()
        print self.cdrList[0]
        
    def startCapture(self):
        self.log.debug('CDRReader: start: %s at %s' %
             (self.path, asctime(gmtime())))
        self.msw.runLong('tail -0f ' + self.path)
        
    def stopCapture(self):
        self.rawCdr = self.msw.stopLong()
        self.log.debug(['CDRReader: captured: ', self.rawCdr])
        return self.rawCdr

    def _buildCDRPath(self, path):
		"""CDR path depends on the format used in server.cfg file
		so it might not be what we adjust below"""
		"""file = 'D%s.CDT' % strftime('%Y%m%d', gmtime())"""
		file = 'DATA.CDR'
		self.path = path + file

    def _getLastCDRNum(self):
        raw = self.msw.filter('tail -1 ' + self.path)
        cdr = self.decodeSingle(raw)
        self.lastCDR = int(cdr['22-cdr-seq-no'])
        self.log.debug('CDRReader: last CDR is %d' % self.lastCDR)

class CDRParser(object):
    """CDRParser will build a list of CDR objects from a raw cdr file pased in.

       Note that this method employs the MSWInfo resource, (which was placed 
       into the context when it was initialized). MSWInfo has a pre-built CDR
       Dictionary.
    """
    def __init__(self, context, cdrfile):
        """
        TODO  replace hard-coded path with iserver config check
        """
        global iServerVersion

        self.log = logging.getLogger('nextestlog')
        self.cdrfile = cdrfile
        self.cdrList = []
        # Get the CDR Dictionary from MSWInfo in context
        if (context.has_key('mswinfo')) and (context.get('mswinfo') != None):
            m=context['mswinfo']
        elif context.has_key('bkupinfo') and (context.get('bkupinfo') != None):
            m=context['bkupinfo']
        self.cdrdict = m.cdrdict
        iServerVersion = m.iVersion 

    def decode(self):
        """
        Decode CDRs contained in the cdrfile parameter.

        Returns a list of CDR objects.  If no valid CDR lines were
        read, an empty list is returned.
        """
        f = open(self.cdrfile, 'r')
        linelist = f.readlines()
        f.close()
        for line in linelist:
            if len(line) != 0:
                c = CDR(self.cdrdict, line)
                if c: self.cdrList.append(c)
        return self.cdrList

class CDRDictionary(ListType):
    """
    A dictionary of CDR fields.

    The key for each entry is the field number.  The value is a
    dictionary containing the field's properties.  Some fields have no
    properties because they are obsolete.

    Note that dictionaries can NOT be accessed sequentially!  That's
    why the key is the field number.  Another option was to build a
    list (which IS strictly ordered) but then the parser would have to
    check field numbers, yadda yadda.

    The constructor accepts either an active MSW SSH session or an XML
    string.  If a session is provided, this class will contact the MSW
    and retrieve the XML dictionary.  In either case, the XML is
    fed to the SAX parser to create the final dictionary.
    """
    def __init__(self, msw):
        """Create the CDR dictionary from whatever is passed in.

        The msw argument can either be an open MSW session or a file
        name.  The latter is used for unit testing.
        """
        self.log = logging.getLogger('nextestlog')
        if type(msw) is StringType:
            f = open(msw, 'r')
            lineList = f.readlines()
            f.close()
            self.rawXml = string.join(lineList)
        else:
            # TODO type check
            self.msw = msw
            self._getCDRDict()
        self._processDict()

    def _getCDRDict(self):
        self.log.debug('CDRDictionary: retrieving')
        cmd = 'cat ' + CDR_DICT
        self.rawXml = self.msw.filter(cmd)
        
    def _processDict(self):
        "Process the XML data and make the CDR object list."
        self.log.debug('CDRDictionary: parsing')
        parser = sax.make_parser()
        handler = CDRHandler()
        sax.parseString(self.rawXml, handler)
        # Make ourselves into the list that was created by the handler.
        # Note that we can't just say "self = handler.list" because
        # the handler is destroyed by the parser when finished.
        for i in handler.list:
            self.append(i)
        count = 'CDRDictionary: %s items' % len(self)
        self.log.debug(count)

class CDRHandler(sax.ContentHandler):
    """XML SAX handler for use with the CDRDictionary parser.

    The result is a list of dictionaries, each containing the
    attributes for a field.  The list order is the same as that of the
    file, which is not guaranteed to be right.   Callers should
    reference the 'no' attribute if in doubt.
    """
    def __init__(self):
        "Create the handler's attributes"
        self.log = logging.getLogger('nextestlog')
        self.inputIsCDRDict = False
        self.value = ''
        self.list = []

    def startElement(self, name, attrs):
        """
        Convert SAX Attributes objects for each <field> tag into
        simple dictionaries. 

        The conversion is done so that callers are not dependent on
        SAX 'Attributes' objects, which support the Python dictionary
        interface but have a class of their own.
        
        Field tags in the XML CDR dictionary contain 1 or more
        attributes: they have a number attribute but they may not have
        name and format attributes.  This handler loads up a list in
        the order that elements are stored in the XML dictionary -
        this is usually in the correct sequential order but the field
        number is stored with the other attributes so that callers can
        verify. 
        """
        if name == 'CDR':
            self.log.debug('SAX CDRHandler: found CDR dictionary')
            self.inputIsCDRDict = True
            return
        if name != 'field':
            raise xmlcommon.UnknownTagError(name)
        
        # copy the attrs object into a dictionary.  req'd for two
        # reasons: first, the attrs object is not a straight Python
        # dictionary - it is a SAX object.  second, the parser can and
        # will reuse the attrs object, so it must be copied in order
        # to be saved.
        f = {}
        f.update(attrs)
        self.list.append(f)
        
    def character(self, text):
        "Shouldn't see anything here - the file is all tags."
        m = 'worthless? ' + text
        self.log.debug(m)
        
class CdrAssertions:
    def __init__(self, test, clist):
        global iServerVersion

        if (test == None) or (clist == None):
            raise ValueError,"CdrTestAssertion: initialization error"

        self.clist = clist
	self.test = test
        self.iVersion = iServerVersion
    
    #PR183504 for Code mapping changes
    callErrorMap = {
                    '401 authorization required'        :'Unauthorized',
                    '403 forbidden'                     :'Forbidden',
                    '407 proxy authorization required'  :'Proxy Authentication Required',
                    '500 internal error'        :'Internal Error-Internal SBC Error',
                    '503 service unavailable'        :'Service Unavailable',
                    'Media 911 CAC channels exceeded'        :'Media CAC Emergency Channel Limit Exceeded',
                    'Media CAC channels exceeded'        :'Media CAC Channel Limit Exceeded',
                    'abandoned'        :'Request Terminated-Call Abandoned',
                    'ani-dnis-loop'        :'Loop Detected-ANI DNIS Loop Detected',
                    'busy'        :'Busy Here',
                    'dest-gone'        :'Gone-Destination No Longer Registered',
                    'dest-relcomp'        :'Internal Error-Destination Release Complete',
                    'dest-timeout'        :'Service Unavailable-Destination Timeout',
                    'dest-unreach'        :'Temporarily Unavailable-Destination Unreachable',
                    'disconnect-unreach'        :'Temporarily Unavailable-Release Complete Dest Unreachable',
                    'gw-resource-unavailable'        :'Service Unavailable-Media Gateway Resource Unavailable',
                    'h323-maxcalls'        :'Service Unavailable-H323 Max Calls Exceeded',
                    'incomp-addr'        :'Address Incomplete',
                    'invalid-chars-in-dnis'        :'Bad Request-Invalid DNIS Characters Received',
                    'local-disconnect'        :'Service Unavailable-Local Disconnect',
                    'max-call-duration'        :'Internal Error-Max Call Duration Exceeded ',
                    'no-bandwidth'        :'Service Unavailable-No Bandwidth Available',
                    'no-call-handle'        :'Dialog/Transaction Does Not Exist',
                    'no-media-bandwidth'        :'Service Unavailable-No Media Bandwidth Available',
                    'no-nat-t-license'        :'Internal Error-NAT Traversal License Required',
                    'no-ports'        :'Service Unavailable-No Ports Available',
                    'no-route'        :'Not Found-No Route Found',
                    'no-route-at-dest'        :'Not Found-No Route At Destination',
                    'no-vports'        :'Service Unavailable-No Vports Available',
                    'pre-max-call-duration'        :'Request timed out',
                    'resource-unavailable'        :'Temporarily Unavailable-Resource Unavailable',
                    'sdp-not-supported'        :'Unsupported Media Type',
                    'shutdown'        :'Internal Error-SBC Shutdown',
                    'temporarily-unavailable'        :'Temporarily Unavailable',
                    'undefined'        :'Internal Error',
                    'user-blocked'        :'Forbidden-User Blocked',
		    'src-not-found'        :'Forbidden-Source Endpoint Lookup Failed',
                    'user-blocked-at-dest'        :'Forbidden-User Blocked At Destination',
		    'call-gapping-limit-exceeded' :'Internal Error-Call Gapping Limit Exceeded'
                }

    def assertCount(self, callNum):
        self.test.assertEquals(len(self.clist), callNum, \
                        'Expected %s, got %s CDRs' %(callNum, len(self.clist)))\

    def assertFields(self, callNum, **fields):
        try:
            call = self.clist[callNum-1]
        except:
            #call is not present
            self.test.assert_(False,'No CDR for call %s' %  (callNum))

        for key in fields.keys():
            #PR183504 for Code mapping changes
            if (self.iVersion >= '8.1') and (key == 'callError' or key == 'destCallError'):
                try:
                    keylist = (str(fields[key])[1:-1]).strip().split(',')
                    keyValue2 = ''                
                    for i in keylist:
                         keyValue1 =  self.callErrorMap.get((i.strip())[1:-1])
                         if (keyValue1 != None) and (keyValue1 != ''):
                             keyValue2= keyValue2 + ',' + keyValue1
                         else:
                             keyValue2= keyValue2 + ',' + (i.strip())[1:-1]
                         
                    if (keyValue2 != None) and (keyValue2 != ''):
                       keyValue = keyValue2[1:]
                    else:
                       keyValue = fields[key] 
                except KeyError:
                    keyValue = fields[key]
            else:
                keyValue = fields[key]
            getattr(self,key,self.__defaultFieldAssert)(callNum, key, keyValue) 

    def isdnCauseCode(self, callNum, fieldName, fieldValues):
        call = self.clist[callNum-1]
        if self.iVersion >= '4.0':
            actual = call['60-original-isdn-cause-code']
        else:
            actual = call['30-isdn-cause-code']
        self.test.assert_((actual in fieldValues) and (actual != None),\
            'Call %s error: %s got (%s), expected (%s)' % (callNum, fieldName, actual, fieldValues))
        
    def __defaultFieldAssert(self, callNum, fieldName, fieldValues):
        mappedKeys = {
            'dnisOnDest'        :'09-called-party-on-dest',
            #36318 - Added CDR field number 10
            'dnisOnSrc'         :'10-called-party-from-src',
            'callType'          :'11-call-type',
            'callError'         :'15-call-error',
            'discError'         :'13-disconnect-error-type',
            'srcRegId'          :'26-call-source-regid',
            'destRegId'         :'28-call-dest-regid',
            'isdnSrcCauseCode'  :'30-isdn-cause-code',
            # 30306 Corrected the name of field number 60
            'isdnDestCauseCode' :'60-original-isdn-cause-code',
            'aniOnDest'         :'35-new-ani',
            'cdrType'           :'39-cdr-type',
            'sipSrcRespCode'    :'75-sip-src-respcode',
            'destCrName'        :'55-call-dest-crname',
            'sipDestRespCode'   :'45-sip-dest-respcode',
            'destuport'         :'29-call-dest-uport', 
            'ani'               :'18-ani',
            'callErrorNum'      :'14-call-error',
            'srcuport'          :'27-call-source-uport',
            'callerTG'          :'41-caller-trunk-group',
            'destTG'            :'46-dest-trunk-group',
            # 30618 Added field number 51, 52, 58 and 59
            'calledPartyDestType' :'51-called-party-on-dest-num-type',
            'callingPartyDestType':'58-calling-party-on-dest-num-type',
            'calledPartySrcType'  :'52-called-party-from-src-num-type',
            'callingPartySrcType' :'59-calling-party-from-src-num-type',
            #30983 - Added for performing the CDR verification on 
            # field numbers 77 and 78
            'srcPrivateIp'      :'77-src-private-ip',
            'destPrivateIp'     :'78-dest-private-ip',
            #36909 - Added for verifying CDR field numbers 53 and 54
            # 36319 - Added src,dest ip addresses and src,dest realms
            'srcRealmName'      :'53-call-source-realm-name',
            'dstRealmName'      :'54-call-dest-realm-name',
            'srcIP'             :'04-call-source',
            'dstIP'             :'06-call-dest',
            'mswName'           :'49-msw-name',
            #37410
            'calledPartyAfterTransit': '50-called-party-after-transit-route',
            # 38681 - Add hunt fields
            'huntAttempt'       :'40-hunting-attempts',
            'huntAttIncLCFTries':'87-hunt-attempts-including-LCF-tries',
            # 39027
            'callDuration'      :'03-call-duration',
            'callDurationSec'   :'36-call-duration', 
            # 39291
            'callZoneData'      :'57-call-zone-data', 
            'calledPartyAfterSrcCallingPlan': '31-called-party-after-src-calling-plan',
            #40327
            'calledPartyOnDest':'09-called-party-on-dest',
            #39546:
            'protocol'          :'38-protocol',
            'huntingAttempts'  :'40-hunting-attempts',
            'peerProtocol'     :'76-peer-protocol',
            # 38970 
            'srcIgrp'    :'79-src-igrp-name',
            'dstIgrp'    :'80-dest-igrp-name',
            # 48354: added field for sip-sesion-timer feature
            'destCallError'    :'33-call-error-dest',
            # 156875: Added fields 106 and 107 for cdr-start-stop-time feature
            # 156887: Change the field 106 from call-start-stop-ms to call-connect-time-ms
            'callConnectTime'     :'106-call-connect-time-ms',
            'callEndTime'       :'107-call-end-time-ms',
            #179651: SIP local refer, cdr field
            'localReferStatus'       :'117-local-refer-status',
            # Interim cdr fields   
            'callDurationFractional' :'47-call-duration-fractional',
            'segStartTime'           :'123-segment-start-time-ms', 
            'segDurationFractional'  :'124-segment-duration-fractional',
            'cdrSeq' :'22-cdr-seq-no',
            'codecSrc':'65-codec-on-src-leg',
            'codecDst':'72-codec-on-dest-leg',
            'rfactorSrc':'67-rfactor-on-src-leg',
            'rfactorDst':'74-rfactor-on-dest-leg',
	    'sipSrcRespreason' :'119-sip-src-respreason',
	    #sipi_peerless PR 189201
	    'chargeNumber' :'120-charge-number',
	    'chargeNumNoa' :'121-charge-number-noa',
	    'chargeNumNpi' :'122-charge-number-npi'
            }

        call = self.clist[callNum-1]

        try: 
            mappedKey = mappedKeys[fieldName]
            actual = call[mappedKey]
        except KeyError:
            print call

            self.test.assert_(False, 'field (%s) is not supported. It must be in %s' % \
                            (fieldName, mappedKeys.keys()))

        self.test.assert_((actual in fieldValues) and (actual != None),\
            'Call %s error: %s got (%s), expected (%s)' % (callNum, fieldName, actual, fieldValues))


    def is_time_format_match(self,time_cdr_value):
        ''' This function has been added to check if the cdr value(time) is of the format 
        "YYYY-MM-DD HH:MM:SS.sss"
        '''
        if len(time_cdr_value.split('.')[1]) == 3:
            val_millisecond=True
        else:
            val_millisecond=False


        try:
            time.strptime(time_cdr_value.split('.')[0],'%Y-%m-%d %H:%M:%S')
        except:
            val_format=False
        else:
            val_format=True

        if ((val_millisecond==True)and(val_format==True)):
           return True
        else:
           return False


          

class utCdrTestAssertion(unittest.TestCase):

    def setUp(self):
        clist = [{'11-call-type':'IV', \
	              '13-disconnect-error-type':'E', \
		      '15-call-error':'dest-unreach',\
		      '39-cdr-type':'end1',
	              '26-call-source-regid':'cr_IPPhone1',
	              '28-call-dest-regid':'cr_IPPhone2',
	              '09-called-party-on-dest':'1234',
                      '45-sip-dest-respcode':'exceptional field'
		      },\
	             {'11-call-type':'IV', \
	              '13-disconnect-error-type':'N', \
		      '15-call-error':'',\
		      '39-cdr-type':'end1',\
	              '26-call-source-regid':'cr_IPPhone1',
	              '28-call-dest-regid':'cr_IPPhone2',
	              '09-called-party-on-dest':'1234',
		      },\
	             {'11-call-type':'IV', \
	              '13-disconnect-error-type':'N', \
		      '15-call-error':'',\
		      '39-cdr-type':'end1',
	              '26-call-source-regid':'cr_IPPhone1',
	              '28-call-dest-regid':'cr_IPPhone2',
	              '09-called-party-on-dest':'1234',
		      },\
		      ]

        self.a = CdrAssertions(self, clist)

    def test1(self):
        self.a.assertFields(1, 
                        callType=['IV'],
                        cdrType=['end1'],
                        callError=['dest-unreach'],
                        discError=['E'])
        self.a.assertFields(2, 
                        callType=['IV'],
                        cdrType=['end1'],
                        callError=[''],
                        discError=['N'])
        self.a.assertFields(3, 
                        callType=['IV'],
                        cdrType=['end1'],
                        callError=[''],
                        discError=['N'])

    def test3(self):
        self.a.assertFields(1,
                        callType=['IV'],
                        cdrType=['end1'],
                        callError=['no-ports','dest-unreach'],
                        discError=['E'])

    def test5(self):
        self.a.assertFields(1, 
                        callType=['IV'],
                        cdrType=['end1'],
			discError=['E'],
			callError=['no-ports','dest-unreach'],
		        srcRegId=['cr_IPPhone1'],
		        destRegId=['cr_IPPhone2'],
		        dnisOnDest=['1234'],
			)
    def test6(self):
        self.a.assertFields(1,
                        callType=['IV'],
                        cdrType=['end1'],
			discError=['E'],
			callError=['no-ports','dest-unreach'],
		        srcRegId=['cr_IPPhone1'],
		        destRegId=['cr_IPPhone2'],
		        dnisOnDest=['1234']
			)
    def test7(self):
        #self.a.assertFields(1, callType=['IV'], cdrType=['end1'], sipDestRespCode=['abcd'],)
        print self.a.is_time_format_match('2012-12-11 03:24:34.478')

if __name__ == '__main__':
    unittest.main()


########################################################################
# Local Variables:
# mode: python
# indent-tabs-mode: nil
# fill-column: 72
# auto-fill-function: do-auto-fill
# End:
