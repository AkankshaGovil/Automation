#!/usr/bin/python
"""
  gatekeeper classes
  currently only implements gnuGatekeeper
"""

import logging
import socket
import pexpect
import unittest
from time import sleep
import os

class GatekeeperError(Exception):
    "General Gatekeeper exception"

class gnuGk(object):
  """
    Gnu Gatekeeper class
    only attribute is ip address / hostname
  """
  status_control = 0       # keeps track of the status of control session
  status_gk      = 0       # keeps track of the status of gk 
                           # 0 not started, 1 started
  configured     = 1       # defines if the msw is configured on the Master GK

  def __init__(self, gatekeeper, switch='pub_rsa'):
    """
      constructor of the Gatekeeper class, call with gatekeeper set to hostname or ip-address of
      the gatekeeper server and switch set to hostname or ip-address of the msw (normally pub_rsa)
    """
       
    self.status_control = 0
    self.status_gk      = 0  
    self.configured     = 1  # defines if the msw is configured on the Master GK
    self.remotegwid     = ""
    self.remotegwprefix = ""
    self.name           = gatekeeper
    # 36319 - Introduce a new variable to hold the check HVAL value
    self.checkHVal = False

    self.log = logging.getLogger('nextestlog')

    try:
      self.ipaddr = socket.gethostbyname(gatekeeper)
    except socket.gaierror, exc:
      errnum, errstr = exc
      self.log.error("GnuGatekeeper: Cannot Resolve IP address")
      raise GatekeeperError('Error retrieving address for %s' % gatekeeper)

    try:
      self.msw = socket.gethostbyname(switch)
    except socket.gaierror, exc:
      errnum, errstr = exc
      self.log.error("GnuGatekeeper: Cannot Resolve IP address")
      raise GatekeeperError('Error retrieving address for %s' % switch)

  def __del__(self):
    if (self.status_control + self.status_gk):
      self.stop()

  def configure(self,properties):
    if 'remotegwid' in properties.keys():
        self.remotegwid = properties['remotegwid'] 
    if 'remotegwprefix' in properties.keys():
        self.remotegwprefix = properties['remotegwprefix']
 
  def _generateConfiguration (self):
    self.conffile = "/tmp/" + self.name + ".ini"
    cf = file(self.conffile , 'w')

    cf.writelines ( [ '[Gatekeeper::Main]\n', 
                      'Fourtytwo=42\n',
                      'Name=%s\n' % (self.name),
                      'Home=%s\n\n' % (self.ipaddr),
                      'TotalBandwidth=100000\n',  
                      'StatusPort=7000\n',
                      'UseBroadcastListener=0\n\n',
                      '[GkStatus::Auth]\n',
                      'rule=allow\n\n',
                      '[RoutedMode]\n',
                      'GKRouted=1\n',
                      'AcceptNeighborCalls=1\n',
                      'AcceptUnregisteredCalls=1\n\n',
                      '[RasSrv::Neighbors]\n',
                      ('GK2=%s:1719;*\n\n' % (self.msw) ),
                      'AcceptPrefixes=*\n',
                      '[RasSrv::LRQFeatures]\n',
                      'ForwardHopCount=2\n',
                      'AlwaysForwardLRQ=1\n',
                      'AcceptForwardedLRQ=1\n',
                      'IncludeDestinationInfoInLCF=0\n\n'
                         ])

    if not self.configured :
      cf.writelines ( [ '[Gatekeeper::Auth]\n',
                      'AliasAuth=required;RRQ,LRQ,Setup\n\n' ] )

    if self.remotegwid :
      tmp1 = self.remotegwid + '=' + self.remotegwprefix + '\n\n' 
      cf.writelines ( [ '[RasSrv::GWPrefixes]\n',
                      tmp1 ])

    cf.close()

  # 36319 - Added a new default parameter to handle the case when the
  # configuration file needs to contain non-default value
  def start(self,genConf=True):
    """
      starts the gnuGatekeeper server and opens a control session to port 7000
    """

    # 36319 - Generate the conf file only if its required
    if genConf: 
      self._generateConfiguration()

    #cmd = "/usr/sbin/gnugk"
    cmd = "gnugk"
    cfgOption = "-c " + self.conffile  
    cmdLine = "%s %s" % (cmd, cfgOption)

    self.log.info("GnuGatekeeper: Starting gnu Gatekeeper with command %s" % (cmdLine) )
    self.gk = pexpect.spawn(cmdLine)
    sleep(1)
    if not self.gk.isalive():
      self.log.error("GnuGatekeeper: Failed to start Gatekeeper")
      self.status_gk = 0
    else:
      self.status_gk = 1

    self.log.info("GnuGatekeeper: Starting Control session on ip %s  port 7000" % (self.ipaddr) )
    self.control = pexpect.spawn("telnet %s 7000" % (self.ipaddr) )
    sleep(1)
    if not self.control.isalive():
      self.log.error("GnuGatekeeper: Failed to start Control Session - May be due to TCP TIME_WAIT problem")
      sleep(60)
      self.control = pexpect.spawn("telnet %s 7000" % (self.ipaddr) )
      if not self.control.isalive(): 
          self.log.error("GnuGatekeeper: Failed to start Control Session")
          self.status_control = 0
    else:
      self.status_control = 1

    self.control.expect(";")
    self.log.info("GnuGatekeeper: Gatekeeper started")

    # 36319 - Set the value to True since the call involves a GK and hence it involves H323 
    self.checkHVal = True

  def stop(self):
    """
      stops the control session and gnuGatekeeper server
    """

    self.control.sendline('exit')
    sleep(2)
    if self.control.isalive():
      self.log.error("GnuGatekeeper: Failed to stop Control Session - May be due to TCP TIME_WAIT problem")
      sleep(30)
      if  self.control.isalive():
          self.log.error("GnuGatekeeper: Failed to stop Control Session")
          self.status_control = 1 
    #else:
      if not self.control.isalive():
          self.status_control = 0
          self.control.close()
          self.log.info("GnuGatekeeper: Control Session stopped")

    self.gk.kill(15)
    sleep(2)
    if self.gk.isalive():
      self.status_control = 1
      self.log.error("GnuGatekeeper: Failed to stop Gatekeeper")
    else:  
      self.status_control = 0
      self.gk.close()
      self.log.info("GnuGatekeeper: Gatekeeper stopped")

  def status(self):
    """
      sorry currently not implemented
    """
    pass

  
  def waitForMessage(self, message):
    """
      waits for a specified message to be printed in the control session.
      Actually the confirm message get printed but the gk doesn't send anything without receiving a request
    """
    abr = {'GatekeeperConfirm'  : 'GCF', 'GatekeeperReject'  : 'GRJ', 
           'RegistrationConfirm': 'RCF', 'RegistrationReject': 'RRJ',
           'ResourcesAvailable' : 'RAC',
           'LocationConfirm'    : 'LCF', 'LocationReject'    : 'LRJ',
           'RegistrationRequest': 'RRQ' }

    self.log.info("GnuGatekeeper: Waiting for Message %s(%s)" % (message, abr[message]) )
    index = self.control.expect([abr[message], pexpect.TIMEOUT, pexpect.EOF], 65)
    if index==0:
      self.log.info("GnuGatekeeper: %s Received" % message)
      return True
    elif index==1:
      self.log.error("GnuGatekeeper: Timeout received instead of %s" % message )
    elif index==2:
      self.log.error("GnuGatekeeper: EOF received instead of %s" % message )

    return False

class GatekeeperTest(unittest.TestCase):
    """
    Unittest class for testing the Gatekeeper.
    """

    def test1(self):
      gk = gnuGk('172.16.1.84', 'pub_rsa')
      gk.start()

      gcf = gk.waitForMessage('GatekeeperConfirm')
      print "GCF =", gcf

      rcf = gk.waitForMessage('RegistrationConfirm')
      print "RCF =", rcf

      rac = gk.waitForMessage('ResourcesAvailable')
      print "RAC =", rac

      raw_input("Please hit enter")
      gk.stop()

      self.assertEquals( gcf, True, "Waiting for GRQ failed")
      self.assertEquals( rcf, True, "Waiting for GRQ failed")
      self.assertEquals( rac, True, "Waiting for GRQ failed")

if __name__ == '__main__':
    unittest.main()

