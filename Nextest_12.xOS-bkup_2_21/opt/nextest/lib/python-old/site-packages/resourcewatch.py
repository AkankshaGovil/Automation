import logging
import os
import os.path
import pexpect
import string
import tempfile
import unittest
import msw
from  qm.test.result import Result

class MswResourceError(Exception):
    "Base class for exceptions raised during MSW Resource snapshot"

    def __init__(self, errMessage):
        self.msg = errMessage

        
class MswResource(object):
    """
    Abstract class for taking resource snapshot at MSW.    

    """
    def __init__(self, path=None):
        self.mswpath = path
        
        # Connect to logging started earlier
        self.log = logging.getLogger('nextestlog')


    def getSnapshot(self):
        """
        Get snapshot of a resource on MSW.
        
        This method is dummy. This method is defined in the derived
        classes.
        
        """
        raise NotImplementedError


    def _fetchfile(self, mymsw, remotepath, localpath):
        """
        Fetch the data file from remote MSW to a local file.

        """
        remoteaccess = "root@%s:%s" % (mymsw.ipaddr, remotepath)
        command      = "scp -q  %s %s" % (remoteaccess, localpath)
            
        os.system(command)

        if not os.path.isfile(localpath):
            message = "MswResource: failed to fetch file to %s" % localpath
            self.log.error(message)
        else:
            message = "MswResource: copied %s to %s" % (remoteaccess,localpath)
            self.log.info(message)            


class VportsResource(MswResource):
    """
    Responsible for collecting Vports data at MSW.
    """
    def __init__(self, path=None):
        
        # Call base class init
        MswResource.__init__(self, path)

        # Create vports dictionary
        self.vport = { }

        self.vport['avlbl vports']       = None
        self.vport['used vports']        = None
        self.vport['media avlbl vports'] = None
        self.vport['media used vports']  = None

        
    def vportsfileParser(self, vportfile):
        """
    	Parse the vports data file.

        The method parses the vports data file to collect specific
        resource details such as vports and media vports.
        """
        # Read the contents of the file to a list
        filehandle = open(vportfile, 'r')
        datalist   = filehandle.readlines()
        filehandle.close()
        
        # Get the vports dictionary from the list
        for dataline in datalist:
            line = dataline.replace('\n','')

            # Add contents to the dictionary                
            if (line.find('VPORTS') == -1):
                continue
            elif (line.find('Available VPORTS') != -1):
                self.vport['avlbl vports']  = line[line.rfind("\t")+1:]
            elif (line.find('Used VPORTS') != -1):
                self.vport['used vports']   = line[line.rfind("\t")+1:]
            elif (line.find('Available Media') != -1):
                self.vport['media avlbl vports'] = line[line.rfind("\t")+1:]
            elif (line.find('Used Media') != -1):
                self.vport['media used vports']  = line[line.rfind("\t")+1:]


    def getSnapshot(self, mymsw):
        """
        Get the snapshot of vport resource at 'mymsw'.
        
        The method records the snapshot of vports at the MSW.
        Then, gets the recorded data file to the local machine.
        It parses the data file to produce the data dictionary
        for vports resource.
        """
        # Send the command to record vports data
        vportfile  = 'vportsData.txt'
        remotepath = self.mswpath + vportfile

        # using tempfile module to create local tempfile
        tempname   = tempfile.mkstemp('.txt')
        localpath  = tempname[1]
        
        mymsw.ssh.sendline('cli lstat > %s' % remotepath)
        
        # Fetch the file to local machine
        self._fetchfile(mymsw, remotepath, localpath)
        
        # Parse the file and get data dictionary
        self.vportsfileParser(localpath)
        
        # Delete the local file
        command = "rm -f %s" % localpath
        os.system(command)
        
        # Delete the remote file
        mymsw.ssh.sendline('rm -f %s' % remotepath)

        # Return the dictionary to the caller
        vport = { }
        for key in self.vport.keys():
            vport[key] = self.vport[key]
        
        return vport


class CallcacheResource(MswResource):
    """
    Responsible for collecting Callcache data at MSW.
    """
    def __init__(self, path=None):
        
        # Call base class init
        MswResource.__init__(self, path)

        # Create callcache dictionary
        self.callcache = { }

        self.callcache['active calls'] = None
        self.callcache['call legs']    = None

        
    def callcachefileParser(self, cachefile):
        """
    	Parse the callcache data file.

        The method parses the callcache data file to collect specific
        resource details such as active calls and call legs.
        """

        # Read the contents of the file to a list
        filehandle = open(cachefile, 'r')
        cachelist  = filehandle.readlines()
        filehandle.close()
        
        # Get the callcache dictionary from the list
        for cacheline in cachelist:
            line = cacheline.replace('\n','')

            # Add contents to the dictionary                
            if (line.find('Calls') == -1) or (line.find('Legs') == -1):
                continue

            self.callcache['active calls'] = line[:line.find(" ")]
            self.callcache['call legs']=line[line.find(", ")+2:line.rfind(" ")]


    def getSnapshot(self, mymsw):
        """
        Get the snapshot of call resource at 'mymsw'
        
        The method records the snapshot of callcache at the MSW.
        Then, gets the recorded data file to the local machine.
        It parses the data file to produce the data dictionary
        for callcache resource.
        """
        # Send the command to record callcache data
        cCachefile  = 'callcacheData.txt'
        remotepath  = self.mswpath + cCachefile
        
        # using tempfile module to create local tempfile
        tempname   = tempfile.mkstemp('.txt')
        localpath  = tempname[1]
        
        mymsw.ssh.sendline('cli call cache %s' % remotepath)
        
        # Fetch the file to local machine
        self._fetchfile(mymsw, remotepath, localpath)
        
        # Parse the file and get data dictionary
        self.callcachefileParser(localpath)
        
        # Delete the local file
        command = "rm -f %s" % localpath
        os.system(command)
        
        # Delete the remote file
        mymsw.ssh.sendline('rm -f %s' % remotepath)

        # Return the dictionary to the caller
        callcache = { }
        for key in self.callcache.keys():
            callcache[key] = self.callcache[key]
            
        return callcache


class ResourceLeakDetector(object):

    def __init__(self):
        """
        Create resource list for watching.
        Create null lists for holding the snapshot data at
        a later point of time.
        """
        # Connect to primary MSW
        self.primaryMsw = msw.MSWInfo('mymsw')

        # bkup MSW might be there or may not be there!!
        try:
            self.backupMsw  = msw.MSWInfo('bkupmsw')
        except:
            self.bkupexists = False
        else:
            self.bkupexists = True

        # Connect to logging started earlier
        self.log = logging.getLogger('nextestlog')

        # Create instances of all resouces and put them in resourceList
        self.resourceList = []
        self.resourceList.append(VportsResource('/tmp/'))
        self.resourceList.append(CallcacheResource('/usr/local/nextone/bin/'))
        
        # Information log
        self.log.info("ResourceWatch: Resource list created")

        # Create a null preconditionList
        self.precampaignList = []
        
        # Create a null postconditionList
        self.postcampaignList = []

        # Create null lists for bkup MSW
        if self.bkupexists:
            self.bkupPrecampaignList  =[]
            self.bkupPostcampaignList =[]


    def precondition(self):
        """
        Collect resource snapshots before the test campaign

        The method collects snapshots of all the resources in
        the resource list. Corresponding getSnapshot method
        from the resource class is called to do the job.
        """
        if self.precampaignList != []:
            return

        # Get pre campaign snapshots
        for resource in self.resourceList:
            self.precampaignList.append(resource.getSnapshot(self.primaryMsw))

            if self.bkupexists:
                self.bkupPrecampaignList.append(resource.getSnapshot(self.backupMsw))
            
        # Debug log
        self.log.debug("ResourceWatch: preCampaign snapshot taken")


    def _formResultDictionary(self, predict, postdict):
        """
        Forms result dictionary to be used in annotation updation
        """
        result = { }

        # get all the keys in the input dictionary
        keylist = predict.keys()

        # form the the result dictionary from the inputs
        for key in keylist:
            result[key] = "pre value: %s post value: %s" % (predict[key],
                                                            postdict[key])

        # return the formed result dictionary
        return result


    def postcondition(self, res_streams):

        if self.postcampaignList != []:
            return

        # Get post campaign snapshots
        for resource in self.resourceList:
            self.postcampaignList.append(resource.getSnapshot(self.primaryMsw))

            if self.bkupexists:
                self.bkupPostcampaignList.append(resource.getSnapshot(self.backupMsw))

        # Debug log
        self.log.debug("ResourceWatch: postCampaign snapshot taken")

        # Create result object to write result
        resrcResult = Result(Result.TEST,"MSW Resource Watch")

        for i in range(len(self.precampaignList)):

            #dictionaries can be directly compared.
            if self.precampaignList[i] != self.postcampaignList[i]:

                # resource leakage, just print the pre and post elements
                resrcResult.SetOutcome(Result.ERROR,"Resource leak happened")

                logResult =self._formResultDictionary(self.precampaignList[i],
                                                      self.postcampaignList[i])
                resrcResult.Annotate(logResult)

                # write to debug log
                self.log.error("MSW RESOURCE WATCH: Resource leak occured")

                for key in logResult.keys():
                    self.log.error("%s :: %s" % (key, logResult[key]))
                
        # write to the result streams
        for rstream in res_streams:
            rstream.WriteResult(resrcResult)

        # Do the resource check on backup MSW
        if self.bkupexists:

            # Create result object to write result
            bkupResult = Result(Result.TEST,"BKUP MSW Resource Watch")

            for i in range(len(self.bkupPrecampaignList)):

                #dictionaries can be directly compared.
                if self.bkupPrecampaignList[i] != self.bkupPostcampaignList[i]:

                    # resource leakage, print the pre and post elements
                    bkupResult.SetOutcome(Result.ERROR,"Resourceleak happened")

                    logResult =self._formResultDictionary(self.bkupPrecampaignList[i], self.bkupPostcampaignList[i])
                    resrcResult.Annotate(logResult)

                    # write to debug log
                    self.log.error("BKUP MSW RESOURCE WATCH: leakage occured")

                    for key in logResult.keys():
                        self.log.error("%s :: %s" % (key, logResult[key]))

            # write to the result streams
            for rstream in res_streams:
                rstream.WriteResult(bkupResult)


########################################################################
# Unit tests
########################################################################

class ResourceTest(unittest.TestCase):
    """
    Unittest class for testing the main parts of resourcewatch.py code.
    """

    def testVports(self):
        """
        testVports tests the snapshot capability of VportsResource
        and the result format of the 'cli lstat' command
        """
        myserver = msw.MSWInfo('mymsw')
        # instantiate the class
        vportObject = VportsResource('/tmp/')

        # get vport snapshot
        vportDict = vportObject.getSnapshot(ResourceTest.myserver)

        # Assertions
        self.assertNotEqual(vportDict['avlbl vports'], None)
        self.assertNotEqual(vportDict['used vports'], None)
        self.assertNotEqual(vportDict['media avlbl vports'], None)
        self.assertNotEqual(vportDict['media used vports'], None)


    def testCallCache(self):
        """
        testCallCache tests the snapshot capability of CallcacheResource
        and the result format of the 'cli call cache' command
        """
        myserver = msw.MSWInfo('mymsw')
        # instantiate the class
        callObject  = CallcacheResource('/usr/local/nextone/bin/')

        # get call cache snapshot
        callDict = callObject.getSnapshot(ResourceTest.myserver)

        # Assertions
        self.assertNotEqual(callDict['active calls'], None)
        self.assertNotEqual(callDict['call legs'], None)


if __name__ == '__main__':
    unittest.main()


########################################################################
# Local Variables:
# mode: python
# indent-tabs-mode: nil
# fill-column: 78
# auto-fill-function: do-auto-fill
# End:
