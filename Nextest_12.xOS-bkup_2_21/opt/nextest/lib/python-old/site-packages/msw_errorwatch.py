import logging
import os
import os.path
import pexpect
import string
import tempfile
import unittest
import msw
from  qm.test.result import Result
from nxConfigInterface import *
from session import *

class MswErrorWatchError(Exception):
    "Base class for exceptions raised during MSW Error Watch"

    def __init__(self, errMessage):
        self.msg = errMessage

        
class MswErrorWatch(object):
    """
    Abstract class for watching error logs at MSW.    

    """
    def __init__(self, mymswinfo, logpath = '/var/log/iserver_error.log'):
        """
        When the class is instantiated,

        1. Store MSW info.
        2. Direct the errorlog to be stored at separate file.
        3. Clear the previous contents of the error log.
        4. Create previous and current empty error log files.
        5. Connect to nextest log.
        
        """
        # Store the msw error log path
        self.mswlogpath = logpath

        # Store msw information
        self.mymsw = m = mymswinfo

        # Connect to logging started earlier
        self.log = logging.getLogger('nextestlog')

        # Separate the error log file
        self.mswConf = MswConfig('mymsw')
        self.mswSession = SSH(['root@mymsw'])
        # 27718 Get the MSWConfig error log path information
        errPath = mymswinfo.errlogpath
        if errPath != self.mswlogpath:
            self.mswConf.setMSWConfig(self.mswSession,'sLogErrPath',\
                                      self.mswlogpath)


        # Clear the content of errorlog file at MSW
        mswcmd = "echo > %s" % self.mswlogpath
        m.ssh.sendline(mswcmd)

        try:
            m.ssh.expect(m.prompt, 5)
        except:
            self.log.error("MswErrorWatch: failed to execute MSW command")
            
        # using tempfile module to create log file
        tempname   = tempfile.mkstemp('.log')
        self.currErrlog = tempname[1]


    def _fetchfile(self):
        """
        Fetch the log file from MSW to a local file.
        """
        remotefile = "root@%s:%s" % (self.mymsw.ipaddr, self.mswlogpath)
        command    = "scp -q  %s %s" % (remotefile, self.currErrlog)

        try:
            os.system(command)
        except OSError:
            msg = "MswErrorWatch: failed to fetch file to %s" % self.currErrlog
            self.log.error(msg)
        else:
            msg = "MswErrorWatch:copied %s to %s" %(remotefile,self.currErrlog)
            self.log.info(msg)


    def __getErrorlog(self, logfile):
        """
        Get error log lines from the log file.
        """
        # Empty error log list
        errorlog = []

	# Get the file size
	Filesize = os.path.getsize(logfile)
	
	# Read the lines from the newfile to a list
        if (Filesize > 1): # echo creates 1 byte file
            try:
                filepoint = open(logfile, 'r')
                errorlog = filepoint.readlines()
                filepoint.close()
            except:
                self.log.error("MswErrorWatch: Error reading log file")

	# Return the newly added lines
	return errorlog

    def watchMswErrors(self, result, failtest=True):
        """
        Watch on MSW for Error logs.
        
        The method watches for errors at MSW during test execution.
        It gets the error log file to the local machine at the end
        of each test execution to see if fresh errors are reported.
        If there are fresh errors, these are added to nextest log
        and the test is failed.
        """
        # self.log.info("MswErrorWatch: failtest value = %s" % failtest)

        # Fetch the error log file to local machine
        self._fetchfile()

        # Compare previous and current error files for additions
        freshlogs = self.__getErrorlog(self.currErrlog)

        if (freshlogs != []):
            # Add the errors to nextest log
            for msg in freshlogs:
                self.log.error("MswErrorWatch: ERROR on MSW: %s" % msg)

            # Assert test fail
            if (failtest):
                result.SetOutcome(Result.FAIL, "MSW reported error")
                self.log.info("MswErrorWatch: Test failed due to MSW error")
            else:
                result.Annotate({'MSW fault':"MSW reported error"})
                self.log.info("MswErrorWatch: Result annotation due to MSW error")
             
        # log info and return the result
        msg  = "MswErrorWatch: Error watch on MSW done"
        self.log.info(msg)            


########################################################################
# Unit tests
########################################################################

class MswErrorWatchTest(unittest.TestCase):
    """
    Unittest class for testing the main parts of msw_errorwatch.py code.
    """

    def testErrorlog(self):
        """
        This test validates if watchMswErrors() works fine.

        Instantiating the class will create the files.
        Then add a newline to the msw error log file.
        Now, watchMswErrors() should detect the new addition

        """
        # instantiate the class
        myMswInfo  = msw.MSWInfo('mymsw')
        errorWatch = MswErrorWatch(myMswInfo)

        # Put the content in errorlog file at MSW
        message = "MswErrorWatch: dummyline to test Error log feature"
        mswcmd  = "echo %s > %s" % (message, errorWatch.mswlogpath)
        errorWatch.mymsw.ssh.sendline(mswcmd)

        #creating dummy result
        myresult = Result(Result.TEST, "DUMMY 1", annotations = {})

        # find error log difference
        errorWatch.watchMswErrors(myresult, False)
        
        # Assertions
        self.assertEqual(myresult.get('MSW fault'), 'MSW reported error')
            

if __name__ == '__main__':
    unittest.main()


########################################################################
# Local Variables:
# mode: python
# indent-tabs-mode: nil
# fill-column: 78
# auto-fill-function: do-auto-fill
# End:
