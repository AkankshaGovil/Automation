"""Codenomicon specific classes.
"""

import pexpect 
import shells 
import os, sys
import unittest
import logging
from time import *

class Codenomicon(object):
    """Class encapsulating Codenomicon software. Basically wrapping the software into this class, allows
    others to use the software as an object without bothering about the exact commands. This also isolates
    Nextest from Codenomicon related changes.
    """
    def __init__(self, codyAddr, serverAddr, workDir='/tmp',message=None,dialogue=None):
        # Added the docstring, changes made for ticket no. 34934
        """
          In this function we initialize all the variables to be used throughout the
          class Codenomicon.
          Parameters supplied to the __init__ functions are.

          codyAddr    ---- The IP address of machine from where we run the tool codenomicon.
          serverAddr  ---- IP address of the SUT machine.
          workDir     ---- The directory where the codenomicon logs will be stored code will  be stored.
          message     ---- The anomalised message in sequence dialogue
          dialogue    ---- The SIP dialog that is used by the test tool in all test cases

        """
        
    
	#setup local shell
        # Changes made for FP 36216
        #updated the name of jar file to sip-uas32.jar to use the codenomicon sip 3.2 test suite (ticket #37641)
        if (not (os.environ.has_key('CLASSPATH') and (os.environ['CLASSPATH'].count('sip-uas32.jar') > 0))):
            raise EnvironmentError, 'CLASSPATH does not contain sip-uas32.jar file'

        self.localShell = shells.LocalShell()
        self.msw = shells.MswShell()
        self.workDir = workDir
	self.message = message
	self.dialogue = dialogue
        self.myAddr = codyAddr
        self.serverAddr = serverAddr
        self.results = {'verdict':'UNTESTED', 'testIndex':0}
        self.coreFiles = self.msw.getCoreFiles()
        self.log = logging.getLogger('nextestlog')
        self.logPatterns = self.localShell.compile_pattern_list([
                                    'Test case #(\d+) completed',
                                    'Reached end-of-test-cases',
                                    pexpect.EOF, 
                                    pexpect.TIMEOUT])
        self.errorPatterns = self.localShell.compile_pattern_list([
                                    pexpect.TIMEOUT,
                                    'No such file or directory',
                                    'Exception in thread',
                                    pexpect.EOF])

    def __del__(self):
        self.localShell.disconnect()
        self.msw.disconnect()

    def start(self, index='0-'):
        """Start running the codenomicon software.
	   
        """
        codyToolCommand = 'java -Xmx128M com.codenomicon.utility.protectedloader.Main '
        codyToolCommand += '--no-gui '
        codyToolCommand += '--index %s ' % index
        codyToolCommand += '--to-uri sip:361012222@%s ' % self.serverAddr
        #Ticket 36101 - changed from uri, via an contact uri port to 5070
        codyToolCommand += '--from-uri sip:361011111@%s:5070 ' % self.serverAddr
        # Ticket-36225: Use port 5070 instead of 5060
        
        if ( (self.message == "CANCEL" or self.message == "ACK") and  self.dialogue == None) :
	    codyToolCommand += '--message %s ' %self.message
        elif (self.message == None  and self.dialogue == "dlg-invite-bye" ):  
	    codyToolCommand += '--sequence %s ' %self.dialogue
        # Changes made for ticket 36336
        elif ( (self.message == "BYE" or self.message == "ACK" or self.message == "ACK-BYE" or self.message == "INFO" or self.message == "REFER") and self.dialogue == "dlg-invite-bye" ):
	    codyToolCommand += '--sequence %s ' %self.dialogue
	    codyToolCommand += '--message %s ' %self.message
        elif ( self.dialogue == "dlg-options" or self.dialogue == "dlg-register" or self.dialogue == "dlg-subscribe" or self.dialogue == "dlg-refer" or self.dialogue == "message"):
	    codyToolCommand += '--sequence %s ' %self.dialogue

        codyToolCommand += '--log-dir %s/cody ' % self.workDir
        codyToolCommand += '--via-uri 361011111@%s:5070 ' % self.myAddr
        codyToolCommand += '--contact-uri 361011111@%s:5070' % self.myAddr
        # Ticket-36225: Use port 5070 instead of 5060


	    

        print 'Cody command is :%s:' % codyToolCommand
        self.log.debug('Codenomicon: start command: %s' % codyToolCommand)
        self.localShell.sendline(codyToolCommand)

        i = self.localShell.expect_list(self.errorPatterns, 2)
        
        # Changes made for ticket 36216
	#updated the name of jar file to sip-uas31.jar to use the codenomicon sip 3.2 test suite (ticket #37641).
	
       	if (i != 0):
            warningMessage = 'sip-uas32.jar file is not in CLASSPATH. Following steps should be performed: ' + \
                             'Correct the CLASSPATH in .bashrc or .nextestrc file'
            raise EnvironmentError,warningMessage

    def runTillVerdict(self):
        """This call is blocking call for the calling user. The call will wait till the Cody software
        stops running which may take more than 24 hours.
        """
        while True:
            #we wait for a maximum of 60 seconds for each test to complete
            i = self.localShell.expect_list(self.logPatterns, 120)
            if i == 0:
                testCaseNumber = int(self.localShell.match.group(1))
        
                if (self.results['testIndex'] != testCaseNumber):
                    print 'Warning: Missing tests between %s and %s' % (self.results['testIndex'], testCaseNumber)
        
                self.results['testIndex'] = testCaseNumber+1
        
                print '\ttest %s completed' % testCaseNumber
                self.qmtTestEndHook(testCaseNumber)
        
            elif i == 1:
                print 'End reached:%s:' % self.localShell.match.group()
                self.results['verdict'] = 'PASS'
                break
        
            else:
                print 'EOF or timeout'
                self.results['verdict'] = 'FAIL'
                break

        return self.results


    def __del__(self):
        #destroy local shell
        pass

    def testHooks(self, testPoint):
        """Future use only.
        """
        #demux calls
        pass

    def startRunHook(self):
        """Called at the beginning of test campaign. Not used currently.
        """
        #Verify iserver is running
        if not self.msw.isServerRunning():
            raise EnvironmentError,'Server is down'

        #start sdebug 3
        self.localShell.runCommand('localShelljava GetiServerConfig mymsw LoggingConfig')

    def startTestHook(self):
        """Called at the begining of each test case run. Not used currently.
        """

    def endTestHook(self):
        """Called at the end of each test case run. Not used currently.
        """
        #where do I store the results
        if self.msw.isCoreFilePresent():
	    #copy over the file somewhere else
            self.localShell.runCommand('scp root@mymsw:/usr/local/nextone/bin/*core* ~/cody')
            self.msw.runCommand('mv /usr/local/nextone/bin/*core* /tmp')
            self.localShell.runCommand('scp root@mymsw:/var/core/*core* ~/cody')
            self.msw.runCommand('mv /var/core/*core* /tmp')

            #copy over debug buffer
            self.localShell.runCommand('scp root@mymsw: ~/cody')

        #truncate the buffer
        #self.msw.runCommand('echo "" > /var/log/iserver.log')

    def IntrumentHook(self):
        """Instrumentation hook function. Used to find out health of MSW at the end of each test. 
        Not used currently.
        """
        #if iserver is not running
        #   return fail
        pass

    def IntrumentFailHook(self):
        """Instrumentation fail hook function. Used to take corrective action if instrumentation fails. 
        Not used currently.
        """
        #Restart iserver
        #If failed to restart
        #	return fail
        pass

    def qmtTestEndHook(self, testIndex):
        """Hook Function called the end of test campaign. 
        """

        self.log.info('test %s completed' % testIndex)
        coreFiles = self.msw.getCoreFiles()

        newCoreFiles = [x for x in coreFiles if x not in self.coreFiles]

        if len(newCoreFiles) == 0:
            return

        self.coreFiles.extend(newCoreFiles)

        for files in newCoreFiles:
            print 'CORE FILE for test %s' % testIndex
            self.log.critical('test %s caused core: %s' % (testIndex, files))
            self.msw.runCommand('echo "CODY TEST %s caused core %s file" >> /var/log/iserver.log' % (testIndex, files))

            #copy over debug buffer
            #self.localShell.runCommand('scp root@mymsw: ~/cody')

        #truncate the buffer
        #self.msw.runCommand('echo "" > /var/log/iserver.log')


class CodyTest(unittest.TestCase):
    """
    Unittest class for testing Codenomicon class.
    """
    def test_1(self):
        """
        check runCommand()
        """
        msw = shells.MswShell()
        msw.deleteCoreFiles()

        cody = Codenomicon(
                              codyAddr='10.1.6.22',
                              serverAddr='10.2.0.40', 
                              workDir='/tmp'
                              )
        print 'existing core files: %s' % cody.coreFiles
        cody.start('0-2')
        cody.msw.runCommand('echo \'\' > %s/core.DilbaghChahal01' %cody.msw.corePath)
        cody.msw.runCommand('echo \'\' > %s/core.DilbaghChahal02' %cody.msw.corePath)
        verdict = cody.runTillVerdict()
        print verdict
        #cody = Codenomicon()
        #coreFiles = cody.msw.getCoreFiles()
        #self.assertEqual(len(coreFiles), 2)
        #cody.qmtTestEndHook(999)
        #coreFiles = cody.msw.getCoreFiles()
        #self.assertEqual(len(coreFiles), 0)
        #output = cody.localShell.runCommand('ls -1 /tmp/*core*')
        #self.assertNotEqual(output.find('999_core.DilbaghChahal01'), -1)
        #self.assertNotEqual(output.find('999_core.DilbaghChahal02'), -1)

        #cody.localShell('delete /tmp/core*')
        


if __name__ == '__main__':

    if len(sys.argv) == 1:
        unittest.main()


