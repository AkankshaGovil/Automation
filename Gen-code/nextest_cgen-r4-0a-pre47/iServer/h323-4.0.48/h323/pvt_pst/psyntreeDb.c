/*
***********************************************************************************

NOTICE:
This document contains information that is proprietary to RADVISION LTD..
No part of this publication may be reproduced in any form whatsoever without
written prior approval by RADVISION LTD..

RADVISION LTD. reserves the right to revise this publication and make changes
without obligation to notify any person of such revisions or changes.

***********************************************************************************
*/


/*
  psynTreeDb

  Syntax tree database access
  Provides internal functions to access the syntax database generated by the
  ASN.1 compiler.
 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdlib.h>
#include <psyntreeDb.h>


/************************************************************************
 *
 *                              Private structures
 *
 ************************************************************************/


/************************************************************************
 * searchKey struct
 * Used as the key to search for in calls to the standard library's bsearch()
 * syntax   - Syntax struct being searched
 * data     - Data being searched for
 ************************************************************************/
typedef struct
{
    fmt2Struct* syntax;
    void*       data;
} searchKey;






/************************************************************************
 *
 *                              Private functions
 *
 ************************************************************************/


/************************************************************************
 * fmt2NameCompare
 * purpose: Compare a search key with a table element of the syntax
 *          Used when looking for a name offset
 * input  : eKey    - Key element we're searching for
 *          elem    - Element we're currently comparing with
 * output : none
 * return : Negative if the key is lower than elem in dictionary comparison
 *          0 if the key and the element are equal
 *          Positive if the key is higher than elem in dictionary comparison
 ************************************************************************/
int fmt2NameCompare(IN const void *eKey, IN const void *elem)
{
    searchKey*  key = (searchKey *)eKey;
    char*       str2 = (char *)elem;

    str2 = key->syntax->dictionary + ((fmt2Elem *)elem)->nameOffset + 1;

    return strcmp((char *)key->data, str2);
}





/************************************************************************
 *
 *                              Public functions
 *
 ************************************************************************/


/************************************************************************
 * stGetChildByIndex
 * purpose: Get a child node of a parent node by its index
 * input  : hSyn            - Syntax information
 *          parentNodeId    - Parent's node ID
 *          index           - Index of the child (1-based)
 * output : nodeData        - Data pointer of the child node
 *                            Can be set to NULL
 * return : Child's node ID on success
 *          Negative value on failure
 ************************************************************************/
int stGetChildByIndex(
    IN  HPST        hSyn,
    IN  int         parentNodeId,
    IN  int         index,
    OUT UINT32**    nodeData)
{
    int nextId, i;
    fmt2Struct* syntax = ((synStruct *)hSyn)->syntax;

    /* Sanity checks */
    if ((parentNodeId < 0) || (parentNodeId >= syntax->dataSize))
        return RVERROR;
    nextId = parentNodeId;

    /* Travel through the children to the right index */
    for (i = 0; i < index; i++)
    {
        /* Skip current node */
        nextId += (syntax->data[nextId] & 0xff);

        /* Make sure we're not out of bounds yet */
        if (nextId >= syntax->dataSize) return RVERROR;
    }

    /* See if we also have to get the data itself */
    if (nodeData != NULL)
        *nodeData = syntax->data + nextId + 1;

    return nextId;
}


/************************************************************************
 * stGetNodeDataByNodeId
 * purpose: Get the data pointer of a node by its node ID
 * input  : hSyn        - Syntax information
 *          nodeId      - Node ID
 * output : none
 * return : Data pointer of node information on success
 *          NULL on failure
 ************************************************************************/
UINT32* stGetNodeDataByNodeId(IN HPST hSyn, IN int nodeId)
{
    fmt2Struct* syntax = ((synStruct *)hSyn)->syntax;

    /* Sanity checks */
	/* NexTone: added check for NULL syntax */
    if ((nodeId < 0) || (syntax == NULL) || (nodeId >= syntax->dataSize))
        return NULL;

    return (syntax->data + nodeId + 1);
}


/************************************************************************
 * stGetNameByNameId
 * purpose: Get the name string by the name ID
 * input  : hSyn        - Syntax information
 *          nameId      - Name ID of the field
 * output : length      - Length on name in bytes
 *                        Can be set to NULL
 * return : Name of field on success
 *          NULL on failure
 ************************************************************************/
char* stGetNameByNameId(
    IN  HPST        hSyn,
    IN  int         nameId,
    OUT int*        length)
{
    fmt2Struct* syntax = ((synStruct *)hSyn)->syntax;

    /* Sanity check */
	/* NexTone: added check for NULL syntax */
    if ((nameId < 0) || (syntax == NULL) || (nameId >= syntax->dictionarySize))
        return NULL;

    /* Get the length */
    if (length != NULL)
        *length = syntax->dictionary[nameId] - 1;

    return (syntax->dictionary + nameId + 1);
}


/************************************************************************
 * stGetNodeIdByName
 * purpose: Get the node ID of a type by the type's name string
 * input  : hSyn        - Syntax information
 *          name        - String name
 * return : Type's node ID on success
 *          Negative value on failure
 ************************************************************************/
int stGetNodeIdByName(IN HPST hSyn, IN char *name)
{
    searchKey key;
    fmt2Elem* elem;

    if (name == NULL) return RVERROR;

    /* Create the search key */
    key.syntax  = ((synStruct *)hSyn)->syntax;
    key.data    = name;

    /* Search for the name inside the main table.
       The strings are sorted, so we're using binary search for it */
    elem = (fmt2Elem *)bsearch(&key, key.syntax->table, key.syntax->tableSize, sizeof(fmt2Elem), fmt2NameCompare);
    if (elem == NULL) return RVERROR;

    return elem->dataOffset;
}


/************************************************************************
 * stGetNameIdByName
 * purpose: Get the name ID for a given name string
 * input  : hSyn        - Syntax information
 *          name        - String name
 * return : Name ID on success
 *          Negative value on failure
 ************************************************************************/
int stGetNameIdByName(IN HPST hSyn, IN char *name)
{
    searchKey key;
    fmt2Elem* elem;

    /* Create the search key */
    key.syntax  = ((synStruct *)hSyn)->syntax;
    key.data    = name;

    /* Search for the name inside the main table.
       The strings are sorted, so we're using binary search for it */
    elem = (fmt2Elem *)bsearch(&key, key.syntax->table, key.syntax->tableSize, sizeof(fmt2Elem), fmt2NameCompare);
    if (elem == NULL) return RVERROR;

    return elem->nameOffset;
}


/************************************************************************
 * stGetNodeIdByNameId
 * purpose: Get the node ID of a type by the type's name ID
 * input  : hSyn        - Syntax information
 *          nameId      - String name's ID
 * return : Type's node ID on success
 *          Negative value on failure
 ************************************************************************/
int stGetNodeIdByNameId(IN HPST hSyn, IN int nameId)
{
    /* Get the name, and then search for the node ID :-) */
    return stGetNodeIdByName(hSyn, stGetNameByNameId(hSyn, nameId, NULL));
}


/************************************************************************
 * stGetNameIdByNodeId
 * purpose: Get the name ID of a type by the type's node ID
 * input  : hSyn        - Syntax information
 *          nodeId      - Node ID
 * return : Type's name ID on success
 *          Negative value on failure
 ************************************************************************/
int stGetNameIdByNodeId(IN HPST hSyn,IN int nodeId)
{
    UINT32* node = ((synStruct *)hSyn)->syntax->data + nodeId;

    return ((*node) >> 8);
}


/************************************************************************
 * stGetNameByNodeId
 * purpose: Get the name string of a type by the type's node ID
 * input  : hSyn        - Syntax information
 *          nodeId      - Node ID
 * return : Name string of node on success
 *          NULL on failure
 ************************************************************************/
char* stGetNameByNodeId(IN HPST hSyn, IN int nodeId)
{
    return stGetNameByNameId(hSyn, stGetNameIdByNodeId(hSyn, nodeId), NULL);
}


/************************************************************************
 * stGetChildByNodeAndFieldName
 * purpose: Get a child's node ID by its parent's node ID and the child's
 *          name id.
 * input  : hSyn            - Syntax information
 *          parentNodeId    - Parent's node ID
 *          numFields       - Number of fields in the parent
 *          childNameId     - Name ID of the searched child
 * output : childNodeId     - Node ID of the child
 * return : Child's index on success (1-based)
 *          Negative value on failure
 ************************************************************************/
int stGetChildByNodeAndFieldName(
    IN  HPST    hSyn,
    IN  int     parentNodeId,
    IN  int     numFields,
    IN  int     childNameId,
    OUT int*    childNodeId)
{
    fmt2Struct* syntax = ((synStruct *)hSyn)->syntax;
    int nextId, i;

    /* Sanity checks */
    if ((parentNodeId < 0) || (parentNodeId >= syntax->dataSize)) return RVERROR;
    nextId = parentNodeId;

    /* Go through the fields and see if any of the match */
    for (i = 1; i <= numFields; i++)
    {
        /* Get the next child - it's right after the last node */
        nextId += (syntax->data[nextId] & 0xff);
        if (nextId >= syntax->dataSize) return RVERROR;

        if ((int)(syntax->data[nextId] >> 8) == childNameId)
        {
            /* Found the node with the same name id - we're done */
            if (childNodeId != NULL)
                *childNodeId = nextId;
            return i;
        }
    }

    /* Not found */
    return RVERROR;
}



#ifdef __cplusplus
}
#endif

