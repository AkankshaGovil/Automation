/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "cli_rpc.h"
#include <stdio.h>
#include <stdlib.h> /* getenv, exit */
#include <signal.h>

/* AAAAAAA */

#include "gis.h"

extern cache_t mapCacheType2Cache(int cacheType);

CacheTableInfo *
cli_cache_handle_iedge_1(netInfo, cacheType, op, rqstp)
	NetoidInfoEntry *netInfo;
	int cacheType;
	int op;
	struct svc_req *rqstp;
{
	static CacheTableInfo	centry={0};
	cache_t  cache;
	int	retval = TRUE;
	/*
	 * insert server code here
	 */
	switch (op)
	{
		case CLIOP_ADD:
		case CLIOP_DELETE:
		case CLIOP_REPLACE:
				/* how do i convey the value of success of failure of 
				 *	this routine to other side
				 */
				CacheHandleIedge(netInfo, op);
				memset(&centry, 0 , sizeof(CacheTableInfo));
				break;

		/* copies database entry portion of cache entry into netInfo */
		/* only looks up regCache */
		case CLIOP_COPY:
				memset(&centry, 0 , sizeof(CacheTableInfo));
				InheritIedgeGlobals(netInfo);
				memcpy(&centry.data, netInfo, sizeof(InfoEntry));
	}
	return (&centry);
}

int *
cli_cache_insert_1(cacheType, data, rqstp)
	int cacheType;
	CacheEntryGeneric data;
	struct svc_req *rqstp;
{
	static int  result=-1;
	CacheTableInfo  *info = NULL;
	CacheRealmEntry  *realm = NULL;
	CacheIgrpInfo    *igrp = NULL;
	CacheTriggerEntry *trigger=NULL;
	CacheGkInfo			*gk= NULL;
	void		*item=NULL;
	cache_t		wcache;

	switch (data.cache)
	{
		case REG_CACHE:
		case REGID_CACHE:
		case PHONE_CACHE:
		case VPN_PHONE_CACHE:
		case EMAIL_CACHE:
		case IP_CACHE:
		case URI_CACHE:
		case H323ID_CACHE:
		case SUBNET_CACHE:
		case TG_CACHE:
				info = malloc(sizeof(CacheTableInfo));
				if (info)
				{
					memcpy(info, &data.cache_entry_u.cacheInfoEntry, sizeof(CacheTableInfo));
					item = info; 
				}
				break;
		case GK_CACHE:
				gk = malloc(sizeof(CacheGkInfo));
				if (gk)
				{
					memcpy(info, &data.cache_entry_u.cacheGkEntry, sizeof(CacheGkInfo));
					item = gk; 
				}
				break;
		case CRID_CACHE:
				/* cacheIedge = CacheGet(cridCache, &data.keyCrId); */
				break;
		case GW_CACHE:
				break;
		case REALM_CACHE:
		case RSA_CACHE:
				realm = malloc(sizeof(CacheRealmEntry));
				if (realm)
				{
					memcpy(realm, &data.cache_entry_u.cacheRealmEntry, sizeof(CacheRealmEntry));
					item = realm; 
				}
				break;
		case IGRP_CACHE:
				igrp = malloc(sizeof(CacheIgrpInfo));
				if (igrp)
				{
					memcpy(igrp, &data.cache_entry_u.cacheIgrpEntry, sizeof(CacheIgrpInfo));
					item = igrp; 
				}
				break;
		case TRIGGER_CACHE:
				trigger = malloc(sizeof(CacheTriggerEntry));
				if (trigger)
				{
					memcpy(trigger, &data.cache_entry_u.cacheTriggerEntry, sizeof(CacheTriggerEntry));
					item = trigger; 
				}
				break;

		default :
				break;

	}

	if (item)
	{
		wcache = mapCacheType2Cache(cacheType);
		CacheGetLocks(wcache, LOCK_WRITE, LOCK_BLOCK);
		result = CacheInsert(wcache, info);
		CacheReleaseLocks(wcache);
	}

	return (&result);
}

int *
cli_cache_get_numitems_1(cacheType, rqstp)
	int cacheType;
	struct svc_req *rqstp;
{
	static int  result;
	cache_t		wcache;

	wcache = mapCacheType2Cache(cacheType);
	result = wcache->nitems;
	return (&result);
}

CacheEntryGeneric *
cli_cache_get_1(cacheType, data, rqstp)
	int cacheType;
	CacheKey data;
	struct svc_req *rqstp;
{
	static CacheEntryGeneric	entry={0};
	CacheTableInfo      *iedge= NULL;
	CacheGkInfo			*gk=NULL;
	CacheTriggerEntry	*trigger=NULL;
	CacheRealmEntry		*realm=NULL;
	CacheIgrpInfo		*igrp=NULL;
	CacheVpnEntry		*vpn=NULL;
	CacheVpnGEntry		*vpng=NULL;
	CacheCPEntry		*cp=NULL;
	CacheCPBEntry		*cpbcr=NULL;
	int					found = FALSE;
	int					retval = TRUE;

	entry.cache = CACHE_IGNORE;

	switch (data.cache)
	{
		case REG_CACHE:
				CacheGetLocks(regCache, LOCK_READ, LOCK_BLOCK);
				iedge = CacheGet(regCache, &data.cache_key_u.keyInfoEntry);
				if (iedge)
				{
					found =  TRUE;
					entry.cache = data.cache;
					memset(&entry.cache_entry_u.cacheInfoEntry, 0, sizeof(CacheTableInfo));
					memcpy(&entry.cache_entry_u.cacheInfoEntry, iedge, sizeof(CacheTableInfo));
				}
				CacheReleaseLocks(regCache);
				break;
		case REGID_CACHE:
				CacheGetLocks(regCache, LOCK_READ, LOCK_BLOCK);
				iedge = CacheGet(regidCache, &data.cache_key_u.keyInfoEntry);
				if (iedge)
				{
					found =  TRUE;
					entry.cache = data.cache;
					memset(&entry.cache_entry_u.cacheInfoEntry, 0, sizeof(CacheTableInfo));
					memcpy(&entry.cache_entry_u.cacheInfoEntry, iedge, sizeof(CacheTableInfo));
				}
				CacheReleaseLocks(regCache);
				break;
		case PHONE_CACHE:
				CacheGetLocks(regCache, LOCK_READ, LOCK_BLOCK);
				iedge = CacheGet(phoneCache, &data.cache_key_u.keyPhone);
				if (iedge)
				{
					found =  TRUE;
					entry.cache = data.cache;
					memset(&entry.cache_entry_u.cacheInfoEntry, 0, sizeof(CacheTableInfo));
					memcpy(&entry.cache_entry_u.cacheInfoEntry, iedge, sizeof(CacheTableInfo));
				}
				CacheReleaseLocks(regCache);
				break;
		case VPN_PHONE_CACHE:
				CacheGetLocks(regCache, LOCK_READ, LOCK_BLOCK);
				iedge = CacheGet(vpnPhoneCache, &data.cache_key_u.keyPhone);
				if (iedge)
				{
					found =  TRUE;
					entry.cache = data.cache;
					memset(&entry.cache_entry_u.cacheInfoEntry, 0, sizeof(CacheTableInfo));
					memcpy(&entry.cache_entry_u.cacheInfoEntry, iedge, sizeof(CacheTableInfo));
				}
				CacheReleaseLocks(regCache);
				break;
		case EMAIL_CACHE:
				CacheGetLocks(regCache, LOCK_READ, LOCK_BLOCK);
				iedge = CacheGet(emailCache, &data.cache_key_u.keyEmail);
				if (iedge)
				{
					found =  TRUE;
					entry.cache = data.cache;
					memset(&entry.cache_entry_u.cacheInfoEntry, 0, sizeof(CacheTableInfo));
					memcpy(&entry.cache_entry_u.cacheInfoEntry, iedge, sizeof(CacheTableInfo));
				}
				CacheReleaseLocks(regCache);
				break;
		case IP_CACHE:
				CacheGetLocks(regCache, LOCK_READ, LOCK_BLOCK);
				iedge = CacheGet(ipCache, &data.cache_key_u.keyRealmIP);
				if (iedge)
				{
					found =  TRUE;
					entry.cache = data.cache;
					memset(&entry.cache_entry_u.cacheInfoEntry, 0, sizeof(CacheTableInfo));
					memcpy(&entry.cache_entry_u.cacheInfoEntry, iedge, sizeof(CacheTableInfo));
				}
				CacheReleaseLocks(regCache);
				break;
		case URI_CACHE:
				CacheGetLocks(regCache, LOCK_READ, LOCK_BLOCK);
				iedge = CacheGet(uriCache, &data.cache_key_u.keyUri);
				if (iedge)
				{
					found =  TRUE;
					entry.cache = data.cache;
					memset(&entry.cache_entry_u.cacheInfoEntry, 0, sizeof(CacheTableInfo));
					memcpy(&entry.cache_entry_u.cacheInfoEntry, iedge, sizeof(CacheTableInfo));
				}
				CacheReleaseLocks(regCache);
				break;
		case H323ID_CACHE:
				CacheGetLocks(regCache, LOCK_READ, LOCK_BLOCK);
				iedge = CacheGet(h323idCache, &data.cache_key_u.keyh323Id);
				if (iedge)
				{
					found =  TRUE;
					entry.cache = data.cache;
					memset(&entry.cache_entry_u.cacheInfoEntry, 0, sizeof(CacheTableInfo));
					memcpy(&entry.cache_entry_u.cacheInfoEntry, iedge, sizeof(CacheTableInfo));
				}
				CacheReleaseLocks(regCache);
				break;
		case SUBNET_CACHE:
				CacheGetLocks(regCache, LOCK_READ, LOCK_BLOCK);
				iedge = CacheGet(subnetCache, &data.cache_key_u.keyRealmSubnet);
				if (iedge)
				{
					found =  TRUE;
					entry.cache = data.cache;
					memset(&entry.cache_entry_u.cacheInfoEntry, 0, sizeof(CacheTableInfo));
					memcpy(&entry.cache_entry_u.cacheInfoEntry, iedge, sizeof(CacheTableInfo));
				}
				CacheReleaseLocks(regCache);
				break;
		case CRID_CACHE:
				/* iedge = CacheGet(cridCache, &data.keyCrId); */
				break;
		case TG_CACHE:
				CacheGetLocks(regCache, LOCK_READ, LOCK_BLOCK);
				iedge = CacheGet(tgCache, &data.cache_key_u.keyTg);
				if (iedge)
				{
					found =  TRUE;
					entry.cache = data.cache;
					memset(&entry.cache_entry_u.cacheInfoEntry, 0, sizeof(CacheTableInfo));
					memcpy(&entry.cache_entry_u.cacheInfoEntry, iedge, sizeof(CacheTableInfo));
				}
				CacheReleaseLocks(regCache);
				break;
		case GW_CACHE:
				break;
		case GK_CACHE:
				CacheGetLocks(regCache, LOCK_READ, LOCK_BLOCK);
				gk= CacheGet(gkCache, &data.cache_key_u.keyGk);
				if (gk)
				{
					found =  TRUE;
					entry.cache = data.cache;
					memset(&entry.cache_entry_u.cacheGkEntry, 0, sizeof(CacheGkInfo));
					memcpy(&entry.cache_entry_u.cacheGkEntry, gk, sizeof(CacheGkInfo));
				}
				CacheReleaseLocks(regCache);
				break;
		case TRIGGER_CACHE:
				CacheGetLocks(triggerCache, LOCK_READ, LOCK_BLOCK);
				trigger = CacheGet(triggerCache, &data.cache_key_u.keyTrigger);
				if (trigger)
				{
					found =TRUE;
					entry.cache = data.cache;
					memset(&entry.cache_entry_u.cacheTriggerEntry, 0, sizeof(CacheTriggerEntry));
					memcpy(&entry.cache_entry_u.cacheTriggerEntry, trigger, sizeof(CacheTriggerEntry));
				}
				CacheReleaseLocks(triggerCache);
				break;
		case REALM_CACHE:
		case RSA_CACHE:
				CacheGetLocks(realmCache, LOCK_READ, LOCK_BLOCK);
				realm = CacheGet(((data.cache == REALM_CACHE)? realmCache : rsaCache),
					   												&data.cache_key_u.keyRealm);
				if(realm)
				{
					found  = TRUE;
					entry.cache = data.cache;
					memset(&entry.cache_entry_u.cacheRealmEntry, 0, sizeof(CacheRealmEntry));
					memcpy(&entry.cache_entry_u.cacheRealmEntry, realm, sizeof(CacheRealmEntry));
				}
				CacheReleaseLocks(realmCache);
				break;
		case IGRP_CACHE:
				CacheGetLocks(igrpCache, LOCK_READ, LOCK_BLOCK);
				igrp = CacheGet(igrpCache, &data.cache_key_u.keyIgrp);
				if (igrp)
				{
					found =TRUE;
					entry.cache = data.cache;
					memset(&entry.cache_entry_u.cacheIgrpEntry, 0, sizeof(CacheIgrpInfo));
					memcpy(&entry.cache_entry_u.cacheIgrpEntry, igrp, sizeof(CacheIgrpInfo));
				}
				CacheReleaseLocks(igrpCache);
				break;

		case VPN_CACHE:
				CacheGetLocks(vpnCache, LOCK_READ, LOCK_BLOCK);
				vpn = CacheGet(vpnCache, &data.cache_key_u.keyVpn);
				if (vpn)
				{
					found = TRUE;
					entry.cache = data.cache;
					memset(&entry.cache_entry_u.cacheVpnEntry, 0, sizeof(CacheVpnEntry));
					memcpy(&entry.cache_entry_u.cacheVpnEntry,	vpn, sizeof(CacheVpnEntry));
				}
				CacheReleaseLocks(vpnCache);
				break;

		case VPNG_CACHE:
				CacheGetLocks(vpnGCache, LOCK_READ, LOCK_BLOCK);
				vpng = CacheGet(vpnGCache, &data.cache_key_u.keyVpnG);
				if (vpng)
				{
					found = TRUE;
					entry.cache = data.cache;
					memset(&entry.cache_entry_u.cacheVpnGEntry, 0, sizeof(CacheVpnGEntry));
					memcpy(&entry.cache_entry_u.cacheVpnGEntry,	vpn, sizeof(CacheVpnGEntry));
				}
				CacheReleaseLocks(vpnGCache);
				break;
		case CP_CACHE:
				CacheGetLocks(cpCache, LOCK_READ, LOCK_BLOCK);
				cp = CacheGet(cpCache, &data.cache_key_u.keyCp);
				if (cp)
				{
					found = TRUE;
					entry.cache = data.cache;
					memset(&entry.cache_entry_u.cacheCPEntry, 0, sizeof(CacheCPEntry));
					memcpy(&entry.cache_entry_u.cacheCPEntry, cp, sizeof(CacheCPEntry));
				}
				CacheReleaseLocks(cpCache);
				break;

		case CPBCR_CACHE:
				CacheGetLocks(cpbcrCache, LOCK_READ, LOCK_BLOCK);
				cpbcr = CacheGet(cpbcrCache, data.cache_key_u.keyCpb.crname);
				if (cpbcr)
				{
					found = TRUE;
					entry.cache = data.cache;
					memset(&entry.cache_entry_u.cacheCPBEntry, 0, sizeof(CacheCPBEntry));
					memcpy(&entry.cache_entry_u.cacheCPBEntry, cpbcr, sizeof(CacheCPBEntry));
				}
				CacheReleaseLocks(cpbcrCache);
				break;

		case GWCP_CACHE:
				/* required for PrintCPBList in clicp.c */
				break;
		default :
				break;

	}

	if (found == FALSE)
	{
		entry.cache = CACHE_IGNORE;
		entry.cache_entry_u.foo = 0xdeadbeef;
	}

	return (&entry);
}


int *
cli_handle_cache_reinstantiate_1(cacheType, rqstp)
	int cacheType;
	struct svc_req *rqstp;
{
	static int  result;
	switch (cacheType)
	{
		case VPN_CACHE:
					CacheGetLocks(vpnCache, LOCK_WRITE, LOCK_BLOCK);
					VpnCacheDestroyData(lsMem);
					VpnCacheInstantiate(lsMem);
					CacheReleaseLocks(vpnCache);

					VpnPopulate(lsMem, NULL);
					break;

		case VPNG_CACHE:
					CacheGetLocks(vpnGCache, LOCK_WRITE, LOCK_BLOCK);
					VpnGCacheDestroyData(lsMem);
					VpnGCacheInstantiate(lsMem);
					CacheReleaseLocks(vpnGCache);

					VpnGPopulate(lsMem, NULL);
					break;
		case CP_CACHE:
					CacheGetLocks(cpCache, LOCK_WRITE, LOCK_BLOCK);
					CPCacheDestroyData(lsMem);
					CPCacheInstantiate(lsMem);
					CacheReleaseLocks(cpCache);

					CPPopulate(lsMem, NULL);
					break;
		case CPB_CACHE:
					CacheGetLocks(cpbCache, LOCK_WRITE, LOCK_BLOCK);
					CPBCacheDestroyData(lsMem);
					CPBCacheInstantiate(lsMem);
					CacheReleaseLocks(cpbCache);

					CPBPopulate(lsMem, NULL);
					break;
		case REALM_CACHE:
					CacheGetLocks(realmCache, LOCK_WRITE, LOCK_BLOCK);
					RealmCacheDestroyData(lsMem);
					RealmCacheInstantiate(lsMem);
					CacheReleaseLocks(realmCache);

					RealmPopulate(lsMem, NULL);
					break;

		case IGRP_CACHE:
					CacheGetLocks(igrpCache, LOCK_WRITE, LOCK_BLOCK);
					IgrpCacheDestroyData(lsMem);
					IgrpCacheInstantiate(lsMem);
					CacheReleaseLocks(igrpCache);

					IgrpPopulate(lsMem, NULL);
					break;
	}
	return (&result);
}


int *
cli_cache_purge_1(cacheName, rqstp)
	char *cacheName;
	struct svc_req *rqstp;
{
	static int  result=TRUE;
	CachePurge(cacheName);
	return (&result);
}

CacheTableInfo_va *
cli_handle_netoid_get_bulk_1(cacheType, rqstp)
	int cacheType;
	struct svc_req *rqstp;
{
	static CacheTableInfo_va result = {0};
	CacheTableInfo	*info=NULL, *buf =NULL;
	RealmIP	realmip;
	int		num_items=0;
	int		n;
	cache_t	wCache;
	int		retval = TRUE;

	/*
	 * insert server code here
	 */
	wCache = mapCacheType2Cache(cacheType);

	CacheGetLocks(wCache, LOCK_READ, LOCK_BLOCK);
	num_items = wCache->nitems;
	buf = malloc(sizeof(CacheTableInfo)*num_items);

	n = 0;
	info = CacheGetFirst(wCache);
	while (info)
	{
		memcpy(&buf[n], info, sizeof(CacheTableInfo));

		switch (cacheType)
		{
			case REG_CACHE: 
			case GW_CACHE:
				info = CacheGetNext(wCache, &info->data);
				break;

			case PHONE_CACHE:
				info = CacheGetNext(wCache, info->data.phone);
				break;

			case VPN_PHONE_CACHE:
				info = CacheGetNext(wCache, info->data.vpnPhone);
				break;

			case IP_CACHE:
				realmip.ipaddress = info->data.ipaddress.l;
				realmip.realmId = info->data.realmId;
				info = CacheGetNext(wCache, &realmip);
				break;

			case SUBNET_CACHE:
				info = CacheGetNext(wCache, &info->data.subnetip);
				break;
			
			case URI_CACHE:
				info = CacheGetNext(wCache, info->data.uri);
				break;

			case REGID_CACHE:
				info = CacheGetNext(wCache, info->data.regid);
				break;

			case EMAIL_CACHE:
				info = CacheGetNext(wCache, info->data.email);
				break;

            case H323ID_CACHE:
				info = CacheGetNext(wCache, info->data.h323id);
				break;

            case CRID_CACHE:
				info = CacheGetNext(wCache, &info->data.crId);
				break;

            case TG_CACHE:
				info = CacheGetNext(wCache, &info->data.tg);
				break;
			default:
				info = NULL;
				break;
		}
		n++;
	}
	CacheReleaseLocks(wCache);

	result.CacheTableInfo_va_val = buf;
	result.CacheTableInfo_va_len = n;

	return (&result);
}

CacheTableInfo *
cli_handle_get_iedge_longest_match_1(rmsub, rqstp)
	RealmSubnet *rmsub;
	struct svc_req *rqstp;
{
	static CacheTableInfo  result;
	CacheTableInfo		*iedge;

	iedge = GetIedgeLongestMatch(rmsub);
	if (iedge)
	{
		memset(&result, 0, sizeof(CacheTableInfo));
		memcpy(&result, iedge, sizeof(CacheTableInfo));
	}
	else
	{
		memset(&result, 0, sizeof(CacheTableInfo));
	}
	return (&result);
}


CacheGkInfo_va *
cli_handle_gk_get_bulk_1(rqstp)
	struct svc_req *rqstp;
{
	static CacheGkInfo_va  result={0};
	CacheGkInfo	*info=NULL, *buf =NULL;
	int		num_items=0;
	int		n;

	n = 0;
	CacheGetLocks(gkCache, LOCK_READ, LOCK_BLOCK);

	num_items = gkCache->nitems;
	buf = malloc(sizeof(CacheGkInfo)*num_items);

	info = CacheGetFirst(gkCache);
	while (info)
	{
		memcpy(&buf[n], info, sizeof(CacheTableInfo));
		n++;
		info = CacheGetNext(gkCache, info->regid);
	}
	CacheReleaseLocks(gkCache);

	result.CacheGkInfo_va_val = buf;
	result.CacheGkInfo_va_len = n;

	return (&result);
}

CacheRealmEntry_va *
cli_handle_realm_get_bulk_1(rqstp)
	struct svc_req *rqstp;
{
	static CacheRealmEntry_va  result={0};
	CacheRealmEntry  *realm=NULL, *buf=NULL; 
	int		n=0, num_items=0;

	CacheGetLocks(realmCache, LOCK_READ, LOCK_BLOCK);

	num_items = realmCache->nitems;
	buf = malloc(sizeof(CacheRealmEntry)*num_items);

	realm = CacheGetFirst(realmCache);
	while (realm)
	{
		memcpy(&buf[n], realm, sizeof(CacheRealmEntry));
		n++;
		realm = CacheGetNext(realmCache, &realm->realm.realmId);
	}
	CacheReleaseLocks(realmCache);
	
	result.CacheRealmEntry_va_len = n;
	result.CacheRealmEntry_va_val = buf;
	
	return (&result);
}

char **
cli_handle_check_rsa_dup_1(new, old, rqstp)
	RealmEntry	*new;
	RealmEntry	*old;
	struct svc_req *rqstp;
{
	static char	*errstr=NULL;
	int			rc=0;

	errstr = malloc (128);
	memset(errstr, 0, 128);

	rc = CheckRSA(NULL, new, old, errstr);
	if (!rc)
	{
		errstr[0] = '0';
	}

	return (&errstr);
}

int *
cli_handle_realm_enable_sig_1(rsa, rqstp)
	u_long rsa;
	struct svc_req *rqstp;
{
	static int  result=TRUE;
	CacheRealmEntry		*realm;

	CacheGetLocks(realmCache, LOCK_WRITE, LOCK_BLOCK);
	realm =  CacheGet(rsaCache, &rsa);
	if (realm)
	{
		realm->realm.adminStatus = 1;
	}
	else
	{
		CacheReleaseLocks(realmCache);
		return (&result);
	}
	CacheReleaseLocks(realmCache);

	if(realm)
	{
		UH323RealmReconfig(rsa);
		SipRealmReconfig(rsa);
	}
	return (&result);
}

int *
cli_handle_realm_disable_sig_1(rsa, rqstp)
	u_long rsa;
	struct svc_req *rqstp;
{
	static int  result=TRUE;
	CacheRealmEntry		*realm;

	CacheGetLocks(realmCache, LOCK_WRITE, LOCK_BLOCK);
	realm =  CacheGet(rsaCache, &rsa);
	if (realm)
	{
		realm->realm.adminStatus = 0;
	}
	else
	{
		CacheReleaseLocks(realmCache);
		return (&result);
	}
	CacheReleaseLocks(realmCache);

	if(realm)
	{
		UH323RealmReconfig(rsa);
		SipRealmReconfig(rsa);
	}
	return (&result);
}

int *
cli_handle_check_realmid_dup_1(realmid, rqstp)
	u_long realmid;
	struct svc_req *rqstp;
{
	static int  result;

	/*
	 * insert server code here
	 */

	return (&result);
}

CacheIgrpInfo_va *
cli_handle_igrp_get_bulk_1(rqstp)
	struct svc_req *rqstp;
{
	static CacheIgrpInfo_va  result;
	CacheIgrpInfo	*igrp=NULL, *buf=NULL;
	int		n=0, num_items =0;

	CacheGetLocks(igrpCache, LOCK_READ, LOCK_BLOCK);

	num_items = igrpCache->nitems;
	buf = malloc(sizeof(CacheIgrpInfo)*num_items);

	igrp = CacheGetFirst(igrpCache);
	while (igrp)
	{
		memcpy(&buf[n], igrp, sizeof(CacheIgrpInfo));
		n++;
		igrp = CacheGetNext(igrpCache, igrp->igrp.igrpName);
	}
	CacheReleaseLocks(igrpCache);

	result.CacheIgrpInfo_va_len = n;
	result.CacheIgrpInfo_va_val = buf;

	return (&result);
}

CacheTriggerEntry_va *
cli_handle_trigger_get_bulk_1(rqstp)
	struct svc_req *rqstp;
{
	static CacheTriggerEntry_va  result;
	CacheTriggerEntry	*trigger, *buf=NULL;	
	int		n=0, num_items=0;

	CacheGetLocks(triggerCache, LOCK_READ, LOCK_BLOCK);

	num_items = triggerCache->nitems;
	buf = malloc(sizeof(CacheTriggerEntry)*num_items);

	trigger = CacheGetFirst(triggerCache);
	while (trigger)
	{
		memcpy(&buf[n], trigger, sizeof(CacheTriggerEntry));
		n++;
		trigger = CacheGetNext(triggerCache, &trigger->trigger.event);
	}
	CacheReleaseLocks(triggerCache);

	result.CacheTriggerEntry_va_len = n;
	result.CacheTriggerEntry_va_val = buf;

	return (&result);
}

int *
cli_handle_igrp_add_calls_1(igrpname, incalls, outcalls, totalcalls, rqstp)
	char *igrpname;
	u_int incalls;
	u_int outcalls;
	u_int totalcalls;
	struct svc_req *rqstp;
{
	static int  result;
	result = IgrpAddCalls(igrpname, incalls, outcalls, totalcalls);
	return (&result);
}

int *
cli_handle_igrp_delete_calls_1(igrpname, incalls, outcalls, totalcalls, rqstp)
	char *igrpname;
	u_int incalls;
	u_int outcalls;
	u_int totalcalls;
	struct svc_req *rqstp;
{
	static int  result=TRUE;
	result = IgrpDeleteCalls(igrpname, incalls, outcalls, totalcalls);
	return (&result);
}

int *
cli_cache_handle_vpn_1(vpnEntry, op, rqstp)
	VpnEntry *vpnEntry;
	int op;
	struct svc_req *rqstp;
{
	static int  result;
	result = CacheHandleVpn(vpnEntry, op);
	return (&result);
}

int *
cli_cache_handle_vpng_1(vpnGroupEntry, op, rqstp)
	VpnGroupEntry *vpnGroupEntry;
	int op;
	struct svc_req *rqstp;
{
	static int  result;
	result = CacheHandleVpnG(vpnGroupEntry, op);
	return (&result);
}

int *
cli_cache_handle_cr_1(routeEntry, op, rqstp)
	VpnRouteEntry *routeEntry;
	int op;
	struct svc_req *rqstp;
{
	static int  result;
	result = CacheHandleCR(routeEntry, op);
	return (&result);
}

int *
cli_cache_handle_cp_1(cpEntry, op, rqstp)
	CallPlanEntry *cpEntry;
	int op;
	struct svc_req *rqstp;
{
	static int  result;
	result = CacheHandleCP(cpEntry, op);
	return (&result);
}

int *
cli_cache_handle_cpb_1(cpbEntry, op, rqstp)
	CallPlanBindEntry *cpbEntry;
	int op;
	struct svc_req *rqstp;
{
	static int  result;
	result = CacheHandleCPB(cpbEntry,op);
	return (&result);
}

int *
cli_cache_handle_trigger_1(tgEntry, op, rqstp)
	TriggerEntry *tgEntry;
	int op;
	struct svc_req *rqstp;
{
	static int result;

	result = CacheHandleTrigger(tgEntry, op);
	return (&result);
}

int *
cli_cache_handle_realm_1(entry, op, rqstp)
	RealmEntry *entry;
	int op;
	struct svc_req *rqstp;
{
	static int result;

	result = CacheHandleRealm(entry, op);
	return (&result);
}

int *
cli_cache_handle_igrp_1(entry, op, rqstp)
	IgrpInfo *entry;
	int op;
	struct svc_req *rqstp;
{
	static int result;

	result = CacheHandleIgrp(entry, op);
	return (&result);
}

int *
cli_handle_iedge_cache_pop_1(flags, rqstp)
	int flags;
	struct svc_req *rqstp;
{
	static int  result=TRUE;
	result = IedgeCachePopulate(lsMem, NULL, flags);
	return (&result);
}

int *
cli_handle_vpn_cache_pop_1(flags, rqstp)
	int flags;
	struct svc_req *rqstp;
{
	static int  result;
	result = VpnPopulate(lsMem, NULL);
	return (&result);
}

int *
cli_handle_vpng_cache_pop_1(flags, rqstp)
	int flags;
	struct svc_req *rqstp;
{
	static int  result;
	result = VpnGPopulate(lsMem, NULL);
	return (&result);
}

int *
cli_handle_cp_cache_pop_1(flags, rqstp)
	int flags;
	struct svc_req *rqstp;
{
	static int  result;
	result = CPPopulate(lsMem, NULL);
	return (&result);
}

int *
cli_handle_cr_cache_pop_1(flags, rqstp)
	int flags;
	struct svc_req *rqstp;
{
	static int  result;

	/*
	 * insert server code here
	 */

	return (&result);
}

int *
cli_handle_cpb_cache_pop_1(flags, rqstp)
	int flags;
	struct svc_req *rqstp;
{
	static int  result;
	result = CPBPopulate(lsMem, NULL);
	return (&result);
}

int *
cli_handle_trigger_cache_pop_1(flags, rqstp)
	int flags;
	struct svc_req *rqstp;
{
	static int  result;
	result = TriggerPopulate(lsMem, NULL);
	return (&result);
}

int *
cli_handle_realm_cache_pop_1(flags, rqstp)
	int flags;
	struct svc_req *rqstp;
{
	static int  result;
	result = RealmPopulate(lsMem, NULL);
	return (&result);
}

int *
cli_handle_igrp_cache_pop_1(flags, rqstp)
	int flags;
	struct svc_req *rqstp;
{
	static int  result;
	result = IgrpPopulate(lsMem, NULL);
	return (&result);
}

int *
cli_license_init_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	result = license_init();
	return (&result);
}

int *
cli_license_allocate_1(n, rqstp)
	int n;
	struct svc_req *rqstp;
{
	static int  result;
	result = license_allocate(n);
	return (&result);
}

int *
cli_license_release_1(n, rqstp)
	int n;
	struct svc_req *rqstp;
{
	static int  result;
	result = license_release(n);
	return (&result);
}

int *
cli_get_lsmem_usedlic_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	result = lsMem->usedlic;
	return (&result);
}

int *
cli_get_lsmem_numlic_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	result = lsMem->nlic;
	return (&result);
}

int *
cli_get_lsmem_maxcalls_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	result = lsMem->maxCalls;
	return (&result);
}

int *
cli_get_lsmem_maxmrcalls_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	result = lsMem->maxMRCalls;
	return (&result);
}

int *
cli_nlm_init_config_port_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	result = nlm_initConfigPort();
	return (&result);
}

int *
cli_nlm_get_config_port_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	result = nlm_getconfigport();
	return (&result);
}

int *
cli_nlm_set_config_port_1(n, rqstp)
	int n;
	struct svc_req *rqstp;
{
	static int  result;
	nlm_setconfigport(n);
	return (&result);
}

int *
cli_nlm_get_vport_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	result = nlm_getvport();
	return (&result);
}

int *
cli_nlm_get_usedvport_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	result = nlm_getUsedvport();
	return (&result);
}

int *
cli_nlm_get_usedvport_nolock_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	result = nlm_getUsedvportNolock();
	return (&result);
}

int *
cli_nlm_get_mrvport_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	result = nlm_getMRvport();
	return (&result);
}

int *
cli_nlm_get_usedmrvport_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	/*   */
	return (&result);
}

int *
cli_nlm_get_usedmrvport_nolock_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	result = nlm_getUsedMRvportNolock();
	return (&result);
}

int *
cli_nlm_free_mrvport_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	result = nlm_freeMRvport();
	return (&result);
}

char **
cli_nlm_get_featurelist_1(rqstp)
	struct svc_req *rqstp;
{
	static char * result;

	/*
	 * insert server code here
	 */

	return (&result);
}

int *
cli_sip_enabled_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	result = sipEnabled();
	return (&result);
}

int *
cli_fce_enabled_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	result = fceEnabled();
	return (&result);
}

int *
cli_radius_enabled_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	result = radiusEnabled();
	return (&result);
}

int *
cli_h323_enabled_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	result = h323Enabled();
	return (&result);
}

int *
cli_gen_enabled_1(rqstp)
	struct svc_req *rqstp;
{
	static int  result;
	result = genEnabled();
	return (&result);
}

str_va *
cli_handle_test_cache_1(argv0, rqstp)
	char *argv0;
	struct svc_req *rqstp;
{
	static str_va  prnbuf={0};
	static char_va lines[1024]={0};
	char	line[128]={0};
	int		i=0;
	CfgParms *cfgParms;
	
	sprintf(line, "Last process to hold locks was %d\n", regCache->lock->pid);
	prnbuf_addline(lines, line, &i);
	sprintf(line, "testing regCache locks: ");
	prnbuf_addline(lines, line, &i);

	/* Test the caches */
	if (CacheGetLocks(regCache, LOCK_WRITE, LOCK_TRY) < 0)
	{
		sprintf(line, "error.\n");
		prnbuf_addline(lines, line, &i);
	}
	else
	{
		sprintf(line, "success.\n");
		prnbuf_addline(lines, line, &i);
		sprintf(line, "regCache has %d items.\n", regCache->nitems);
		prnbuf_addline(lines, line, &i);
		sprintf(line, "regidCache has %d items.\n", regidCache->nitems);
		prnbuf_addline(lines, line, &i);
		sprintf(line, "phoneCache has %d items.\n", phoneCache->nitems);
		prnbuf_addline(lines, line, &i);
		sprintf(line, "gwCache has %d items.\n", gwCache->nitems);
		prnbuf_addline(lines, line, &i);
		sprintf(line, "ipCache has %d items.\n", ipCache->nitems);
		prnbuf_addline(lines, line, &i);
		sprintf(line, "gkCache has %d items.\n", gkCache->nitems);
		prnbuf_addline(lines, line, &i);
		sprintf(line, "h323idCache has %d items.\n", h323idCache->nitems);
		prnbuf_addline(lines, line, &i);
		sprintf(line, "uriCache has %d items.\n", uriCache->nitems);
		prnbuf_addline(lines, line, &i);
		sprintf(line, "gwcpCache has %d items.\n", gwcpCache->nitems);
		prnbuf_addline(lines, line, &i);
		sprintf(line, "subnetCache has %d items.\n", subnetCache->nitems);
		prnbuf_addline(lines, line, &i);
		sprintf(line, "cridCache has %d items.\n", cridCache->nitems);
		prnbuf_addline(lines, line, &i);

		CacheReleaseLocks(regCache);
	}

	sprintf(line, "Last process to hold locks was %d\n", vpnCache->lock->pid);
	prnbuf_addline(lines, line, &i);
	sprintf(line, "testing vpnCache locks: ");
	prnbuf_addline(lines, line, &i);
	if (CacheGetLocks(vpnCache, LOCK_WRITE, LOCK_TRY) < 0)
	{
		sprintf(line, "error.\n");
		prnbuf_addline(lines, line, &i);
	}
	else
	{
		sprintf(line, "success. Cache has %d items\n", vpnCache->nitems);
		prnbuf_addline(lines, line, &i);
		CacheReleaseLocks(vpnCache);
	}

	sprintf(line, "Last process to hold locks was %d\n", vpnGCache->lock->pid);
	prnbuf_addline(lines, line, &i);
	sprintf(line, "testing vpnGCache locks: ");
	prnbuf_addline(lines, line, &i);
	if (CacheGetLocks(vpnGCache, LOCK_WRITE, LOCK_TRY) < 0)
	{
		sprintf(line, "error.\n");
		prnbuf_addline(lines, line, &i);
	}
	else
	{
		sprintf(line, "success. Cache has %d items\n", vpnGCache->nitems);
		prnbuf_addline(lines, line, &i);
		CacheReleaseLocks(vpnGCache);
	}

	sprintf(line, "Last process to hold locks was %d\n", confCache->lock->pid);
	prnbuf_addline(lines, line, &i);
	sprintf(line, "testing confCache locks: ");
	prnbuf_addline(lines, line, &i);
	if (CacheGetLocks(confCache, LOCK_WRITE, LOCK_TRY) < 0)
	{
		sprintf(line, "error.\n");
		prnbuf_addline(lines, line, &i);
	}
	else
	{
		sprintf(line, "success. Cache has %d items\n", confCache->nitems);
		prnbuf_addline(lines, line, &i);
		CacheReleaseLocks(confCache);
	}

	sprintf(line, "Last process to hold locks was %d\n", callCache->lock->pid);
	prnbuf_addline(lines, line, &i);
	sprintf(line, "testing callCache locks: ");
	prnbuf_addline(lines, line, &i);
	if (CacheGetLocks(callCache, LOCK_WRITE, LOCK_TRY) < 0)
	{
		sprintf(line, "error.\n");
		prnbuf_addline(lines, line, &i);
	}
	else
	{
		sprintf(line, "success. Cache has %d items\n", callCache->nitems);
		prnbuf_addline(lines, line, &i);
		CacheReleaseLocks(callCache);
	}

	sprintf(line, "Last process to hold locks was %d\n", cpCache->lock->pid);
	prnbuf_addline(lines, line, &i);
	sprintf(line, "testing cpCache locks: ");
	prnbuf_addline(lines, line, &i);
	if (CacheGetLocks(cpCache, LOCK_WRITE, LOCK_TRY) < 0)
	{
		sprintf(line, "error.\n");
		prnbuf_addline(lines, line, &i);
	}
	else
	{
		sprintf(line, "success. Cache has %d items\n", cpCache->nitems);
		prnbuf_addline(lines, line, &i);
		CacheReleaseLocks(cpCache);
	}

	sprintf(line, "Last process to hold locks was %d\n", cpbCache->lock->pid);
	prnbuf_addline(lines, line, &i);
	sprintf(line, "testing cpbCache locks: ");
	prnbuf_addline(lines, line, &i);
	if (CacheGetLocks(cpbCache, LOCK_WRITE, LOCK_TRY) < 0)
	{
		sprintf(line, "error.\n");
		prnbuf_addline(lines, line, &i);
	}
	else
	{
		sprintf(line, "success. Cache has %d items\n", cpbCache->nitems);
		prnbuf_addline(lines, line, &i);
		CacheReleaseLocks(cpbCache);
	}

	// Cannot read off these locks or the TSM cache.
	// as it is stored in local memory
	//if (CacheGetLocks(transCache, LOCK_WRITE, LOCK_TRY) < 0)
	//{
	//	fprintf(stdout, "TSM Cache lock failed\n");
	//	fprintf(stdout, "Last process to hold locks was %d\n",
	//		transCache->pid);
	//}
	//else
	//{
	//	fprintf(stdout, "TSM cache has %d items\n", transCache->nitems);
	//	CacheReleaseLocks(transCache);
	//}

#if 0
	/* Test the updates cache also */
	if (MemGetRwLock(&lsMem->updatemutex, LOCK_WRITE, LOCK_TRY) != AL_OK)
	{
		fprintf(stdout, "update cache lock failed\n");
	}
	else
	{
		MemReleaseRwLock(&lsMem->updatemutex);
	}

	/* Test the updates cache also */
	if (MemGetRwLock(&lsMem->cpmutex, LOCK_WRITE, LOCK_TRY) != AL_OK)
	{
		fprintf(stdout, "cp cache lock failed\n");
	}
	else
	{
		MemReleaseRwLock(&lsMem->cpmutex);
	}

	/* Test the updates cache also */
	if (MemGetRwLock(&lsMem->cpbmutex, LOCK_WRITE, LOCK_TRY) != AL_OK)
	{
		fprintf(stdout, "cpb cache lock failed\n");
	}
	else
	{
		MemReleaseRwLock(&lsMem->cpbmutex);
	}

	/* Test the updates cache also */
	if (MemGetRwLock(&lsMem->callmutex, LOCK_WRITE, LOCK_TRY) != AL_OK)
	{
		fprintf(stdout, "call cache lock failed\n");
	}
	else
	{
		MemReleaseRwLock(&lsMem->callmutex);
	}

	/* Test the updates cache also */
	if (MemGetRwLock(&lsMem->confmutex, LOCK_WRITE, LOCK_TRY) != AL_OK)
	{
		fprintf(stdout, "conf cache lock failed\n");
	}
	else
	{
		MemReleaseRwLock(&lsMem->confmutex);
	}
#endif
	
	cfgParms = lsMem->cfgParms;
	if (cfgParms)
	{
		sprintf(line, "allowSrcAll = %d\n", cfgParms->allowSrcAll);
		prnbuf_addline(lines, line, &i);
		sprintf(line, "allowDestAll = %d\n", cfgParms->allowDestAll);
		prnbuf_addline(lines, line, &i);
		sprintf(line, "cacheTimeout = %d\n", cfgParms->cacheTimeout);
		prnbuf_addline(lines, line, &i);
		sprintf(line, "RSDConfig = %d\n", cfgParms->RSDConfig);
		prnbuf_addline(lines, line, &i);
		sprintf(line, "allowHairPin = %d\n", cfgParms->allowHairPin);
		prnbuf_addline(lines, line, &i);
	}

#if 0
	printf("doing block test for shared memory blocks\n");
	SHM_MallocBlockTest();
	printf("block test done\n");
#endif

    sprintf(line, "Test completed\n");
	prnbuf_addline(lines, line, &i);

	prnbuf.str_va_len = i;
	prnbuf.str_va_val = lines;
	return (&prnbuf);
}

void
prnbuf_addline(char_va *para, char *s, int *index)
{
	int len =strlen(s);
	char	*tmp;

	if (len)
	{
		para[*index].char_va_len = len;
		tmp = malloc(len+1);
		memset(tmp, '\0' , len+1);
		strncpy(tmp, s, len+1);
		para[*index].char_va_val  = tmp;
		(*index)++;
	}
}


int *
cli_handle_vpn_sipdomain_change_1(vpn, rqstp)
	VpnEntry *vpn;
	struct svc_req *rqstp;
{
	static int  result=TRUE;
	HandleVpnSipDomainChange(vpn);
	return (&result);
}

int *
cli_handle_vpn_prefix_change_1(vpn, rqstp)
	VpnEntry *vpn;
	struct svc_req *rqstp;
{
	static int  result=TRUE;
	HandleVpnPrefixChange(vpn);
	return (&result);
}

int *
cli_handle_mem_age_iedges_in_vpngs_1(vpng1, vpng2, rqstp)
	char *vpng1;
	char *vpng2;
	struct svc_req *rqstp;
{
	static int  result;
	MemAgeIedgesInVpnGs(vpng1, vpng2);
	return (&result);
}

CacheVpnEntry_va *
cli_handle_vpn_get_bulk_1(rqstp)
	struct svc_req *rqstp;
{
	static CacheVpnEntry_va  result;
	CacheVpnEntry	*vpn , *buf=NULL;	
	int		n=0, num_items=0;

	CacheGetLocks(vpnCache, LOCK_READ, LOCK_BLOCK);

	num_items = vpnCache->nitems;
	buf = malloc(sizeof(CacheVpnEntry)*num_items);

	vpn = CacheGetFirst(vpnCache);
	while (vpn)
	{
		memcpy(&buf[n], vpn, sizeof(CacheVpnEntry));
		n++;
		vpn = CacheGetNext(vpnCache, &vpn->vpnEntry);
	}
	CacheReleaseLocks(vpnCache);

	result.CacheVpnEntry_va_len = n;
	result.CacheVpnEntry_va_val = buf;

	return (&result);
}

CacheVpnGEntry_va *
cli_handle_vpng_get_bulk_1(rqstp)
	struct svc_req *rqstp;
{
	static CacheVpnGEntry_va  result;
	CacheVpnGEntry	*vpng, *buf=NULL;	
	int		n=0, num_items=0;

	CacheGetLocks(vpnGCache, LOCK_READ, LOCK_BLOCK);

	num_items = vpnGCache->nitems;
	buf = malloc(sizeof(CacheVpnGEntry)*num_items);

	vpng = CacheGetFirst(vpnGCache);
	while (vpng)
	{
		memcpy(&buf[n], vpng, sizeof(CacheVpnGEntry));
		n++;
		vpng = CacheGetNext(vpnGCache, &vpng->vpnGroupEntry);
	}
	CacheReleaseLocks(vpnGCache);

	result.CacheVpnGEntry_va_len = n;
	result.CacheVpnGEntry_va_val = buf;

	return (&result);
}

CacheCPBEntry_va *
cli_handle_cp_get_bulk_1(rqstp)
	struct svc_req *rqstp;
{
	static CacheCPBEntry_va  result;
	CacheCPBEntry	*cp, *buf=NULL;	
	int		n=0, num_items=0;

	CacheGetLocks(cpbCache, LOCK_READ, LOCK_BLOCK);

	num_items = cpbCache->nitems;
	buf = malloc(sizeof(CacheCPBEntry)*num_items);

	cp = CacheGetFirst(cpbCache);
	while (cp)
	{
		memcpy(&buf[n], cp, sizeof(CacheCPBEntry));
		n++;
		cp = CacheGetNext(cpbCache, &cp->cpbEntry);
	}
	CacheReleaseLocks(cpbCache);

	result.CacheCPBEntry_va_len = n;
	result.CacheCPBEntry_va_val = buf;

	return (&result);
}

CacheCREntry_va *
cli_handle_cr_get_bulk_1(rqstp)
	struct svc_req *rqstp;
{
	static CacheCREntry_va  result;
	CacheRouteEntry	*cr, *buf=NULL;	
	int		n=0, num_items=0;

	CacheGetLocks(cpCache, LOCK_READ, LOCK_BLOCK);

	num_items = cpCache->nitems;
	buf = malloc(sizeof(CacheRouteEntry)*num_items);

	cr = CacheGetFirst(cpCache);
	while (cr)
	{
		memcpy(&buf[n], cr, sizeof(CacheRouteEntry));
		n++;
		cp = CacheGetNext(cpCache, &cr->cacheRouteEntry);
	}
	CacheReleaseLocks(cpCache);

	result.CacheRouteEntry_va_len = n;
	result.CacheRouteEntry_va_val = buf;

	return (&result);
}

/* BBBBBBBBBB */
CacheEntryGeneric *
cli_cache_getnext_1(cacheType, data, rqstp)
	int cacheType;
	CacheKey data;
	struct svc_req *rqstp;
{
	static CacheEntryGeneric  result;

	/*
	 * insert server code here
	 */

	return (&result);
}

CacheEntryGeneric *
cli_cache_getfirst_1(cacheType, rqstp)
	int cacheType;
	struct svc_req *rqstp;
{
	static CacheEntryGeneric  result;

	/*
	 * insert server code here
	 */

	return (&result);
}

CacheEntryGeneric *
cli_cache_delete_1(cacheType, data, rqstp)
	int cacheType;
	CacheEntryGeneric data;
	struct svc_req *rqstp;
{
	static CacheEntryGeneric  result;

	/*
	 * insert server code here
	 */

	return (&result);
}

int *
cli_cache_remove_1(cacheType, data, rqstp)
	int cacheType;
	CacheEntryGeneric data;
	struct svc_req *rqstp;
{
	static int  result;

	/*
	 * insert server code here
	 */

	return (&result);
}
