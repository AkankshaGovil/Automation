package com.nextone.common;

import java.io.*;
import java.net.*;
import java.util.*;
import java.text.SimpleDateFormat;
import com.nextone.util.LimitedDataInputStream;
import com.nextone.util.IPAddress;
import com.nextone.util.IPUtil;
import com.nextone.util.SysUtil;


/**
 * this class implements methods to get an iEdge 500/510's configuration
 * from the device
 */
public class ConfigFile500Impl implements ConfigProvider {
	  private Registration reg;
	  private ConfigRetriever cr;

	  /**
	   * @param reg the registration method received from the iedge we
	   * are interested to get the configuration from
	   */
	  ConfigFile500Impl (Registration reg, ConfigRetriever cr) {
		 this.reg = reg;
		 this.cr = cr;
	  }

	  // some header in the file
	  private String getHeaderInfo () {
		 StringBuffer sb = new StringBuffer();
//		 sb.append("#\n# Generated by " + Constants.VERSION + "\n");
		 sb.append("# ");
		 sb.append(new SimpleDateFormat("EEE MMM dd hh:mm:ssa yyyy z").format(new Date()));
		 sb.append("\n# ");
		 sb.append(CommonConstants.SIGNATURE);
		 sb.append(reg.getDeviceId());
		 sb.append(CommonConstants.SIGNATURE);
		 sb.append("\n#\n");
		 sb.append("set registration_id ");
		 sb.append(reg.getRegId());
		 sb.append("\nset security_mode off\n");
		 return sb.toString();
	  }

	  // information we don't care about right now, set them to erase
	  private String getStaleInfo () {
		 String [] eraseable = {
			"account_information",
			"admin_status",
			"config_date",
			"firmware_version",
			"log_server_address",
			"ports",
			"service_provider_name",
			"software_version",
		 };

		 StringBuffer sb = new StringBuffer();
		 for (int i = 0; i < eraseable.length; i++) {
			sb.append("erase ");
			sb.append(eraseable[i]);
			sb.append("\n");
		 }

		 return sb.toString();
	  }

	  private class AccessControlData implements DataConsumer {
			private String adminPass, userName, userPass;
			private boolean success;

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   short code = dis.readShort();
			   if (code != CommonConstants.ACCESS_CONTROL) {
				  throw new IOException("Expected return code " + CommonConstants.ACCESS_CONTROL + ", received " + code);
			   }

			   adminPass = dis.readUTF();
			   userName = dis.readUTF();
			   userPass = dis.readUTF();

			   success = true;
			}

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   if (adminPass.equals(""))
				  sb.append("erase admin_password\n");
			   else
				  sb.append("set admin_password " + adminPass + "\n");
			   if (userName.equals(""))
				  sb.append("erase user_name\n");
			   else
				  sb.append("set user_name " + userName + "\n");
			   if (userPass.equals(""))
				  sb.append("erase user_password\n");
			   else
				  sb.append("set user_password " + userPass + "\n");

			   return sb.toString();
			}
	  }

	  private String getAccessControlConfig () throws IOException {
		 try {
			AccessControlData acd = new AccessControlData();
			boolean ret = cr.retrieve(CommonConstants.ACCESS_CONTROL, acd);
			if (ret == true)
			   return acd.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting Access Control Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  private class DataVpnData implements DataConsumer {
			private int numEntries;
			private Vector peer, ip, mask;
			private boolean success, isEnabled;

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   short code = dis.readShort();
			   if (code != CommonConstants.DATA_VPN) {
				  throw new IOException("Expected return code " + CommonConstants.DATA_VPN + ", received " + code);
			   }

			   numEntries = dis.readShort();
			   if (numEntries > 10 | numEntries < 0)
				  throw new IOException("Invalid number of Data VPN entries received - " + numEntries);

			   peer = new Vector(numEntries);
			   ip = new Vector(numEntries);
			   mask = new Vector(numEntries);
			   for (int i = 0; i < numEntries; i++) {
				  peer.add(IPUtil.ipStringFromStream(dis));
				  ip.add(IPUtil.ipStringFromStream(dis));
				  mask.add(IPUtil.ipStringFromStream(dis));
			   }

			   short ef = dis.readShort();
			   if (ef == 1)
				  isEnabled = true;
			   else
				  isEnabled = false;

			   success = true;
			}

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   sb.append("set data_vpn delete all\n");
			   for (int i = 0; i < numEntries; i++)
				  sb.append("set data_vpn " + (String)peer.get(i) + " " + (String)ip.get(i)+ " " + (String)mask.get(i) + "\n");
			   sb.append("set data_vpn ");
 			   if (isEnabled)
				  sb.append("on\n");
			   else
				  sb.append("off\n");

			   return sb.toString();
			}
	  }

	  private String getDataVpnConfig () throws IOException {
		 try {
			DataVpnData dvd = new DataVpnData();
			boolean ret = cr.retrieve(CommonConstants.DATA_VPN, dvd);
			if (ret == true)
			   return dvd.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting Data VPN Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  private class DhcpRelayData implements DataConsumer {
			private String primary, secondary;
			private boolean success;

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   short code = dis.readShort();
			   if (code != CommonConstants.DHCP_RELAY) {
				  throw new IOException("Expected return code " + CommonConstants.DHCP_RELAY + ", received " + code);
			   }
			   primary = IPUtil.ipStringFromStream(dis);
			   secondary = IPUtil.ipStringFromStream(dis);
			   success = true;
			}

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   if (primary.equals("0.0.0.0"))
				  sb.append("erase primary_dhcp_server\n");
			   else
				  sb.append("set primary_dhcp_server " + primary + "\n");
			   if (secondary.equals("0.0.0.0"))
				  sb.append("erase secondary_dhcp_server\n");
			   else
				  sb.append("set secondary_dhcp_server " + secondary + "\n");

			   return sb.toString();
			}
	  }

	  private String getDhcpRelayConfig () throws IOException {
		 try {
			DhcpRelayData drd = new DhcpRelayData();
			boolean ret = cr.retrieve(CommonConstants.DHCP_RELAY, drd);
			if (ret == true)
			   return drd.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting DHCP Relay Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  private class DnsData implements DataConsumer {
			private String primary, secondary, domainName;
			private boolean success;

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   short code = dis.readShort();
			   if (code != CommonConstants.DNS) {
				  throw new IOException("Expected return code " + CommonConstants.DNS + ", received " + code);
			   }
			   primary = IPUtil.ipStringFromStream(dis);
			   secondary = IPUtil.ipStringFromStream(dis);
			   domainName = dis.readUTF();
			   success = true;
			}

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   if (primary.equals("0.0.0.0"))
				  sb.append("erase primary_dns_ip_address\n");
			   else
				  sb.append("set primary_dns_ip_address " + primary + "\n");
			   if (secondary.equals("0.0.0.0"))
				  sb.append("erase secondary_dns_ip_address\n");
			   else
				  sb.append("set secondary_dns_ip_address " + secondary + "\n");
			   if (domainName.equals(""))
				  sb.append("erase fqdn\n");
			   else
				  sb.append("set fqdn " + domainName + "\n");

			   return sb.toString();
			}
	  }

	  private String getDnsConfig () throws IOException {
		 try {
			DnsData dnsd = new DnsData();
			boolean ret = cr.retrieve(CommonConstants.DNS, dnsd);
			if (ret == true)
			   return dnsd.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting DNS Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  private class EthernetData implements DataConsumer {
			private String ip, mask, gw;
			private boolean success, dhcpClient;
			private String dhcpHostname;

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   short code = dis.readShort();
			   if (code != CommonConstants.ETHERNET) {
				  throw new IOException("Expected return code " + CommonConstants.ETHERNET + ", received " + code);
			   }
			   ip = IPUtil.ipStringFromStream(dis);
			   mask = IPUtil.ipStringFromStream(dis);
			   gw = IPUtil.ipStringFromStream(dis);
			   byte dhcp = dis.readByte();
			   if (dhcp == (byte)0x1)
				  dhcpClient = true;
			   else
				  dhcpClient = false;
			   dhcpHostname = dis.readUTF();
			
			   success = true;
			}

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   if (dhcpClient) {
				  sb.append("set dhcp_client enable\n");
			   } else {
				  sb.append("set dhcp_client disable\n");
				  if (ip.equals("0.0.0.0"))
					 sb.append("erase ip_address\n");
				  else
					 sb.append("set ip_address " + ip + "\n");
				  if (mask.equals("0.0.0.0"))
					 sb.append("erase subnet_mask\n");
				  else
					 sb.append("set subnet_mask " + mask + "\n");
				  if (gw.equals("0.0.0.0"))
					 sb.append("erase ip_gateway_address\n");
				  else
					 sb.append("set ip_gateway_address " + gw + "\n");
			   }
			   sb.append("set dhcp_hostname " + dhcpHostname + "\n");

			   return sb.toString();
			}
	  }

	  private String getEthernetConfig () throws IOException {
		 try {
			EthernetData ed = new EthernetData();
			boolean ret = cr.retrieve(CommonConstants.ETHERNET, ed);
			if (ret == true)
			   return ed.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting Ethernet Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  private class H323Data implements DataConsumer {
			private String addrType, pGk, sGk;
			private String voipgw, cCode, aCode, eCode;
			private String id1, id2;
			private String [] validAT = {"discover", "static"};
			private boolean success, isPreferred;

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   short code = dis.readShort();
			   if (code != CommonConstants.H323) {
				  throw new IOException("Expected return code " + CommonConstants.H323 + ", received " + code);
			   }

			   if (dis.readShort() == (short)0x1)
				  isPreferred = true;
			   else
				  isPreferred = false;
			   addrType = validAT[dis.readShort()];
			   pGk = IPUtil.ipStringFromStream(dis);
			   sGk = IPUtil.ipStringFromStream(dis);

			   if (reg.getDeviceId() == CommonConstants.DEVICE_ID_510) {
				  cCode = dis.readUTF();
				  aCode = dis.readUTF();
				  eCode = dis.readUTF();
			   } else {
				  voipgw = IPUtil.ipStringFromStream(dis);
			   }
			   id1 = dis.readUTF();
			   id2 = dis.readUTF();

			   success = true;
			}

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   if (isPreferred)
				  sb.append("set prefer_h323 enable\n");
			   else
				  sb.append("set prefer_h323 disable\n");
			   sb.append("set h323_gatekeeper_addrtype " + addrType + "\n");
			   if (pGk.equals("0.0.0.0"))
				  sb.append("erase h323_primary_gatekeeper_address\n");
			   else
				  sb.append("set h323_primary_gatekeeper_address " + pGk + "\n");
			   if (sGk.equals("0.0.0.0"))
				  sb.append("erase h323_secondary_gatekeeper_address\n");
			   else
				  sb.append("set h323_secondary_gatekeeper_address " + sGk + "\n");
			   if (reg.getDeviceId() == CommonConstants.DEVICE_ID_510) {
				  if (cCode.equals(""))
					 sb.append("erase h323_gateway_countrycode\n");
				  else
					 sb.append("set h323_gateway_countrycode " + cCode + "\n");
				  if (aCode.equals(""))
					 sb.append("erase h323_gateway_areacode\n");
				  else
					 sb.append("set h323_gateway_areacode " + aCode + "\n");
				  if (eCode.equals(""))
					 sb.append("erase h323_gateway_exchangecode\n");
				  else
					 sb.append("set h323_gateway_exchangecode " + eCode + "\n");
			   } else {
				  if (voipgw.equals("0.0.0.0"))
					 sb.append("erase default_voip_router_ip_address\n");
				  else
					 sb.append("set default_voip_router_ip_address " + voipgw + "\n");
			   }
			   if (id1.equals(""))
				  sb.append("erase h323_gatekeeper_id\n");
			   else
				  sb.append("set h323_gatekeeper_id " + id1 + "\n");
			   // secondary gatekeeper id is not supported currently//			   if (id2.equals(""))
//				  sb.append("erase h323_secondary_gatekeeper_id\n");
//			   else
//				  sb.append("set h323_secondary_gatekeeper_id " + id2 + "\n");

			   return sb.toString();
			}
	  }

	  private String getH323Config () throws IOException {
		 try {
			H323Data hd = new H323Data();
			boolean ret = cr.retrieve(CommonConstants.H323, hd);
			if (ret == true)
			   return hd.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting H.323 Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  private class InternetData implements DataConsumer {
			private String method, name, pass, pNo, sNo, dScript, mScript;
			private int baud;
			private boolean success;

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   short code = dis.readShort();
			   if (code != CommonConstants.INTERNET) {
				  throw new IOException("Expected return code " + CommonConstants.INTERNET + ", received " + code);
			   }

			   short acc = dis.readShort();
			   if (acc == CommonConstants.ACCESS_MODEM)
				  method = "modem";
			   else if (acc == CommonConstants.ACCESS_SERIAL)
				  method = "serial port";
			   else
				  method = "ethernet";

			   baud = dis.readInt();
			   name = dis.readUTF();
			   pass = dis.readUTF();
			   pNo = dis.readUTF();
			   sNo = dis.readUTF();
			   dScript = dis.readUTF();
			   mScript = dis.readUTF();

			   success = true;
			}

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   sb.append("set internet_access_port " + method + "\n");
			   if (name.equals(""))
				  sb.append("erase dialup_name\n");
			   else
				  sb.append("set dialup_name " + name + "\n");
			   if (pass.equals(""))
				  sb.append("erase dialup_password\n");
			   else
				  sb.append("set dialup_password " + pass + "\n");
			   if (pNo.equals(""))
				  sb.append("erase primary_dialup_number\n");
			   else
				  sb.append("set primary_dialup_number " + pNo + "\n");
			   if (sNo.equals(""))
				  sb.append("erase secondary_dialup_number\n");
			   else
				  sb.append("set secondary_dialup_number " + sNo + "\n");
			   sb.append("set modem_baud " + baud + "\n");
			   if (dScript.equals(""))
				  sb.append("erase dialup_script\n");
			   else
				  sb.append("set dialup_script " + dScript + "\n");
			   if (mScript.equals(""))
				  sb.append("erase modem_setup_script\n");
			   else
				  sb.append("set modem_setup_script " + mScript + "\n");

			   return sb.toString();
			}
	  }

	  private String getInternetConfig () throws IOException {
		 try {
			InternetData id = new InternetData();
			boolean ret = cr.retrieve(CommonConstants.INTERNET, id);
			if (ret == true)
			   return id.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting Internet Access Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  private class IPFilterData implements DataConsumer {
			private int numEntries;
			private String [] rule, protocol, srcip, srcmask, dstip, dstmask;
			short [] srcps, srcpe, dstps, dstpe;
			private boolean success, isEnabled;
			private String [] ruleStr = {"allow", "deny"};

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   short code = dis.readShort();
			   if (code != CommonConstants.IP_FILTER) {
				  throw new IOException("Expected return code " + CommonConstants.IP_FILTER + ", received " + code);
			   }

			   numEntries = dis.readShort();
			   if (numEntries > 10 | numEntries < 0)
				  throw new IOException("Invalid number of IP filter entries received - " + numEntries);

			   rule = new String [numEntries];
			   protocol = new String [numEntries];
			   srcip = new String [numEntries];
			   srcmask = new String [numEntries];
			   srcps = new short [numEntries];
			   srcpe = new short [numEntries];
			   dstip = new String [numEntries];
			   dstmask = new String [numEntries];
			   dstps = new short [numEntries];
			   dstpe = new short [numEntries];
			   for (int i = 0; i < numEntries; i++) {
				  rule[i] = ruleStr[dis.readShort()-1];
				  protocol[i] = IPUtil.getProtocolString(dis.readShort());
				  srcip[i] = IPUtil.ipStringFromStream(dis);
				  srcmask[i] = IPUtil.ipStringFromStream(dis);
				  srcps[i] = dis.readShort();
				  srcpe[i] = dis.readShort();
				  dstip[i] = IPUtil.ipStringFromStream(dis);
				  dstmask[i] = IPUtil.ipStringFromStream(dis);
				  dstps[i] = dis.readShort();
				  dstpe[i] = dis.readShort();
			   }

			   short ef = dis.readShort();
			   if (ef == 1)
				  isEnabled = true;
			   else
				  isEnabled = false;

			   success = true;
			}

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   sb.append("set ip_filter delete all\n");
			   for (int i = 0; i < numEntries; i++)
				  sb.append("set ip_filter " + rule[i] + " " + protocol[i] + " src " + srcip[i] + " " + srcmask[i] + " " + srcps[i] + " " + srcpe[i] + " dst " + dstip[i] + " " + dstmask[i] + " " + dstps[i] + " " + dstpe[i] + "\n");
			   sb.append("set ip_filter ");
			   if (isEnabled)
				  sb.append("on\n");
			   else
				  sb.append("off\n");

			   return sb.toString();
			}
	  }

	  private String getIPFilterConfig () throws IOException {
		 try {
			IPFilterData ipfd = new IPFilterData();
			boolean ret = cr.retrieve(CommonConstants.IP_FILTER, ipfd);
			if (ret == true)
			   return ipfd.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting IP Filter Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  private class IServerData implements DataConsumer {
			private String primaryIs, secondaryIs;
			private boolean success;

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   short code = dis.readShort();
			   if (code != CommonConstants.ISERVER) {
				  throw new IOException("Expected return code " + CommonConstants.ISERVER + ", received " + code);
			   }
			   String regid = dis.readUTF();  // we ignore this
			   primaryIs = dis.readUTF();
			   secondaryIs = dis.readUTF();
			   success = true;
			}

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   if (primaryIs.equals(""))
				  sb.append("erase iserver_address\n");
			   else
				  sb.append("set iserver_address " + primaryIs + "\n");
			   if (secondaryIs.equals(""))
				  sb.append("erase secondary_iserver_address\n");
			   else
				  sb.append("set secondary_iserver_address " + secondaryIs + "\n");
			   return sb.toString();
			}
	  }

	  private String getIServerConfig () throws IOException {
		 try {
			IServerData isd = new IServerData();
			boolean ret = cr.retrieve(CommonConstants.ISERVER, isd);
			if (ret == true)
			   return isd.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting iServer Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  private class ITSPData implements DataConsumer {
			private int numEntries;
			private byte [] entryStatus;
			private String [] entry;
			private short [] timeout;
			private boolean success;

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   short code = dis.readShort();
			   if (code != CommonConstants.ITSP) {
				  throw new IOException("Expected return code " + CommonConstants.ITSP + ", received " + code);
			   }
			   numEntries = dis.readShort();
			   if (numEntries != (short)0x6)
				  throw new IOException("Invalid number of ITSP entries received - " + numEntries);

			   entryStatus = new byte [numEntries];
			   entry = new String [numEntries];
			   timeout = new short [numEntries];
			   for (int i = 0; i < numEntries; i++) {
				  byte entryNum = dis.readByte();
				  entryStatus[i] = dis.readByte();

				  if (entryStatus[i] == (byte)0x1) {
					 timeout[i] = dis.readShort();
					 entry[i] = dis.readUTF();
				  }
			   }

			   success = true;
			}

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   for (int i = 0; i < numEntries; i++) {
				  if (entryStatus[i] == (byte)0x1) {
					 sb.append("set itsp_dial_entry " + (i+1) + " " + entry[i] + "\n");
					 sb.append("set itsp_dial_timeout " + (i+1) + " " + timeout[i] + "\n");
				  } else {
					 sb.append("erase itsp_dial_entry " + (i+1) + "\n");
					 sb.append("erase itsp_dial_timeout " + (i+1) + "\n");
				  }
			   }

			   return sb.toString();
			}
	  }

	  private String getITSPConfig () throws IOException {
		 try {
			ITSPData itspd = new ITSPData();
			boolean ret = cr.retrieve(CommonConstants.ITSP, itspd);
			if (ret == true)
			   return itspd.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting ITSP Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  private class NatData implements DataConsumer {
			private String ip, mask;
			short tcpto, udpto;
			private boolean success, isEnabled;

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   short code = dis.readShort();
			   if (code != CommonConstants.NAT) {
				  throw new IOException("Expected return code " + CommonConstants.NAT + ", received " + code);
			   }
			   ip = IPUtil.ipStringFromStream(dis);
			   mask = IPUtil.ipStringFromStream(dis);
			   tcpto = dis.readShort();
			   udpto = dis.readShort();
			   if (dis.readByte() == (byte)0x1)
				  isEnabled = true;
			   else
				  isEnabled = false;

			   success = true;
			}

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   if (ip.equals("0.0.0.0"))
				  sb.append("erase nat_ip\n");
			   else
				  sb.append("set nat_ip " + ip + "\n");
			   if (mask.equals("0.0.0.0"))
				  sb.append("erase nat_mask\n");
			   else
				  sb.append("set nat_mask " + mask + "\n");
			   if (tcpto == 0)
				  sb.append("erase nat_tcpto\n");
			   else
				  sb.append("set nat_tcpto " + tcpto + "\n");
			   if (udpto == 0)
				  sb.append("erase nat_udpto\n");
			   else
				  sb.append("set nat_udpto " + udpto + "\n");
			   if (isEnabled)
				  sb.append("set nat enable\n");
			   else
				  sb.append("set nat disable\n");

			   return sb.toString();
			}
	  }

	  private String getNatConfig () throws IOException {
		 try {
			NatData nd = new NatData();
			boolean ret = cr.retrieve(CommonConstants.NAT, nd);
			if (ret == true)
			   return nd.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting NAT Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  private class NatProxyData implements DataConsumer {
			private short numEntries;
			private byte [] entryStatus;
			private String [] protocol, ip;
			private short [] inport, outport;
			private boolean success;

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   short code = dis.readShort();
			   if (code != CommonConstants.NAT_PROXY) {
				  throw new IOException("Expected return code " + CommonConstants.NAT_PROXY + ", received " + code);
			   }

			   numEntries = dis.readShort();
			   if (numEntries != (short)0x5)
				  throw new IOException("Invalid number of NAT Proxy entries received - " + numEntries);

			   entryStatus = new byte [numEntries];
			   protocol = new String [numEntries];
			   ip = new String [numEntries];
			   inport = new short [numEntries];
			   outport = new short [numEntries];
			   for (int i = 0; i < numEntries; i++) {
				  byte entryNum = dis.readByte();
				  entryStatus[i] = dis.readByte();
				  if (entryStatus[i] == (byte)0x1) {
					 protocol[i] = IPUtil.getProtocolString(dis.readShort());
					 ip[i] = IPUtil.ipStringFromStream(dis);
					 inport[i] = dis.readShort();
					 outport[i] = dis.readShort();
				  }
			   }

			   success = true;
			}

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   for (int i = 0; i < numEntries; i++) {
				  if (entryStatus[i] == (byte)0x1)
					 sb.append("set nat_proxy " + (i+1) + " " + protocol[i] + " " + ip[i] + " " + inport[i] + " " + outport[i] + "\n");
				  else
					 sb.append("set nat_proxy " + (i+1) + " delete\n");
			   }

			   return sb.toString();
			}
	  }

	  private String getNatProxyConfig () throws IOException {
		 try {
			NatProxyData npd = new NatProxyData();
			boolean ret = cr.retrieve(CommonConstants.NAT_PROXY, npd);
			if (ret == true)
			   return npd.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting NAT Proxy Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  private class PhonePortData implements DataConsumer {
			private int numEntries;
			private String [] status, type, phone, email, hid;
			private String [] numberType, number;
			private String faxServer;
			private short jitter;
			private boolean success;
			private String [] hybrid;

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   short code = dis.readShort();
			   if (code != CommonConstants.PHONE_PORT) {
				  throw new IOException("Expected return code " + CommonConstants.PHONE_PORT + ", received " + code);
			   }

			   numEntries = dis.readShort();
			   if (numEntries != 3)
				  throw new IOException("Invalid number of Phone port entries received - " + numEntries);

			   status = new String [numEntries];
			   type = new String [numEntries];
			   phone = new String [numEntries];
			   email = new String [numEntries];
			   hid = new String [numEntries];
			   numberType = new String [numEntries];
			   number = new String [numEntries];
			   hybrid = new String [numEntries];
			   for (int i = 0; i < numEntries; i++) {
				  short s = dis.readShort();
				  if (s < 0 || s > 2)
					 s = (short)0;
				  status[i] = CommonConstants.portStatus[s];

				  short t = dis.readShort();
				  if (t < 0 || t > 2)
					 t = (short)3;
				  type[i] = CommonConstants.portType[t];

				  phone[i] = dis.readUTF();
				  email[i] = dis.readUTF();
				  hid[i] = dis.readUTF();

				  short rntype = dis.readShort();
				  if (rntype != CommonConstants.LUS_TYPE &&
					  rntype != CommonConstants.VPN_TYPE) {
					 rntype = (short)CommonConstants.LUS_TYPE;
				  }
				  numberType[i] = CommonConstants.rollType[rntype];
				  number[i] = dis.readUTF();

				  if (i == 2) {
					 faxServer = dis.readUTF();
				  }
			   }

			   jitter = dis.readShort();

			   if (reg.getDeviceId() == CommonConstants.DEVICE_ID_510) {
				  for (int i = 0; i < numEntries; i++) {
					 try {
						hybrid[i] = dis.readUTF();
					 } catch (EOFException ee) {
						hybrid[i] = "";
					 }
				  }
			   }

			   success = true;
			}

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   String rollCmdType = null;
			   String rollCmdNum = null;
			   if (reg.getDeviceId() == CommonConstants.DEVICE_ID_510) {
				  rollCmdType = new String(" auto_attendant_num_type ");
				  rollCmdNum = new String(" auto_attendant_num ");
			   } else {
				  rollCmdType = new String(" rollover_num_type ");
				  rollCmdNum = new String(" rollover_num ");
			   }
			   for (int i = 0; i < numEntries; i++) {
				  sb.append("set port_status " + (i+1) + " " + status[i] + "\n");
				  sb.append("set port_type " + (i+1) + " " + type[i] + "\n");
				  if (phone[i].equals(""))
					 sb.append("erase phone_number " + (i+1) + "\n");
				  else
					 sb.append("set phone_number " + (i+1) + " " + phone[i] + "\n");
				  if (email[i].equals(""))
					 sb.append("erase email_id " + (i+1) + "\n");
				  else
					 sb.append("set email_id " + (i+1) + " " + email[i] + "\n");
				  if (hid[i].equals(""))
					 sb.append("erase h323_id " + (i+1) + "\n");
				  else
					 sb.append("set h323_id " + (i+1) + " " + hid[i] + "\n");
				  sb.append("set" + rollCmdType + (i+1) + " " + numberType[i] + "\n");
				  if (number[i].equals(""))
					 sb.append("erase" + rollCmdNum + (i+1) + "\n");
				  else
					 sb.append("set" + rollCmdNum + (i+1) + " " + number[i] + "\n");
				  if (reg.getDeviceId() == CommonConstants.DEVICE_ID_510) {
					 if (hybrid[i].equals(""))
						sb.append("set hybridtype " + (i+1) + " other\n");
					 else
						sb.append("set hybridtype " + (i+1) + " " + hybrid[i] + "\n");
				  }

				  if (i == 2 &&
					  reg.getDeviceId() == CommonConstants.DEVICE_ID_500) {
					 if (faxServer.equals(""))
						sb.append("erase external_fax_server\n");
					 else
						sb.append("set external_fax_server " + faxServer + "\n");
				  }
			   }
			   sb.append("set jitter " + jitter + "\n");

			   return sb.toString();
			}
	  }

	  private String getPhonePortConfig () throws IOException {
		 try {
			PhonePortData ppd = new PhonePortData();
			boolean ret = cr.retrieve(CommonConstants.PHONE_PORT, ppd);
			if (ret == true)
			   return ppd.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting Phone Port Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  private class PrefixData implements DataConsumer {
//			short pstn, itsp, lus;
			String pstn, itsp, lus, vpn;
			String gw;
			private boolean success;

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   short code = dis.readShort();
			   if (code != CommonConstants.DIAL_PREFIX) {
				  throw new IOException("Expected return code " + CommonConstants.DIAL_PREFIX + ", received " + code);
			   }

			   pstn = SysUtil.convertToString(dis.readShort());
			   itsp = SysUtil.convertToString(dis.readShort());
			   lus = SysUtil.convertToString(dis.readShort());
			   if (reg.getDeviceId() == CommonConstants.DEVICE_ID_510) {
				  gw = dis.readUTF();
			   }
			   try {
				  vpn = SysUtil.convertToString(dis.readShort());
			   } catch (EOFException ee) {}

			   success = true;
			}

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   if (lus.equals(""))
				  sb.append("erase lus_dial_prefix\n");
			   else
				  sb.append("set lus_dial_prefix " + lus + "\n");
			   if (vpn != null) {
				  if (vpn.equals(""))
					 sb.append("erase vpn_dial_prefix\n");
				  else
					 sb.append("set vpn_dial_prefix " + vpn + "\n");
			   }
			   if (reg.getDeviceId() == CommonConstants.DEVICE_ID_500) {
				  if (pstn.equals(""))
					 sb.append("erase pstn_dial_prefix\n");
				  else
					 sb.append("set pstn_dial_prefix " + pstn + "\n");
				  if (itsp.equals(""))
					 sb.append("erase itsp_dial_prefix\n");
				  else
					 sb.append("set itsp_dial_prefix " + itsp + "\n");
			   }
			   if (reg.getDeviceId() == CommonConstants.DEVICE_ID_510) {
				  if (gw.equals(""))
					 sb.append("erase gateway_dial_prefix\n");
				  else
					 sb.append("set gateway_dial_prefix " + gw + "\n");
			   }

			   return sb.toString();
			}
	  }

	  private String getPrefixConfig () throws IOException {
		 try {
			PrefixData pd = new PrefixData();
			boolean ret = cr.retrieve(CommonConstants.DIAL_PREFIX, pd);
			if (ret == true)
			   return pd.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting Dialing Prefix Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  private class LinePortData implements DataConsumer {
			short numPorts;
			String [] status;
			String [] emergencyNumbers;
			boolean [] busyLinePort;
			private boolean success;

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   String []statStr = {"unused","active","debug","unknown"};
			   short code = dis.readShort();
			   if (code != CommonConstants.LINE_PORT) {
				  throw new IOException("Expected return code " + CommonConstants.LINE_PORT + ", received " + code);
			   }

			   numPorts = dis.readShort();
			   if (numPorts != 3)
				  throw new IOException("Invalid number of Line port entries received - " + numPorts);

			   status = new String [numPorts];
			   for (int i = 0; i < numPorts; i++) {
				  short stat = dis.readShort();
				  if (stat < 0 || stat > 2)
					 stat = 0;
				  status[i] = statStr[stat];
			   }

			   if (reg.getDeviceId() == CommonConstants.DEVICE_ID_500) {
				  // Read the emergency numbers
				  emergencyNumbers = new String[CommonConstants.MAX_EMERGENCY_NUMBERS];
				  for (int j=0; j<CommonConstants.MAX_EMERGENCY_NUMBERS; j++) {
					 emergencyNumbers[j] = dis.readUTF();
				  }

				  // 1.1 maintenance addd BusyLineportEnable
				  busyLinePort = new boolean[2];
				  try {
					 busyLinePort[0] = (1 == dis.readUnsignedByte());
					 busyLinePort[1] = (1 == dis.readUnsignedByte());
				  } catch(EOFException eofe) {
					 busyLinePort[0] = false;
					 busyLinePort[1] = false;
				  }
			   }
			   success = true;
			}
      

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   for (int i = 0; i < numPorts; i++)
				  sb.append("set line_port_status " + (i+1) + " " + status[i] + "\n");

			   for (int i = 0; i < CommonConstants.MAX_EMERGENCY_NUMBERS; i++) {
				  if (emergencyNumbers[i].equals("")) {
					 sb.append("erase emergency_number " + (i+1) + "\n");
				  } else {
					 sb.append("set emergency_number " + (i+1) + " " + emergencyNumbers[i] + "\n");
				  }
			   }

			   for (int i = 0; i < 2; i++)
				  sb.append("set busy_lineport_foripcall " + (i+1) + " " + ((busyLinePort[i])?"enable":"disable") + "\n");

			   return sb.toString();
			}
	  }

	  private String getLinePortConfig () throws IOException {
		 try {
			LinePortData lpd = new LinePortData();
			boolean ret = cr.retrieve(CommonConstants.LINE_PORT, lpd);
			if (ret == true)
			   return lpd.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting Line Port Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  private class SoftwareDownloadData implements DataConsumer {
			private String ip, username, password, dir, filename, sfilename;
			private boolean success;

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   short code = dis.readShort();
			   if (code != CommonConstants.DOWNLOAD_CODE) {
				  throw new IOException("Expected return code " + CommonConstants.DOWNLOAD_CODE + ", received " + code);
			   }

			   ip = IPUtil.ipStringFromStream(dis);

			   username = dis.readUTF();
			   password = dis.readUTF();
			   dir = dis.readUTF();
			   filename = dis.readUTF();
			   sfilename = dis.readUTF();

			   success = true;
			}

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   if (ip.equals("0.0.0.0"))
				  sb.append("erase download_server_address\n");
			   else
				  sb.append("set download_server_address " + ip + "\n");
			   if (username.equals(""))
				  sb.append("erase download_user\n");
			   else
				  sb.append("set download_user " + username + "\n");
			   if (password.equals(""))
				  sb.append("erase download_password\n");
			   else
				  sb.append("set download_password " + password + "\n");
			   if (dir.equals(""))
				  sb.append("erase download_directory\n");
			   else
				  sb.append("set download_directory " + dir + "\n");
			   if (filename.equals(""))
				  sb.append("erase download_file\n");
			   else
				  sb.append("set download_file " + filename + "\n");
			   if (sfilename.equals(""))
				  sb.append("erase softrom_download_file\n");
			   else
				  sb.append("set softrom_download_file " + sfilename + "\n");

			   return sb.toString();
			}
	  }

	  private String getSoftwareDownloadConfig () throws IOException {
		 try {
			SoftwareDownloadData sdd = new SoftwareDownloadData();
			boolean ret = cr.retrieve(CommonConstants.DOWNLOAD_CODE, sdd);
			if (ret == true)
			   return sdd.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting Software Download Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  private class PermissionData implements DataConsumer {
			private String readPass, writePass;
			private boolean success;

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   short code = dis.readShort();
			   if (code != CommonConstants.PERMISSION) {
				  throw new IOException("Expected return code " + CommonConstants.PERMISSION + ", received " + code);
			   }

			   readPass = dis.readUTF();
			   writePass = dis.readUTF();

			   success = true;
			}

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   if (readPass == null || readPass.equals(""))
				  sb.append("erase read_permission\n");
			   else
				  sb.append("set read_permission " + readPass + "\n");
			   if (writePass == null || writePass.equals(""))
				  sb.append("erase write_permission\n");
			   else
				  sb.append("set write_permission " + writePass + "\n");

			   return sb.toString();
			}
	  }

	  private String getPermissionConfig () throws IOException {
		 try {
			PermissionData sdd = new PermissionData();
			boolean ret = cr.retrieve(CommonConstants.PERMISSION, sdd);
			if (ret == true)
			   return sdd.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting Permission Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  private class IVRData implements DataConsumer {
			private String password;
			private boolean success;

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   short code = dis.readShort();
			   if (code != CommonConstants.IVR) {
				  throw new IOException("Expected return code " + CommonConstants.IVR + ", received " + code);
			   }

			   password = dis.readUTF();

			   success = true;
			}

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   if (password == null || password.equals(""))
				  sb.append("erase ivr_password\n");
			   else
				  sb.append("set ivr_password " + password + "\n");

			   return sb.toString();
			}
	  }

	  private String getIvrConfig () throws IOException {
		 try {
			IVRData sdd = new IVRData();
			boolean ret = cr.retrieve(CommonConstants.IVR, sdd);
			if (ret == true)
			   return sdd.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting IVR Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  // DhcpServer data
	  private class DhcpServerData implements DataConsumer {
			private boolean success;
			private boolean enable = false;
			private int maxLeaseTime;
			private int defaultLeaseTime;
			private String domainName;
			private int numberOfNameservers;
			private IPAddress []nameservers;
			private short numberOfSubnets;
			private IPAddress defaultGateway;
			private StringBuffer []subnets;

			public void extractGetReply (LimitedDataInputStream dis) throws IOException {
			   short code = dis.readShort();
			   if (code != CommonConstants.DHCP_SERVER) {
				  throw new IOException("Expected return code " + CommonConstants.DHCP_SERVER + ", received " + code);
			   }

			   int en = dis.readUnsignedByte();
			   if (en != 0) {
				  enable = true;
			   }

			   domainName = dis.readUTF();
        
			   numberOfNameservers = dis.readUnsignedByte();
			   nameservers = new IPAddress[numberOfNameservers];
			   for (int i=0; i<numberOfNameservers; i++) {
				  nameservers[i] = new IPAddress(dis);
			   }

			   // Default gateway/router
			   defaultGateway = new IPAddress(dis);

			   // Subnet data
			   numberOfSubnets = dis.readShort();
			   // Store the subnet data as a String
			   subnets = new StringBuffer[numberOfSubnets];
			   for (int i=0; i<numberOfSubnets; i++) {
				  maxLeaseTime = dis.readInt();
				  defaultLeaseTime = dis.readInt();
				  IPAddress ip = new IPAddress(dis); // net addr
				  subnets[i] = new StringBuffer(ip+" ");
				  ip.read(dis); // mask
				  subnets[i].append(ip+" range ");

				  short numberOfRanges = dis.readShort();
				  for (int j=0; j<numberOfRanges; j++) {
					 ip.read(dis); // start
					 subnets[i].append(ip+" ");
					 ip.read(dis); // end
					 subnets[i].append(ip+" ");
				  }

				  // The lease info is discarded
				  short numberOfLeases = dis.readShort();
				  for (int j=0; j<numberOfLeases; j++) {
					 new IPAddress().read(dis);
					 dis.readUTF();
					 dis.readUTF();
					 dis.readUnsignedByte();
					 dis.readUnsignedByte();
					 dis.readUTF();
					 dis.readInt();
					 dis.readInt();
					 dis.readInt();
					 dis.readInt();
				  }
			   }

			   success = true;
			}

			public String getConfig () {
			   if (!success)
				  return null;

			   StringBuffer sb = new StringBuffer();

			   // Set enable
			   if (enable == true) {
				  sb.append("set dhcp_server enable\n");
			   } else {
				  sb.append("set dhcp_server disable\n");
			   }

			   // Set the lease times
			   sb.append("set dhcp_server param max-lease-time "+maxLeaseTime+"\n");
			   sb.append("set dhcp_server param default-lease-time "+maxLeaseTime+"\n");

			   // Set the domain info
			   sb.append("set dhcp_server param option domain-name \""+domainName+"\"\n");
			   if (numberOfNameservers>0) {
				  sb.append("set dhcp_server param option domain-name-servers ");
				  for (int i=0; i<numberOfNameservers-1; i++) {
					 sb.append(nameservers[i]+",");
				  }
				  sb.append(nameservers[numberOfNameservers-1]+"\n");
			   }
			   sb.append("set dhcp_server param option routers "+defaultGateway+"\n");

			   // Set the subnet info. This hould only be add commands.
			   for (int i=0; i<numberOfSubnets; i++) {
				  sb.append("set dhcp_server subnet add "+subnets[i]+"\n");
			   }
        
			   return sb.toString();
			}
	  }

	  private String getDhcpServerConfig () throws IOException {
		 try {
			DhcpServerData dhcpServerData = new DhcpServerData();
			boolean ret = cr.retrieve(CommonConstants.DHCP_SERVER, dhcpServerData);
			if (ret == true)
			   return dhcpServerData.getConfig();
		 } catch (IOException ie) {
			throw new IOException("Error getting DHCP Server Data:\n    " + ie.getMessage());
		 }
		 return null;
	  }

	  public String getConfig () throws IOException {
		 StringBuffer sb = new StringBuffer();
		 String cfg;

		 // put some header info
		 sb.append(getHeaderInfo());

		 // erase information that we don't use anymore
		 sb.append(getStaleInfo());

		 cfg = getAccessControlConfig();
		 if (cfg != null)
			sb.append(cfg);
		 else
			throw new IOException("Access Control Data fetch failed");

		 cfg = getDataVpnConfig();
		 if (cfg != null)
			sb.append(cfg);
		 else
			throw new IOException("Data VPN Data fetch failed");

		 cfg = getDhcpRelayConfig();
		 if (cfg != null)
			sb.append(cfg);
		 else
			throw new IOException("DHCP Relay Data fetch failed");

		 cfg = getDnsConfig();
		 if (cfg != null)
			sb.append(cfg);
		 else
			throw new IOException("DNS Data fetch failed");

		 cfg = getEthernetConfig();
		 if (cfg != null)
			sb.append(cfg);
		 else
			throw new IOException("Ethernet Data fetch failed");

		 cfg = getH323Config();
		 if (cfg != null)
			sb.append(cfg);
		 else
			throw new IOException("H.323 Data fetch failed");

		 cfg = getInternetConfig();
		 if (cfg != null)
			sb.append(cfg);
		 else
			throw new IOException("Internet Access Data fetch failed");

		 cfg = getIPFilterConfig();
		 if (cfg != null)
			sb.append(cfg);
		 else
			throw new IOException("IP Filter Data fetch failed");

		 cfg = getIServerConfig();
		 if (cfg != null)
			sb.append(cfg);
		 else
			throw new IOException("iServer Data fetch failed");

		 if (reg.getDeviceId() == CommonConstants.DEVICE_ID_500) {
			cfg = getITSPConfig();
			if (cfg != null)
			   sb.append(cfg);
			else
			   throw new IOException("ITSP Data fetch failed");
		 }

		 cfg = getNatConfig();
		 if (cfg != null)
			sb.append(cfg);
		 else
			throw new IOException("Nat Data fetch failed");

		 cfg = getNatProxyConfig();
		 if (cfg != null)
			sb.append(cfg);
		 else
			throw new IOException("Nat Proxy Data fetch failed");

		 cfg = getPhonePortConfig();
		 if (cfg != null)
			sb.append(cfg);
		 else
			throw new IOException("Phone Port Data fetch failed");

		 cfg = getPrefixConfig();
		 if (cfg != null)
			sb.append(cfg);
		 else
			throw new IOException("Dialing Prefix Data fetch failed");

		 if (reg.getDeviceId() == CommonConstants.DEVICE_ID_500) {
			cfg = getLinePortConfig();
			if (cfg != null)
			   sb.append(cfg);
			else
			   throw new IOException("Line Port Data fetch failed");
		 }

		 cfg = getSoftwareDownloadConfig();
		 if (cfg != null)
			sb.append(cfg);
		 else
			throw new IOException("Software Download Data fetch failed");

		 cfg = getPermissionConfig();
		 if (cfg != null)
			sb.append(cfg);
		 else
			throw new IOException("Permission Data fetch failed");

		 cfg = getDhcpServerConfig();
		 if (cfg != null)
			sb.append(cfg);
		 else
			throw new IOException("DHCP Server Data fetch failed");

		 if (reg.getDeviceId() == CommonConstants.DEVICE_ID_510) {
			cfg = getIvrConfig();
			if (cfg != null)
			   sb.append(cfg);
			else
			   throw new IOException("IVR Data fetch failed");
		 }

		 sb.append("bye\n");
		 return sb.toString();
	  }

}

