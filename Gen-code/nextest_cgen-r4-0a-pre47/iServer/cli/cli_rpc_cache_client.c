/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "cli_rpc.h"
#include <stdio.h>
#include <stdlib.h> /* getenv, exit */
/* AAAAAAAA */

#include "cli.h"
#include "cli_rpc.h"
#include <stdio.h>
#include <stdlib.h> /* getenv, exit */

extern CLIENT *cli_binding;
static CLIENT * cli_rpc_client_init(char *server);
static void cli_rpc_client_close(CLIENT *cl, int force);


int
CacheHandleIedge(unsigned int cacheType, NetoidInfoEntry *entry, int op)
{
	CLIENT			*cl= NULL;
	NetoidInfoEntry netInfo;
	int				rc = -1, retval;
	CacheTableInfo 	*cacheInfo = NULL;

	/*  Init rpc connection */
	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return NULL;
	}

	/* RPC call */
	switch (op)
	{
		case CLIOP_ADD:
		case CLIOP_DELETE:
		case CLIOP_REPLACE:
				cacheInfo = cli_cache_handle_iedge_1(entry, cacheType, op, cl);
				if (cacheInfo == (CacheTableInfo *) NULL) {
					clnt_perror(cl, "call failed");
					cli_rpc_client_close(cl, 0);
					return rc;
				}
				break;

		case CLIOP_COPY: /* copies only netoid part */
				cacheInfo = cli_cache_handle_iedge_1(entry, cacheType, op, cl);
				if (cacheInfo == (CacheTableInfo *) NULL) {
					clnt_perror(cl, "call failed");
					cli_rpc_client_close(cl, 0);
					return rc;
				}
				memcpy(entry, &cacheInfo->data, sizeof(NetoidInfoEntry));
				break;
	}

	cli_rpc_client_close(cl, 0);
	return 0;
}

CacheTableInfo *
GetIedgeLongestMatch_rpc(RealmSubnet *rmsub)
{
	CacheTableInfo  *result, *iedge;
	CLIENT			*cl;
	int				rc=-1;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return NULL;
	}

	result = cli_handle_get_iedge_longest_match_1(rmsub, cl);
	if (result == (CacheTableInfo *) NULL) {
		clnt_perror(cl, "call failed");
		cli_rpc_client_close(cl, 0);
		return NULL;
	}

	if (result->data.regid[0] == 0)
	{
		cli_rpc_client_close(cl, 0);
		return NULL;
	}

	iedge = malloc(sizeof(CacheTableInfo));
	memset(iedge, 0 , sizeof(CacheTableInfo));
	memcpy(iedge, result, sizeof(CacheTableInfo));

	cli_rpc_client_close(cl, 0);
	return (iedge); /* Caller of this function has to free up this memory */
}

/* Variable list may be tricky. Who free the variable list is it us
 * or is it RPC. 
 */

/* Optimize this to handle chunks if the cache size if bigger than a certain length */
   
int
CacheGetBulkFromNetoidCache(int cacheType, CacheTableInfo_va **list)
{
	CLIENT			*cl= NULL;
   	CacheTableInfo *info;
	CacheTableInfo_va	*retlist;
	int				rc=-1, retval;
	int				count, i;
	int 			nactive = 0, nstatic = 0;

	/*  Init rpc connection */
	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return NULL;
	}

	retlist = cli_handle_netoid_get_bulk_1(cacheType, cl);
	if (retlist == (CacheTableInfo_va *) NULL) {
		clnt_perror(cl, "CacheGetBulkFromNetoidCache:call failed");
		cli_rpc_client_close(cl, 0);
		return rc;
	}

	count = 0;
	while(count < retlist->CacheTableInfo_va_len)
	{
		info = &retlist->CacheTableInfo_va_val[count];

		count++;
		CLIPRINTF((stdout, "\tIedge %d\n", count));
		if (info->iserver_addr) 
		{
			CLIPRINTF((stdout, "\tIserver %s\n", ULIPtostring(ntohl(info->iserver_addr))));
		}

		PrintInfoEntry(stdout, &info->data);

		if (info->data.stateFlags & CL_ACTIVE) 
		{
			nactive ++;
		}

		if (info->data.stateFlags & CL_STATIC)
	   	{
			nstatic ++;
		}

		if (cacheType == ipCache)
		{
			/* Print some information relevent only to the
			 * ip cache entry 
			 */
			CLIPRINTF((stdout, "\tNo of ports registered = %d \n\t[", info->data.nports));
			
			for (i=0; i<MAX_IEDGE_PORTS; i++)
			{	
				 if (BITA_TEST(info->data.ports, i))
				 {
					  CLIPRINTF((stdout, " %d", i));
				 }
			}
			CLIPRINTF((stdout, " ]\n\n"));
		}
		else if (cacheType == regidCache)
		{
			/* Print some information relevent only to the
			* regid cache entry 
			*/
			CLIPRINTF((stdout, "\tNo of ports configured = %d \n\t[", info->data.ncfgports));
		
			for (i=0; i<MAX_IEDGE_PORTS; i++)
			{	
				if (BITA_TEST(info->data.cfgports, i))
				{
					 CLIPRINTF((stdout, " %d", i));
				}
			}
			CLIPRINTF((stdout, " ]\n\n"));
		}
	}
	CLIPRINTF((stdout, "GIS %d Endpoints/Ports[%d active %d static]\n\n", count, nactive, nstatic));
	cli_rpc_client_close(cl, 0);
	return 0;
}

int
CacheGetBulkFromGkCache(void)
{
	CLIENT			*cl= NULL;
   	CacheGkInfo 	*info;
	CacheGkInfo_va	*retlist;
	int				rc=-1, retval;
	int				count, i;
	int 			nactive = 0, nstatic = 0;

	/*  Init rpc connection */
	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return NULL;
	}

	retlist = cli_handle_gk_get_bulk_1(cl);
	if (retlist == (CacheGkInfo_va *) NULL) {
		clnt_perror(cl, "CacheGetBulkFromGkCache:call failed");
		cli_rpc_client_close(cl,0);
		return rc;
	}

	count = 0;
	while(count < retlist->CacheGkInfo_va_len)
	{
		info = &retlist->CacheGkInfo_va_val[count];

		count++;
		CLIPRINTF((stdout, "\tGatekeeper %d\n", count));
		PrintGkInfoEntry(stdout, info);
		CLIPRINTF((stdout, "\n"));
	}
	CLIPRINTF((stdout, "GIS %d Endpoints/Ports\n\n", count));
	cli_rpc_client_close(cl,0);
	return 0;
}

int
CacheGetBulkFromRealmCache(void)
{
	CLIENT			*cl= NULL;
   	CacheRealmEntry 	*realm;
	CacheRealmEntry_va	*retlist;
	int				count, rc =-1;

	/*  Init rpc connection */
	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return NULL;
	}

	retlist = cli_handle_realm_get_bulk_1(cl);
	if (retlist == (CacheRealmEntry_va *) NULL) {
		clnt_perror(cl, "CacheGetBulkFromRealmCache:call failed");
		cli_rpc_client_close(cl,0);
		return rc;
	}

	count = 0;
	while(count < retlist->CacheRealmEntry_va_len)
	{
		realm = &retlist->CacheRealmEntry_va_val[count];

		count++;
		PrintRealmEntry(stdout, &realm->realm);
//		CLIPRINTF((stdout, "socket id %d\n", realm->socketId));
	}

	CLIPRINTF((stdout, "\n%d Realm%s\n\n", count, count==1?"":"s"));

	cli_rpc_client_close(cl,0);
	return 0;
}

int
CheckRSA_rpc(void *dummy, RealmEntry *newrm , RealmEntry *oldrm)
{
	CLIENT	*cl;
	char **result, rc;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return 0;
	}	

	/* license.c */
	result = cli_handle_check_rsa_dup_1(newrm , oldrm, cl);
	if (result == (char **)NULL){
		clnt_perror(cl, "CheckRSA_rpc call failed");
		cli_rpc_client_close(cl, 0);
	}
	else if (*result[0] = '0') {
		rc = 0;
	}
	else {
		rc = -1;
		CLIPRINTF((stdout, "%s", *result));
	}

	cli_rpc_client_close(cl, 0);
	return rc;
}

int
RealmChangeVipSig_rpc(unsigned long rsa, int status)
{
	CLIENT	*cl;
	int  *result, rc;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return 0;
	}	

	if (status)  /* enable */	
	{
		result= cli_handle_realm_enable_sig_1(rsa, cl);
		if (result== (int *) NULL) {
			clnt_perror(cl, "call failed");
		}
	}
	else {
		result= cli_handle_realm_disable_sig_1(rsa, cl);
		if (result== (int *) NULL) {
			clnt_perror(cl, "call failed");
		}
	}

	cli_rpc_client_close(cl, 0);
	return 0;
}


int
CacheGetBulkFromIgrpCache(void)
{
	CLIENT			*cl= NULL;
   	CacheIgrpInfo		*igrp;
	CacheIgrpInfo_va	*retlist;
	int				count, rc=0;

	/*  Init rpc connection */
	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return NULL;
	}

	retlist = cli_handle_igrp_get_bulk_1(cl);
	if (retlist == (CacheIgrpInfo_va *) NULL) {
		clnt_perror(cl, "CacheGetBulkFromRealmCache:call failed");
		cli_rpc_client_close(cl,0);
		return rc;
	}

	count = 0;
	while(count < retlist->CacheIgrpInfo_va_len)
	{
		igrp = &retlist->CacheIgrpInfo_va_val[count];

		count++;
		PrintIgrpEntry(stdout, &igrp->igrp);
	}

	CLIPRINTF((stdout, "Total Igrp entries %d\n", count)); 

	cli_rpc_client_close(cl,0);
	return 0;
}

void
IgrpAddCalls_rpc(char *name, unsigned int incalls, unsigned int outcalls,
	   					 unsigned int totalcalls)	
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return;
	}	

	/* license.c */
	result = cli_handle_igrp_add_calls_1(name, incalls, outcalls, totalcalls, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}
	else{	
		switch(*result)
		{
			case 2:
				CLIPRINTF((stdout, "No Igrp entry exists for %s\n", name));
				break;
		}
	}

	cli_rpc_client_close(cl, 0);
	return;

}


void
IgrpDeleteCalls_rpc(char *name, unsigned int incalls, unsigned int outcalls,
	   					 unsigned int totalcalls)	
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return;
	}	

	/* license.c */
	result = cli_handle_igrp_delete_calls_1(name, incalls, outcalls, totalcalls, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}
	else{	
		switch(*result)
		{
			case 2:
				CLIPRINTF((stdout, "No Igrp entry exists for %s\n", name));
				break;
		}
	}

	cli_rpc_client_close(cl, 0);
	return;
}


int
HandleVpnSipDomainChange_rpc(VpnEntry *vpnEntry)
{
	int  *result;
	CLIENT *cl = cli_binding;

	result = cli_handle_vpn_sipdomain_change_1(vpn, cl);
	if (result== (int *) NULL) {
		clnt_perror(cl, "call failed");
		return (*result);
	}
	return (*result);

}

int
HandleVpnPrefixChange_rpc(VpnEntry *vpnEntry)
{
	int  *result;
	CLIENT *cl = cli_binding;

	result= cli_handle_vpn_prefix_change_1(vpn, cl);
	if (result== (int *) NULL) {
		clnt_perror(cl, "call failed");
		return (*result);
	}
	return (*result);
}

int
CacheGetBulkFromTriggerCache(void)
{
	CLIENT			*cl= NULL;
   	CacheTriggerEntry 	*trigger;
	CacheTriggerEntry_va	*retlist;
	int				count, rc=-1;

	/*  Init rpc connection */
	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return NULL;
	}

	retlist = cli_handle_trigger_get_bulk_1(cl);
	if (retlist == (CacheTriggerEntry_va *) NULL) {
		clnt_perror(cl, "CacheGetBulkFromRealmCache:call failed");
		cli_rpc_client_close(cl,0);
		return rc;
	}

	count = 0;
	while(count < retlist->CacheTriggerEntry_va_len)
	{
		trigger = &retlist->CacheTriggerEntry_va_val[count];

		count++;
		PrintTriggerEntry(stdout, &trigger->trigger);
		CLIPRINTF((stdout, "#installed \t\t%d\n", trigger->ntriggers));
	}

	// CLIPRINTF((stdout, "%d triggers\n", n));  - not accurately tabulated
	cli_rpc_client_close(cl,0);
	return 0;
}

int
CacheGetBulkFromCRCache(void)
{
	CLIENT			*cl= cli_binding;
   	CacheRouteEntry	*cr;
	CacheCREntry_va	*retlist;
	int				count, rc=0;

	if  (cl == NULL) { return (-1); }

	retlist = cli_handle_cr_get_bulk_1(cl);
	if (retlist == (CacheCREntry_va *) NULL) {
		clnt_perror(cl, "CacheGetBulkFromCRCache:call failed");
		return (-1);
	}

	count = 0;
	while(count < retlist->CacheCREntry_va_len)
	{
		cr = &retlist->CacheCREntry_va_val[count];

		count++;
		PrintCREntry(stdout, &cr->routeEntry);
	}

	CLIPRINTF((stdout, "#entries %d\n", count)); 

	return 0;
}

int
CacheGetBulkFromCPCache(void)
{
	CLIENT			*cl= cli_binding;
   	CacheCPBEntry	*cp;
	CacheCPBEntry_va	*retlist;
	int				count, rc=0;

	if  (cl == NULL) { return (-1); }

	retlist = cli_handle_cr_get_bulk_1(cl);
	if (retlist == (CacheCPBEntry_va *) NULL) {
		clnt_perror(cl, "CacheGetBulkFromCPCache:call failed");
		return (-1);
	}

	count = 0;
	while(count < retlist->CacheCPBEntry_va_len)
	{
		cp = &retlist->CacheCPBEntry_va_val[count];

		count++;
		PrintCPBEntry(stdout, &cp->cpbEntry);
	}

	CLIPRINTF((stdout, "#entries %d\n", count)); 

	return 0;
}

int
CacheGetBulkFromVpnCache(void)
{
	CLIENT			*cl= cli_binding;
   	CacheVpnEntry	*vpn;
	CacheVpnEntry_va	*retlist;
	VpnEntry			*entry;
	int				count, rc=0;
	time_t			tmptime;

	if  (cl == NULL) { return (-1); }

	retlist = cli_handle_vpn_get_bulk_1(cl);
	if (retlist == (CacheVpnEntry_va *) NULL) {
		clnt_perror(cl, "CacheGetBulkFromVpnCache:call failed");
		return (-1);
	}

	count = 0;
	CLIPRINTF((stdout, "VPN Cache...\n"));
	while(count < retlist->CacheVpnEntry_va_len)
	{
		vpn = &retlist->CacheVpnEntry_va_val[count];
		entry = &vpn->vpnEntry;

		if (vpn->iserver_addr)
		{
			fprintf(stdout, "Iserver %s\n", ULIPtostring(ntohl(vpn->iserver_addr)));
		}
		PrintVpnEntry(stdout, entry);
		tmptime = entry->mTime;
		CLIPRINTF((stdout, "\tmod time %s\n", ctime(&tmptime)));
	}
	return 0;
}

int
CacheGetBulkFromVpnGCache(void)
{
	CLIENT			*cl= cli_binding;
   	CacheVpnGEntry		*vpng;
	CacheVpnGEntry_va	*retlist;
	VpnGroupEntry		*entry;
	int				count, rc=0;
	time_t			tmptime;

	if  (cl == NULL) { return (-1); }

	retlist = cli_handle_vpng_get_bulk_1(cl);
	if (retlist == (CacheVpnGEntry_va *) NULL) {
		clnt_perror(cl, "CacheGetBulkFromVpnGCache:call failed");
		return (-1);
	}

	count = 0;
	CLIPRINTF((stdout, "VPN Cache...\n"));
	while(count < retlist->CacheVpnEntry_va_len)
	{
		vpng = &retlist->CacheVpnEntry_va_val[count];

		if (vpng->iserver_addr)
		{
			fprintf(stdout, "Iserver %s\n", ULIPtostring(ntohl(vpng->iserver_addr)));
		}
		entry = &vpng->vpnGroupEntry;
		CLIPRINTF((stdout, "Retrieved vpn entry \"%s\"\n", entry->vpnGroup));

		tmptime = entry->mTime;
		CLIPRINTF((stdout, "\tmod time %s\n", ctime(&tmptime)));
	}
	return 0;
}
int 
CacheInsert_rpc(int cache, void *data)
{
	CacheEntryGeneric	entry;
	CLIENT				*cl;
	int					*result, rc=-1;

	cl = cli_rpc_client_init("localhost");
	if ((cl == NULL) || (data == NULL))
	{
		return NULL;
	}

	entry.cache = cache;
	switch (cache)
	{
		case REG_CACHE:
		case REGID_CACHE:
		case PHONE_CACHE:
		case VPN_PHONE_CACHE:
		case EMAIL_CACHE:
		case IP_CACHE:
		case URI_CACHE:
		case H323ID_CACHE:
		case SUBNET_CACHE:
		case TG_CACHE:
				memcpy(&entry.cache_entry_u.cacheInfoEntry, data, sizeof(CacheTableInfo));
				break;

		case GK_CACHE:
				memcpy(&entry.cache_entry_u.cacheGkEntry, data, sizeof(CacheGkInfo));
				break;
		case CRID_CACHE:
				/* cacheIedge = CacheGet(cridCache, &data.keyCrId); */
				break;
		case GW_CACHE:
				break;
		case REALM_CACHE:
		case RSA_CACHE:
				memcpy(&entry.cache_entry_u.cacheRealmEntry, data, sizeof(CacheRealmEntry));
				break;
		case IGRP_CACHE:
				memcpy(&entry.cache_entry_u.cacheIgrpEntry, data, sizeof(CacheIgrpInfo));
				break;
		case TRIGGER_CACHE:
				memcpy(&entry.cache_entry_u.cacheTriggerEntry, data, sizeof(CacheTriggerEntry));
				break;

		default :
				cli_rpc_client_close(cl, 0);
				return rc;
	}

	result = cli_cache_insert_1(cache, data, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
		cli_rpc_client_close(cl, 0);
		return rc;
	}
	cli_rpc_client_close(cl, 0);
	return (*result);	
}

int
CacheDelete_rpc(int	cache, void *data)
{
}

int
CacheReInit_rpc(int cache)
{
	CLIENT	*cl;
	int  *result, rc;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return 0;
	}	

	/* license.c */
	result = cli_handle_cache_reinstantiate_1(cache, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
		rc=0;
	}
	else
	{	
		rc = *result;
	}

	cli_rpc_client_close(cl, 0);
	return rc;
}

void
HandleTestCache_rpc(char *str)
{
	CLIENT	*cl;
	int  i;
	str_va  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return ;
	}	

	/* license.c */
	result = cli_handle_test_cache_1(str, cl);
	if (result == (str_va *) NULL) {
		clnt_perror(cl, "call failed");
		return;
	}

	for(i=0; i<result->str_va_len; i++)
	{
		if(result->str_va_val[i].char_va_len)
		{
			fprintf(stdout, "%s", result->str_va_val[i].char_va_val);
		}
		else
		{CLIPRINTF((stdout, "String length 0 for %dth string !!! \n", i)); }
	}

	return;
}

void *
CacheGet_rpc(int cache, void *data)
{
	char fn[] = "CacheGet_rpc";
	CLIENT			*cl= NULL;
	CacheEntryGeneric 	*result;
	CacheKey		key= {0};
	CacheTableInfo  *iedge=NULL;
	CacheGkInfo		*gk=NULL;
	CacheRealmEntry *realm=NULL;
	CacheIgrpInfo	*igrp=NULL;
	CacheTriggerEntry *trigger=NULL;
   	CacheVpnEntry	*vpn=NULL;
   	CacheVpnGEntry	*vpng=NULL;
	CacheCPEntry	*cp=NULL;
	CacheCPBEntry	*cpbcr=NULL;
	void			*item=NULL;

	/*  Init rpc connection */
	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return NULL;
	}

	key.cache = cache;
	switch (cache)
	{
		case REG_CACHE:
		case REGID_CACHE:
				nx_strlcpy(key.cache_key_u.keyInfoEntry.regid, ((NetoidSNKey *)data)->regid, REG_ID_LEN);
				key.cache_key_u.keyInfoEntry.uport = ((NetoidSNKey *)data)->uport;
				break;
		case VPN_PHONE_CACHE:
		case PHONE_CACHE:
				nx_strlcpy(key.cache_key_u.keyPhone.phone, ((NetoidPhoneKey *)data)->phone, PHONE_NUM_LEN); 
				break;
		case EMAIL_CACHE:
				nx_strlcpy(key.cache_key_u.keyEmail.email, ((NetoidEmailKey *)data)->email, EMAIL_LEN); 
				break;
		case IP_CACHE:
				key.cache_key_u.keyRealmIP.realmId = ((RealmIP *)data)->realmId; 
				key.cache_key_u.keyRealmIP.ipaddress = ((RealmIP *)data)->ipaddress; 
				break;
		case URI_CACHE:
				nx_strlcpy(key.cache_key_u.keyUri.uri, ((NetoidUriKey *)data)->uri, SIPURL_LEN); 
				break;
		case H323ID_CACHE:
				nx_strlcpy(key.cache_key_u.keyh323Id.h323id, ((NetoidH323IdKey *)data)->h323id, H323ID_LEN); 
				break;
		case SUBNET_CACHE:
				key.cache_key_u.keyRealmSubnet.subnetip = ((RealmSubnet *)data)->subnetip;
				key.cache_key_u.keyRealmSubnet.mask = ((RealmSubnet *)data)->mask ;
				key.cache_key_u.keyRealmSubnet.realmId = ((RealmSubnet *)data)->realmId ;
				break;
		case CRID_CACHE:
				key.cache_key_u.keyCrId.crId = ((NetoidCrIdKey *)data)->crId;
				break;
		case TG_CACHE:
				nx_strlcpy(key.cache_key_u.keyTg.tg, ((NetoidTgKey *)data)->tg, PHONE_NUM_LEN); 
				break;
		case TRIGGER_CACHE:
				nx_strlcpy((void *)&key.cache_key_u.keyTrigger, data, sizeof(TriggerEntry));
				break;
		case GK_CACHE:
				nx_strlcpy(key.cache_key_u.keyGk.regid, ((NetoidSNKey *)data)->regid, REG_ID_LEN);
				key.cache_key_u.keyGk.uport = ((NetoidSNKey *)data)->uport;
				break;
		case REALM_CACHE:
		case RSA_CACHE:
				key.cache_key_u.keyRealm = *(unsigned long *)data;
				break;
		case IGRP_CACHE:
				nx_strlcpy((void *)&key.cache_key_u.keyIgrp, (void *)data, IGRP_NAME_LEN);
				break;
		case GW_CACHE:
				break;

		case VPN_CACHE:
				nx_strlcpy((void *)&key.cache_key_u.keyVpn, (void *)data, VPN_ATTR_LEN);
				break;
		case VPNG_CACHE:
				nx_strlcpy((void *)&key.cache_key_u.keyVpnG, (void *)data, VPN_GROUP_LEN);
				break;
		case CP_CACHE:
				nx_strlcpy((void *)&key.cache_key_u.keyCp, (void *)data, CALLPLAN_ATTR_LEN);
				break;
		case CPB_CACHE:
		case CPBCR_CACHE:
		case CPBCP_CACHE:
				nx_strlcpy((void *)key.cache_key_u.keyCpb.cpname, (void *)data, CALLPLAN_ATTR_LEN);
				nx_strlcpy((void *)key.cache_key_u.keyCpb.crname, (void *)(data + CALLPLAN_ATTR_LEN), 
																				CALLPLAN_ATTR_LEN);
				break;
	}

	result = cli_cache_get_1(cache, key, cl);
	if (result == (CacheEntryGeneric *) NULL) {
		clnt_perror(cl, "CacheGet_rpc:call failed");
		return NULL;
	}

	switch(result->cache)
	{
		case REG_CACHE:
		case REGID_CACHE:
		case PHONE_CACHE:
		case EMAIL_CACHE:
		case IP_CACHE:
		case URI_CACHE:
		case H323ID_CACHE:
		case SUBNET_CACHE:
		case CRID_CACHE:
		case VPN_PHONE_CACHE:
		case TG_CACHE:
				iedge = malloc(sizeof(CacheTableInfo));
				memset (iedge, 0, sizeof(CacheTableInfo));
				memcpy(iedge, &result->cache_entry_u.cacheInfoEntry, sizeof(CacheTableInfo));
				item = iedge; /* user of CacheGet has to free this pointer */
				break;

		case REALM_CACHE:
		case RSA_CACHE:
				realm = malloc(sizeof(CacheRealmEntry));
				memset(realm, 0, sizeof(CacheRealmEntry));
				memcpy(realm, &result->cache_entry_u.cacheRealmEntry, sizeof(CacheRealmEntry));
				item = realm;
				break;

		case IGRP_CACHE:
				igrp = malloc(sizeof(CacheIgrpInfo));
				memset(igrp, 0, sizeof(CacheIgrpInfo));
				memcpy(igrp, &result->cache_entry_u.cacheIgrpEntry, sizeof(CacheIgrpInfo));
				item = igrp;
				break;

		case GK_CACHE:
				gk = malloc(sizeof(CacheGkInfo));
				memset(gk, 0, sizeof(CacheGkInfo));
				memcpy(gk, &result->cache_entry_u.cacheGkEntry, sizeof(CacheGkInfo));
				item = gk; /* user of CacheGet has to free this pointer */
				break;

		case TRIGGER_CACHE:
				trigger = malloc(sizeof(CacheTriggerEntry));
				memset(trigger, 0, sizeof(CacheTriggerEntry));
				memcpy(trigger, &result->cache_entry_u.cacheTriggerEntry, sizeof(CacheTriggerEntry));
				item = trigger; /* user of CacheGet has to free this pointer */
				break;

		case VPN_CACHE:
				vpn = malloc(sizeof(CacheVpnEntry));
				memset(vpn, 0, sizeof(CacheVpnEntry));
				memcpy(vpn, &result->cache_entry_u.cacheVpnEntry, sizeof(CacheVpnEntry));
				item = vpn;
				break

		case VPNG_CACHE:
				vpng = malloc(sizeof(CacheVpnGEntry));
				memset(vpng, 0, sizeof(CacheVpnGEntry));
				memcpy(vpng, &result->cache_entry_u.cacheVpnGEntry, sizeof(CacheVpnGEntry));
				item = vpng;
				break
	
		case CP_CACHE:
				cp = malloc(sizeof(CacheCPEntry));
				memset(cp, 0, sizeof(CacheCPEntry));
				memcpy(cp, &result->cache_entry_u.cacheCPEntry, sizeof(CacheCPEntry));
				item = cp;
				break;

		/* could not find example code for CacheGet(cpbCache or cpbcp, .. ) - not implementing */
		case CPBCR_CACHE:
				cpbcr = malloc(sizeof(CacheCPBEntry));
				memset(cpbcr, 0, sizeof(CacheCPBEntry)); 
				memcpy(cpbcr, &result->cache_entry_u.cacheCPBEntry,sizeof(CacheCPBEntry));
				item = cpbcr;
				break;

		case CACHE_IGNORE:
				item = NULL;
				break;
	}

	cli_rpc_client_close(cl, 0);
	return (item);
}

int 
CachePurge_rpc(char *cacheName)
{
	CLIENT	*cl;
	int  *result, rc;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return 0;
	}	

	result = cli_cache_purge_1(cacheName, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
		rc=0;
	}
	else
	{	
		rc = *result;
	}

	cli_rpc_client_close(cl, 0);
	return rc;
}



int
CacheHandleVpn(VpnEntry *entry, int op)
{
	CLIENT			*cl= NULL;
	int				*result, rc=1;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	result = cli_cache_handle_vpn_1(entry, op, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
		rc= -1;
	}

	cli_rpc_client_close(cl, 0);
	return rc;
}

int
CacheHandleVpnG(VpnEntry *entry, int op)
{
	CLIENT			*cl= NULL;
	int				*result, rc=1;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return (NULL);
	}

	result = cli_cache_handle_vpng_1(entry, op, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
		rc= -1;
	}

	cli_rpc_client_close(cl, 0);
	return rc;
}

int
CacheHandleCR(VpnRouteEntry *entry, int op)
{
	CLIENT			*cl= NULL;
	int				*result, rc=1;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return (NULL);
	}

	result = cli_cache_handle_cr_1(entry, op, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
		rc= -1;
	}

	cli_rpc_client_close(cl, 0);
	return rc;
}

int
CacheHandleCP(CallPlanEntry *entry, int op)
{
	CLIENT			*cl= NULL;
	int				*result, rc=1;

	cl = cli_rpc_client_init("localhost");
	if (cl == NULL)
	{
		return (NULL);
	}

	result = cli_cache_handle_cp_1(entry, op, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
		rc= -1;
	}

	cli_rpc_client_close(cl, 0);
	return rc;
}

int
CacheHandleCPB(CallPlanBindEntry *entry, int op)
{
	CLIENT			*cl= NULL;
	int				*result, rc=1;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	result = cli_cache_handle_cpb_1(entry, op, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
		rc= -1;
	}

	cli_rpc_client_close(cl, 0);
	return rc;
}

int
CacheHandleTrigger(TriggerEntry *entry, int op)
{
	CLIENT			*cl= NULL;
	int				*result, rc=1;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	result = cli_cache_handle_trigger_1(entry, op, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
		rc= -1;
	}

	cli_rpc_client_close(cl, 0);
	return rc;
}

int
CacheHandleRealm(RealmEntry *entry, int op)
{
	CLIENT			*cl= NULL;
	int				rc = 1, *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	result = cli_cache_handle_realm_1(entry, op, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
		rc = -1;
	}

	cli_rpc_client_close(cl, 0);
	return rc;
}

int
CacheHandleIgrp(IgrpInfo *entry, int op)
{
	CLIENT			*cl= NULL;
	int				rc = 1, *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	result = cli_cache_handle_igrp_1(entry, op, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
		rc=-1;
	}

	cli_rpc_client_close(cl, 0);
	return rc;
}

int
CacheGetNumItems(int cacheType)
{
	CLIENT			*cl= NULL;
	int				rc = 0, *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	result = cli_cache_get_numitems_1(cacheType, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
		rc = 0;
	}
	else
	{
		rc = *result;
	}

	cli_rpc_client_close(cl, 0);
	return (rc);
}

int 
IedgeCachePopulate_rpc(unsigned short flags)
{
	CLIENT			*cl= NULL;
	int				*result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	result = cli_handle_iedge_cache_pop_1(flags, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}
	
	cli_rpc_client_close(cl, 0);
	return (*result);
}

int 
VpnPopulate_rpc(unsigned short flags)
{
	CLIENT			*cl= NULL;
	int				*result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	result = cli_handle_vpn_cache_pop_1(flags, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}
	
	cli_rpc_client_close(cl, 0);
	return (*result);
}

int 
VpnGPopulate_rpc(unsigned short flags)
{
	CLIENT			*cl= NULL;
	int				*result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	result = cli_handle_vpng_cache_pop_1(flags, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}
	
	cli_rpc_client_close(cl, 0);
	return (*result);
}

int 
CPPopulate_rpc(unsigned short flags)
{
	CLIENT			*cl= NULL;
	int				*result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	result = cli_handle_cp_cache_pop_1(flags, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}
	
	cli_rpc_client_close(cl, 0);
	return (*result);
}

int 
CPBPopulate_rpc(unsigned short flags)
{
	CLIENT			*cl= NULL;
	int				*result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	result = cli_handle_cpb_cache_pop_1(flags, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}
	
	cli_rpc_client_close(cl, 0);
	return (*result);
}


int 
TriggerPopulate_rpc(unsigned short flags)
{
	CLIENT			*cl= NULL;
	int				*result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	result = cli_handle_trigger_cache_pop_1(flags, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}
	
	cli_rpc_client_close(cl, 0);
	return (*result);
}

int 
RealmPopulate_rpc(unsigned short flags)
{
	CLIENT			*cl= NULL;
	int				*result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	result = cli_handle_realm_cache_pop_1(flags, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}
	
	cli_rpc_client_close(cl, 0);
	return (*result);
}

int 
IgrpPopulate_rpc(unsigned short flags)
{
	CLIENT			*cl= cli_binding;
	int				*result;

	if (cl == NULL) {return (-1)};

	result = cli_handle_igrp_cache_pop_1(flags, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}
	
	return (*result);
}


int
MemAgeIedgesInVpnGs_rpc(char *vpng1, char *vpng2)
{
	int *result;
	CLIENT  *clnt = cli_binding;

	result = cli_handle_mem_age_iedges_in_vpngs_1(vpng1, vpng2, clnt);
	if (result == (int *) NULL) {
		clnt_perror(clnt, "call failed");
		return (-1);
	}
	return (*result);
}

int 
license_init_rpc(void)
{
	CLIENT	*cl;
	int  *result, rc;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return 0;
	}	

	/* license.c */
	result = cli_license_init_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
		rc=0;
	}
	else
	{	
		rc = *result;
	}

	cli_rpc_client_close(cl, 0);
	return rc;
}

int 
license_allocate_rpc(int n)
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return 0;
	}

	/* license.c */
	result = cli_license_allocate_1(n, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
		cli_rpc_client_close(cl, 0);
		return (0);
	}

	cli_rpc_client_close(cl, 0);
	return (*result);
}

void 
license_release_rpc(int n)
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return ;
	}

	/* license.c */
	result = cli_license_release_1(n, cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0);
	return;
}

int CacheGetLsMemUsedLic_rpc()
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	/* license.c */
	result = cli_get_lsmem_usedlic_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0);
	return (*result);

}

int CacheGetLsMemNumLic_rpc()
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	/* license.c */
	result = cli_get_lsmem_numlic_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0);
	return (*result);

}

int CacheGetLsMemMaxCalls_rpc()
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	/* license.c */
	result = cli_get_lsmem_maxcalls_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0);
	return (*result);

}

int CacheGetLsMemMaxMRCalls_rpc()
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	/* license.c */
	result = cli_get_lsmem_maxmrcalls_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0 );
	return (*result);

}

int nlm_initConfigPort_rpc()
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	/* license.c */
	result = cli_nlm_init_config_port_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0);
	return (*result);

}

int nlm_getconfigport_rpc()
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	/* license.c */
	result = cli_nlm_get_config_port_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0);
	return (*result);

}

int nlm_setconfigport_rpc()
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	/* license.c */
	result = cli_nlm_set_config_port_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0);
	return (*result);

}


int nlm_getvport_rpc (void)
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	result = cli_nlm_get_vport_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0);
	return (*result);
}

int nlm_getUsedvport_rpc (void)
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	result = cli_nlm_get_usedvport_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0);
	return (*result);
}

int nlm_getUsedvportNolock_rpc (void)
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return(NULL);
	}

	result = cli_nlm_get_usedvport_nolock_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0);
	return (*result);
}

int nlm_getMRvport_rpc (void)
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return NULL;
	}

	result = cli_nlm_get_mrvport_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0);
	return (*result);
}


int nlm_freeMRvport_rpc(void)
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return NULL;
	}

	result = cli_nlm_free_mrvport_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0);
	return (*result);
}


int nlm_getUsedMRvportNolock_rpc (void)
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return NULL;
	}

	result = cli_nlm_get_usedmrvport_nolock_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0);
	return (*result);
}

int sipEnabled_rpc(void)
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return -1;
	}

	result = cli_sip_enabled_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0);
	return (*result);
}


int fceEnabled_rpc(void)
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return NULL;
	}

	result = cli_fce_enabled_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0);
	return (*result);
}


int radiusEnabled_rpc(void)
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return NULL;
	}

	result = cli_radius_enabled_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0);
	return (*result);
}


int h323Enabled_rpc(void)
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return NULL;
	}

	result = cli_h323_enabled_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0);
	return (*result);
}


int genEnabled_rpc(void)
{
	CLIENT	*cl;
	int  *result;

	cl = cli_rpc_client_init("localhost");
	if  (cl == NULL)
	{
		return -1;
	}

	result = cli_gen_enabled_1(cl);
	if (result == (int *) NULL) {
		clnt_perror(cl, "call failed");
	}

	cli_rpc_client_close(cl, 0);
	return (*result);
}

void
cli_rpc_client_close(CLIENT *cl, int endoftheworld)
{
	if ( cl != (CLIENT *) NULL )
	{
		if (cl != cli_binding)
		{
			clnt_destroy(cl);
		}
		else
		{
			if (endoftheworld) /* cli process exiting */
			{
				clnt_destroy(cl);
			}
		}
	}
	return;
}


static CLIENT *
cli_rpc_client_init( char *server )
{
	CLIENT *		cl;
	char *			error;
	char			description[255];
	struct timeval	timeOut;
	rpcvers_t		returned_vers;

	if (cli_binding)
	{
		return cli_binding;
	}

	// Set default timeout for client handle, cl, to 4 seconds

	memset(&timeOut, (int)0, sizeof(struct timeval));
	memset(&cl, (int) 0, sizeof(CLIENT *));

	timeOut.tv_sec = 2;

	//
	// Create client "handle" used for calling
	// MESSAGEPROG on the serverdesignated on
	// command line. We tell RPC package
	// to use the "tcp" protocol when contacting
	// the server.
	//

	if (( cl = clnt_create_vers_timed(	server,
										CLI_CACHE_HANDLER_PROG,
										&returned_vers,
										CLI_CACHE_HANDLER_VERS,
										CLI_CACHE_HANDLER_VERS,
										"tcp",
										&timeOut)) == NULL)
	{
		// Couldn't establish connection with the server

		error = clnt_spcreateerror(server);
		CLIPRINTF((stdout,  "RPC  : Client : %s\n", error));
		return((CLIENT *) NULL);
	}

	sprintf(description,
			"Registered with GIS CMD HANDLER RPC Server, \"%s\"", server);

	CLIPRINTF((stdout,  "RPC  : Client : %s\n", description));


	if (clnt_control(cl, CLSET_TIMEOUT, (char*) &timeOut) == FALSE)
	{
		sprintf(description, 
					"can't set timeout value to %d seconds\n", timeOut.tv_sec);
		CLIPRINTF((stdout,  "RPC  : Client : %s\n", description));
	}

	return(cl);
}


void InitRpc(void)
{
	regCache_rpc = REG_CACHE;
	ipCache_rpc = IP_CACHE;
	phoneCache_rpc = PHONE_CACHE;
	emailCache_rpc = EMAIL_CACHE;
	gkCache_rpc = GK_CACHE;
	uriCache_rpc = URI_CACHE;
	h323idCache_rpc = H323ID_CACHE;
	subnetCache_rpc = SUBNET_CACHE;
	cridCache_rpc = CRID_CACHE;
	tgCache_rpc = TG_CACHE;
	gwCache_rpc = GW_CACHE;
	vpnPhoneCache_rpc = VPN_PHONE_CACHE;
	regidCache_rpc = REGID_CACHE;
	gwcpCache_rpc = GWCP_CACHE;

	triggerCache_rpc = TRIGGER_CACHE;

	realmCache_rpc = REALM_CACHE;
	rsaCache_rpc = RSA_CACHE;

	igrpCache_rpc = IGRP_CACHE;
	vpnCache_rpc = VPN_CACHE;
	vpnGCache_rpc = VPNG_CACHE;
	cpCache_rpc = CP_CACHE;
	cpbCache_rpc = CPB_CACHE;
	cpbcrCache_rpc = CPBCR_CACHE;
	cpbcpCache_rpc = CPBCP_CACHE;
	rsapubnetsCache_rpc = RSAPUBNETS_CACHE;
	dtgCache_rpc = DTG_CACHE;
	cpdestCache_rpc = CPDEST_CACHE;

	/* rpc binding to gis on localhost */
	cli_binding = cli_rpc_client_init("localhost");
}

void ShutDownRpc(void)
{
	cli_rpc_client_close(cli_binding, 1);
}

/* BBBBBBBBBB */


void
cli_cache_handler_prog_1(host)
	char *host;
{
	CLIENT *clnt;
	CacheEntryGeneric  *result_1;
	int cli_cache_get_1_cacheType;
	CacheKey cli_cache_get_1_data;
	CacheEntryGeneric  *result_2;
	int cli_cache_getnext_1_cacheType;
	CacheKey cli_cache_getnext_1_data;
	CacheEntryGeneric  *result_3;
	int cli_cache_getfirst_1_cacheType;
	int  *result_4;
	char *cli_cache_purge_1_cacheName;
	int  *result_5;
	int cli_cache_insert_1_cacheType;
	CacheEntryGeneric cli_cache_insert_1_data;
	int  *result_6;
	int cli_cache_get_numitems_1_cacheType;
	CacheEntryGeneric  *result_7;
	int cli_cache_delete_1_cacheType;
	CacheEntryGeneric cli_cache_delete_1_data;
	int  *result_8;
	int cli_cache_remove_1_cacheType;
	CacheEntryGeneric cli_cache_remove_1_data;
	str_va  *result_9;
	char *cli_handle_test_cache_1_argv0;
	CacheTableInfo  *result_10;
	NetoidInfoEntry cli_cache_handle_iedge_1_netInfo;
	int cli_cache_handle_iedge_1_cacheType;
	int cli_cache_handle_iedge_1_op;
	CacheTableInfo_va  *result_11;
	int cli_handle_netoid_get_bulk_1_cacheType;
	CacheTableInfo  *result_12;
	RealmSubnet cli_handle_get_iedge_longest_match_1_rmsub;
	int  *result_13;
	char *cli_handle_mem_age_iedges_in_vpngs_1_vpng1;
	char *cli_handle_mem_age_iedges_in_vpngs_1_vpng2;
	CacheGkInfo_va  *result_14;
	int  *result_15;
	VpnEntry cli_cache_handle_vpn_1_vpnEntry;
	int cli_cache_handle_vpn_1_op;
	int  *result_16;
	VpnGroupEntry cli_cache_handle_vpng_1_vpnGroupEntry;
	int cli_cache_handle_vpng_1_op;
	int  *result_17;
	VpnRouteEntry cli_cache_handle_cr_1_routeEntry;
	int cli_cache_handle_cr_1_op;
	int  *result_18;
	CallPlanEntry cli_cache_handle_cp_1_cpEntry;
	int cli_cache_handle_cp_1_op;
	int  *result_19;
	CallPlanBindEntry cli_cache_handle_cpb_1_cpbEntry;
	int cli_cache_handle_cpb_1_op;
	int  *result_20;
	IgrpInfo cli_cache_handle_igrp_1_igrpEntry;
	int cli_cache_handle_igrp_1_op;
	int  *result_21;
	RealmEntry cli_cache_handle_realm_1_rmEntry;
	int cli_cache_handle_realm_1_op;
	int  *result_22;
	TriggerEntry cli_cache_handle_trigger_1_tgEntry;
	int cli_cache_handle_trigger_1_op;
	int  *result_23;
	int cli_handle_iedge_cache_pop_1_flags;
	int  *result_24;
	int cli_handle_vpn_cache_pop_1_flags;
	int  *result_25;
	int cli_handle_vpng_cache_pop_1_flags;
	int  *result_26;
	int cli_handle_cp_cache_pop_1_flags;
	int  *result_27;
	int cli_handle_cr_cache_pop_1_flags;
	int  *result_28;
	int cli_handle_cpb_cache_pop_1_flags;
	int  *result_29;
	int cli_handle_trigger_cache_pop_1_flags;
	int  *result_30;
	int cli_handle_realm_cache_pop_1_flags;
	int  *result_31;
	int cli_handle_igrp_cache_pop_1_flags;
	int  *result_32;
	int  *result_33;
	int cli_license_allocate_1_n;
	int  *result_34;
	int cli_license_release_1_n;
	int  *result_35;
	int  *result_36;
	int  *result_37;
	int  *result_38;
	int  *result_39;
	int  *result_40;
	int  *result_41;
	int cli_nlm_set_config_port_1_n;
	int  *result_42;
	int  *result_43;
	int  *result_44;
	int  *result_45;
	int  *result_46;
	int  *result_47;
	char * *result_48;
	int  *result_49;
	int  *result_50;
	int  *result_51;
	int  *result_52;
	int  *result_53;
	CacheRealmEntry_va  *result_54;
	int  *result_55;
	u_long cli_handle_check_realmid_dup_1_realmid;
	int  *result_56;
	u_long cli_handle_realm_enable_sig_1_rsa;
	int  *result_57;
	u_long cli_handle_realm_disable_sig_1_rsa;
	char * *result_58;
	RealmEntry cli_handle_check_rsa_dup_1_new;
	RealmEntry cli_handle_check_rsa_dup_1_old;
	CacheIgrpInfo_va  *result_59;
	int  *result_60;
	char *cli_handle_igrp_add_calls_1_igrpname;
	u_int cli_handle_igrp_add_calls_1_incalls;
	u_int cli_handle_igrp_add_calls_1_outcalls;
	u_int cli_handle_igrp_add_calls_1_totalcalls;
	int  *result_61;
	char *cli_handle_igrp_delete_calls_1_igrpname;
	u_int cli_handle_igrp_delete_calls_1_incalls;
	u_int cli_handle_igrp_delete_calls_1_outcalls;
	u_int cli_handle_igrp_delete_calls_1_totalcalls;
	CacheTriggerEntry_va  *result_62;
	int  *result_63;
	int cli_handle_cache_reinstantiate_1_cacheType;
	CacheVpnEntry_va  *result_64;
	CacheVpnGEntry_va  *result_65;
	int  *result_66;
	VpnEntry cli_handle_vpn_sipdomain_change_1_vpn;
	int  *result_67;
	VpnEntry cli_handle_vpn_prefix_change_1_vpn;
	CacheCPBEntry_va  *result_68;
	CacheCREntry_va  *result_69;
	CacheRouteEntry  *result_70;
	CacheRouteEntry cli_handle_cache_route_entry_get_nextptr_1_entry;
	CacheCPBEntry  *result_71;
	CacheCPBEntry cli_handle_cache_cpb_entry_get_crnextptr_1_entry;
	CacheTableInfo  *result_72;
	CacheTableInfo cli_handle_cache_iedge_entry_get_nextptr_1_entry;

#ifndef	DEBUG
	clnt = clnt_create(host, CLI_CACHE_HANDLER_PROG, CLI_CACHE_HANDLER_VERS, "netpath");
	if (clnt == (CLIENT *) NULL) {
		clnt_pcreateerror(host);
		exit(1);
	}
#endif	/* DEBUG */

	result_1 = cli_cache_get_1(cli_cache_get_1_cacheType, cli_cache_get_1_data, clnt);
	if (result_1 == (CacheEntryGeneric *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_2 = cli_cache_getnext_1(cli_cache_getnext_1_cacheType, cli_cache_getnext_1_data, clnt);
	if (result_2 == (CacheEntryGeneric *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_3 = cli_cache_getfirst_1(cli_cache_getfirst_1_cacheType, clnt);
	if (result_3 == (CacheEntryGeneric *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_4 = cli_cache_purge_1(cli_cache_purge_1_cacheName, clnt);
	if (result_4 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_5 = cli_cache_insert_1(cli_cache_insert_1_cacheType, cli_cache_insert_1_data, clnt);
	if (result_5 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_6 = cli_cache_get_numitems_1(cli_cache_get_numitems_1_cacheType, clnt);
	if (result_6 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_7 = cli_cache_delete_1(cli_cache_delete_1_cacheType, cli_cache_delete_1_data, clnt);
	if (result_7 == (CacheEntryGeneric *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_8 = cli_cache_remove_1(cli_cache_remove_1_cacheType, cli_cache_remove_1_data, clnt);
	if (result_8 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_9 = cli_handle_test_cache_1(cli_handle_test_cache_1_argv0, clnt);
	if (result_9 == (str_va *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_10 = cli_cache_handle_iedge_1(cli_cache_handle_iedge_1_netInfo, cli_cache_handle_iedge_1_cacheType, cli_cache_handle_iedge_1_op, clnt);
	if (result_10 == (CacheTableInfo *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_11 = cli_handle_netoid_get_bulk_1(cli_handle_netoid_get_bulk_1_cacheType, clnt);
	if (result_11 == (CacheTableInfo_va *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_12 = cli_handle_get_iedge_longest_match_1(cli_handle_get_iedge_longest_match_1_rmsub, clnt);
	if (result_12 == (CacheTableInfo *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_13 = cli_handle_mem_age_iedges_in_vpngs_1(cli_handle_mem_age_iedges_in_vpngs_1_vpng1, cli_handle_mem_age_iedges_in_vpngs_1_vpng2, clnt);
	if (result_13 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_14 = cli_handle_gk_get_bulk_1(clnt);
	if (result_14 == (CacheGkInfo_va *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_15 = cli_cache_handle_vpn_1(cli_cache_handle_vpn_1_vpnEntry, cli_cache_handle_vpn_1_op, clnt);
	if (result_15 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_16 = cli_cache_handle_vpng_1(cli_cache_handle_vpng_1_vpnGroupEntry, cli_cache_handle_vpng_1_op, clnt);
	if (result_16 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_17 = cli_cache_handle_cr_1(cli_cache_handle_cr_1_routeEntry, cli_cache_handle_cr_1_op, clnt);
	if (result_17 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_18 = cli_cache_handle_cp_1(cli_cache_handle_cp_1_cpEntry, cli_cache_handle_cp_1_op, clnt);
	if (result_18 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_19 = cli_cache_handle_cpb_1(cli_cache_handle_cpb_1_cpbEntry, cli_cache_handle_cpb_1_op, clnt);
	if (result_19 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_20 = cli_cache_handle_igrp_1(cli_cache_handle_igrp_1_igrpEntry, cli_cache_handle_igrp_1_op, clnt);
	if (result_20 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_21 = cli_cache_handle_realm_1(cli_cache_handle_realm_1_rmEntry, cli_cache_handle_realm_1_op, clnt);
	if (result_21 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_22 = cli_cache_handle_trigger_1(cli_cache_handle_trigger_1_tgEntry, cli_cache_handle_trigger_1_op, clnt);
	if (result_22 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_23 = cli_handle_iedge_cache_pop_1(cli_handle_iedge_cache_pop_1_flags, clnt);
	if (result_23 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_24 = cli_handle_vpn_cache_pop_1(cli_handle_vpn_cache_pop_1_flags, clnt);
	if (result_24 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_25 = cli_handle_vpng_cache_pop_1(cli_handle_vpng_cache_pop_1_flags, clnt);
	if (result_25 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_26 = cli_handle_cp_cache_pop_1(cli_handle_cp_cache_pop_1_flags, clnt);
	if (result_26 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_27 = cli_handle_cr_cache_pop_1(cli_handle_cr_cache_pop_1_flags, clnt);
	if (result_27 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_28 = cli_handle_cpb_cache_pop_1(cli_handle_cpb_cache_pop_1_flags, clnt);
	if (result_28 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_29 = cli_handle_trigger_cache_pop_1(cli_handle_trigger_cache_pop_1_flags, clnt);
	if (result_29 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_30 = cli_handle_realm_cache_pop_1(cli_handle_realm_cache_pop_1_flags, clnt);
	if (result_30 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_31 = cli_handle_igrp_cache_pop_1(cli_handle_igrp_cache_pop_1_flags, clnt);
	if (result_31 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_32 = cli_license_init_1(clnt);
	if (result_32 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_33 = cli_license_allocate_1(cli_license_allocate_1_n, clnt);
	if (result_33 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_34 = cli_license_release_1(cli_license_release_1_n, clnt);
	if (result_34 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_35 = cli_get_lsmem_usedlic_1(clnt);
	if (result_35 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_36 = cli_get_lsmem_numlic_1(clnt);
	if (result_36 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_37 = cli_get_lsmem_maxcalls_1(clnt);
	if (result_37 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_38 = cli_get_lsmem_maxmrcalls_1(clnt);
	if (result_38 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_39 = cli_nlm_init_config_port_1(clnt);
	if (result_39 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_40 = cli_nlm_get_config_port_1(clnt);
	if (result_40 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_41 = cli_nlm_set_config_port_1(cli_nlm_set_config_port_1_n, clnt);
	if (result_41 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_42 = cli_nlm_get_vport_1(clnt);
	if (result_42 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_43 = cli_nlm_get_usedvport_1(clnt);
	if (result_43 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_44 = cli_nlm_get_usedvport_nolock_1(clnt);
	if (result_44 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_45 = cli_nlm_get_mrvport_1(clnt);
	if (result_45 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_46 = cli_nlm_get_usedmrvport_nolock_1(clnt);
	if (result_46 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_47 = cli_nlm_free_mrvport_1(clnt);
	if (result_47 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_48 = cli_nlm_get_featurelist_1(clnt);
	if (result_48 == (char **) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_49 = cli_sip_enabled_1(clnt);
	if (result_49 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_50 = cli_fce_enabled_1(clnt);
	if (result_50 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_51 = cli_radius_enabled_1(clnt);
	if (result_51 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_52 = cli_h323_enabled_1(clnt);
	if (result_52 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_53 = cli_gen_enabled_1(clnt);
	if (result_53 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_54 = cli_handle_realm_get_bulk_1(clnt);
	if (result_54 == (CacheRealmEntry_va *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_55 = cli_handle_check_realmid_dup_1(cli_handle_check_realmid_dup_1_realmid, clnt);
	if (result_55 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_56 = cli_handle_realm_enable_sig_1(cli_handle_realm_enable_sig_1_rsa, clnt);
	if (result_56 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_57 = cli_handle_realm_disable_sig_1(cli_handle_realm_disable_sig_1_rsa, clnt);
	if (result_57 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_58 = cli_handle_check_rsa_dup_1(cli_handle_check_rsa_dup_1_new, cli_handle_check_rsa_dup_1_old, clnt);
	if (result_58 == (char **) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_59 = cli_handle_igrp_get_bulk_1(clnt);
	if (result_59 == (CacheIgrpInfo_va *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_60 = cli_handle_igrp_add_calls_1(cli_handle_igrp_add_calls_1_igrpname, cli_handle_igrp_add_calls_1_incalls, cli_handle_igrp_add_calls_1_outcalls, cli_handle_igrp_add_calls_1_totalcalls, clnt);
	if (result_60 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_61 = cli_handle_igrp_delete_calls_1(cli_handle_igrp_delete_calls_1_igrpname, cli_handle_igrp_delete_calls_1_incalls, cli_handle_igrp_delete_calls_1_outcalls, cli_handle_igrp_delete_calls_1_totalcalls, clnt);
	if (result_61 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_62 = cli_handle_trigger_get_bulk_1(clnt);
	if (result_62 == (CacheTriggerEntry_va *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_63 = cli_handle_cache_reinstantiate_1(cli_handle_cache_reinstantiate_1_cacheType, clnt);
	if (result_63 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_64 = cli_handle_vpn_get_bulk_1(clnt);
	if (result_64 == (CacheVpnEntry_va *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_65 = cli_handle_vpng_get_bulk_1(clnt);
	if (result_65 == (CacheVpnGEntry_va *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_66 = cli_handle_vpn_sipdomain_change_1(cli_handle_vpn_sipdomain_change_1_vpn, clnt);
	if (result_66 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_67 = cli_handle_vpn_prefix_change_1(cli_handle_vpn_prefix_change_1_vpn, clnt);
	if (result_67 == (int *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_68 = cli_handle_cp_get_bulk_1(clnt);
	if (result_68 == (CacheCPBEntry_va *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_69 = cli_handle_cr_get_bulk_1(clnt);
	if (result_69 == (CacheCREntry_va *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_70 = cli_handle_cache_route_entry_get_nextptr_1(cli_handle_cache_route_entry_get_nextptr_1_entry, clnt);
	if (result_70 == (CacheRouteEntry *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_71 = cli_handle_cache_cpb_entry_get_crnextptr_1(cli_handle_cache_cpb_entry_get_crnextptr_1_entry, clnt);
	if (result_71 == (CacheCPBEntry *) NULL) {
		clnt_perror(clnt, "call failed");
	}
	result_72 = cli_handle_cache_iedge_entry_get_nextptr_1(cli_handle_cache_iedge_entry_get_nextptr_1_entry, clnt);
	if (result_72 == (CacheTableInfo *) NULL) {
		clnt_perror(clnt, "call failed");
	}
#ifndef	DEBUG
	clnt_destroy(clnt);
#endif		/* DEBUG */
}


main(argc, argv)
	int argc;
	char *argv[];
{
	char *host;

	if (argc < 2) {
		printf("usage:  %s server_host\n", argv[0]);
		exit(1);
	}
	host = argv[1];
	cli_cache_handler_prog_1(host);
}
