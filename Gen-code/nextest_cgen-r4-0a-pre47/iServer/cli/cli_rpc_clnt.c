/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "cli_rpc.h"
#ifndef _KERNEL
#include <stdio.h>
#include <stdlib.h> /* getenv, exit */
#endif /* !_KERNEL */

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

CacheEntryGeneric *
cli_cache_get_1(cacheType, data, clnt)
	int cacheType;
	CacheKey data;
	CLIENT *clnt;
{
	cli_cache_get_1_argument arg;
	static CacheEntryGeneric clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	arg.cacheType = cacheType;
	arg.data = data;
	if (clnt_call(clnt, CLI_CACHE_GET,
		(xdrproc_t) xdr_cli_cache_get_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_CacheEntryGeneric, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

CacheEntryGeneric *
cli_cache_getnext_1(cacheType, data, clnt)
	int cacheType;
	CacheKey data;
	CLIENT *clnt;
{
	cli_cache_getnext_1_argument arg;
	static CacheEntryGeneric clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	arg.cacheType = cacheType;
	arg.data = data;
	if (clnt_call(clnt, CLI_CACHE_GETNEXT,
		(xdrproc_t) xdr_cli_cache_getnext_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_CacheEntryGeneric, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

CacheEntryGeneric *
cli_cache_getfirst_1(cacheType, clnt)
	int cacheType;
	CLIENT *clnt;
{
	static CacheEntryGeneric clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_CACHE_GETFIRST,
		(xdrproc_t) xdr_int, (caddr_t) &cacheType,
		(xdrproc_t) xdr_CacheEntryGeneric, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_cache_purge_1(cacheName, clnt)
	char *cacheName;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_CACHE_PURGE,
		(xdrproc_t) xdr_wrapstring, (caddr_t) &cacheName,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_cache_insert_1(cacheType, data, clnt)
	int cacheType;
	CacheEntryGeneric data;
	CLIENT *clnt;
{
	cli_cache_insert_1_argument arg;
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	arg.cacheType = cacheType;
	arg.data = data;
	if (clnt_call(clnt, CLI_CACHE_INSERT,
		(xdrproc_t) xdr_cli_cache_insert_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_cache_get_numitems_1(cacheType, clnt)
	int cacheType;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_CACHE_GET_NUMITEMS,
		(xdrproc_t) xdr_int, (caddr_t) &cacheType,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

CacheEntryGeneric *
cli_cache_delete_1(cacheType, data, clnt)
	int cacheType;
	CacheEntryGeneric data;
	CLIENT *clnt;
{
	cli_cache_delete_1_argument arg;
	static CacheEntryGeneric clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	arg.cacheType = cacheType;
	arg.data = data;
	if (clnt_call(clnt, CLI_CACHE_DELETE,
		(xdrproc_t) xdr_cli_cache_delete_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_CacheEntryGeneric, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_cache_remove_1(cacheType, data, clnt)
	int cacheType;
	CacheEntryGeneric data;
	CLIENT *clnt;
{
	cli_cache_remove_1_argument arg;
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	arg.cacheType = cacheType;
	arg.data = data;
	if (clnt_call(clnt, CLI_CACHE_REMOVE,
		(xdrproc_t) xdr_cli_cache_remove_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

str_va *
cli_handle_test_cache_1(argv0, clnt)
	char *argv0;
	CLIENT *clnt;
{
	static str_va clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_HANDLE_TEST_CACHE,
		(xdrproc_t) xdr_wrapstring, (caddr_t) &argv0,
		(xdrproc_t) xdr_str_va, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

CacheTableInfo *
cli_cache_handle_iedge_1(netInfo, cacheType, op, clnt)
	NetoidInfoEntry *netInfo;
	int cacheType;
	int op;
	CLIENT *clnt;
{
	cli_cache_handle_iedge_1_argument arg;
	static CacheTableInfo clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	arg.netInfo = netInfo;
	arg.cacheType = cacheType;
	arg.op = op;
	if (clnt_call(clnt, CLI_CACHE_HANDLE_IEDGE,
		(xdrproc_t) xdr_cli_cache_handle_iedge_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_CacheTableInfo, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

CacheTableInfo_va *
cli_handle_netoid_get_bulk_1(cacheType, clnt)
	int cacheType;
	CLIENT *clnt;
{
	static CacheTableInfo_va clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_HANDLE_NETOID_GET_BULK,
		(xdrproc_t) xdr_int, (caddr_t) &cacheType,
		(xdrproc_t) xdr_CacheTableInfo_va, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

CacheTableInfo *
cli_handle_get_iedge_longest_match_1(rmsub, clnt)
	RealmSubnet *rmsub;
	CLIENT *clnt;
{
	static CacheTableInfo clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_HANDLE_GET_IEDGE_LONGEST_MATCH,
		(xdrproc_t) xdr_RealmSubnet, (caddr_t) &rmsub,
		(xdrproc_t) xdr_CacheTableInfo, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_handle_mem_age_iedges_in_vpngs_1(vpng1, vpng2, clnt)
	char *vpng1;
	char *vpng2;
	CLIENT *clnt;
{
	cli_handle_mem_age_iedges_in_vpngs_1_argument arg;
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	arg.vpng1 = vpng1;
	arg.vpng2 = vpng2;
	if (clnt_call(clnt, CLI_HANDLE_MEM_AGE_IEDGES_IN_VPNGS,
		(xdrproc_t) xdr_cli_handle_mem_age_iedges_in_vpngs_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

CacheGkInfo_va *
cli_handle_gk_get_bulk_1(clnt)
	CLIENT *clnt;
{
	static CacheGkInfo_va clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_HANDLE_GK_GET_BULK,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_CacheGkInfo_va, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_cache_handle_vpn_1(vpnEntry, op, clnt)
	VpnEntry *vpnEntry;
	int op;
	CLIENT *clnt;
{
	cli_cache_handle_vpn_1_argument arg;
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	arg.vpnEntry = vpnEntry;
	arg.op = op;
	if (clnt_call(clnt, CLI_CACHE_HANDLE_VPN,
		(xdrproc_t) xdr_cli_cache_handle_vpn_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_cache_handle_vpng_1(vpnGroupEntry, op, clnt)
	VpnGroupEntry *vpnGroupEntry;
	int op;
	CLIENT *clnt;
{
	cli_cache_handle_vpng_1_argument arg;
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	arg.vpnGroupEntry = vpnGroupEntry;
	arg.op = op;
	if (clnt_call(clnt, CLI_CACHE_HANDLE_VPNG,
		(xdrproc_t) xdr_cli_cache_handle_vpng_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_cache_handle_cr_1(routeEntry, op, clnt)
	VpnRouteEntry *routeEntry;
	int op;
	CLIENT *clnt;
{
	cli_cache_handle_cr_1_argument arg;
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	arg.routeEntry = routeEntry;
	arg.op = op;
	if (clnt_call(clnt, CLI_CACHE_HANDLE_CR,
		(xdrproc_t) xdr_cli_cache_handle_cr_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_cache_handle_cp_1(cpEntry, op, clnt)
	CallPlanEntry *cpEntry;
	int op;
	CLIENT *clnt;
{
	cli_cache_handle_cp_1_argument arg;
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	arg.cpEntry = cpEntry;
	arg.op = op;
	if (clnt_call(clnt, CLI_CACHE_HANDLE_CP,
		(xdrproc_t) xdr_cli_cache_handle_cp_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_cache_handle_cpb_1(cpbEntry, op, clnt)
	CallPlanBindEntry *cpbEntry;
	int op;
	CLIENT *clnt;
{
	cli_cache_handle_cpb_1_argument arg;
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	arg.cpbEntry = cpbEntry;
	arg.op = op;
	if (clnt_call(clnt, CLI_CACHE_HANDLE_CPB,
		(xdrproc_t) xdr_cli_cache_handle_cpb_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_cache_handle_igrp_1(igrpEntry, op, clnt)
	IgrpInfo *igrpEntry;
	int op;
	CLIENT *clnt;
{
	cli_cache_handle_igrp_1_argument arg;
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	arg.igrpEntry = igrpEntry;
	arg.op = op;
	if (clnt_call(clnt, CLI_CACHE_HANDLE_IGRP,
		(xdrproc_t) xdr_cli_cache_handle_igrp_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_cache_handle_realm_1(rmEntry, op, clnt)
	RealmEntry *rmEntry;
	int op;
	CLIENT *clnt;
{
	cli_cache_handle_realm_1_argument arg;
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	arg.rmEntry = rmEntry;
	arg.op = op;
	if (clnt_call(clnt, CLI_CACHE_HANDLE_REALM,
		(xdrproc_t) xdr_cli_cache_handle_realm_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_cache_handle_trigger_1(tgEntry, op, clnt)
	TriggerEntry *tgEntry;
	int op;
	CLIENT *clnt;
{
	cli_cache_handle_trigger_1_argument arg;
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	arg.tgEntry = tgEntry;
	arg.op = op;
	if (clnt_call(clnt, CLI_CACHE_HANDLE_TRIGGER,
		(xdrproc_t) xdr_cli_cache_handle_trigger_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_handle_iedge_cache_pop_1(flags, clnt)
	int flags;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_HANDLE_IEDGE_CACHE_POP,
		(xdrproc_t) xdr_int, (caddr_t) &flags,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_handle_vpn_cache_pop_1(flags, clnt)
	int flags;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_HANDLE_VPN_CACHE_POP,
		(xdrproc_t) xdr_int, (caddr_t) &flags,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_handle_vpng_cache_pop_1(flags, clnt)
	int flags;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_HANDLE_VPNG_CACHE_POP,
		(xdrproc_t) xdr_int, (caddr_t) &flags,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_handle_cp_cache_pop_1(flags, clnt)
	int flags;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_HANDLE_CP_CACHE_POP,
		(xdrproc_t) xdr_int, (caddr_t) &flags,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_handle_cr_cache_pop_1(flags, clnt)
	int flags;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_HANDLE_CR_CACHE_POP,
		(xdrproc_t) xdr_int, (caddr_t) &flags,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_handle_cpb_cache_pop_1(flags, clnt)
	int flags;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_HANDLE_CPB_CACHE_POP,
		(xdrproc_t) xdr_int, (caddr_t) &flags,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_handle_trigger_cache_pop_1(flags, clnt)
	int flags;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_HANDLE_TRIGGER_CACHE_POP,
		(xdrproc_t) xdr_int, (caddr_t) &flags,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_handle_realm_cache_pop_1(flags, clnt)
	int flags;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_HANDLE_REALM_CACHE_POP,
		(xdrproc_t) xdr_int, (caddr_t) &flags,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_handle_igrp_cache_pop_1(flags, clnt)
	int flags;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_HANDLE_IGRP_CACHE_POP,
		(xdrproc_t) xdr_int, (caddr_t) &flags,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_license_init_1(clnt)
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_LICENSE_INIT,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_license_allocate_1(n, clnt)
	int n;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_LICENSE_ALLOCATE,
		(xdrproc_t) xdr_int, (caddr_t) &n,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_license_release_1(n, clnt)
	int n;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_LICENSE_RELEASE,
		(xdrproc_t) xdr_int, (caddr_t) &n,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_get_lsmem_usedlic_1(clnt)
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_GET_LSMEM_USEDLIC,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_get_lsmem_numlic_1(clnt)
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_GET_LSMEM_NUMLIC,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_get_lsmem_maxcalls_1(clnt)
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_GET_LSMEM_MAXCALLS,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_get_lsmem_maxmrcalls_1(clnt)
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_GET_LSMEM_MAXMRCALLS,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_nlm_init_config_port_1(clnt)
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_NLM_INIT_CONFIG_PORT,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_nlm_get_config_port_1(clnt)
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_NLM_GET_CONFIG_PORT,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_nlm_set_config_port_1(n, clnt)
	int n;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_NLM_SET_CONFIG_PORT,
		(xdrproc_t) xdr_int, (caddr_t) &n,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_nlm_get_vport_1(clnt)
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_NLM_GET_VPORT,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_nlm_get_usedvport_1(clnt)
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_NLM_GET_USEDVPORT,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_nlm_get_usedvport_nolock_1(clnt)
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_NLM_GET_USEDVPORT_NOLOCK,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_nlm_get_mrvport_1(clnt)
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_NLM_GET_MRVPORT,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_nlm_get_usedmrvport_nolock_1(clnt)
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_NLM_GET_USEDMRVPORT_NOLOCK,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_nlm_free_mrvport_1(clnt)
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_NLM_FREE_MRVPORT,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

char **
cli_nlm_get_featurelist_1(clnt)
	CLIENT *clnt;
{
	static char *clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_NLM_GET_FEATURELIST,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_wrapstring, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_sip_enabled_1(clnt)
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_SIP_ENABLED,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_fce_enabled_1(clnt)
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_FCE_ENABLED,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_radius_enabled_1(clnt)
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_RADIUS_ENABLED,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_h323_enabled_1(clnt)
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_H323_ENABLED,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_gen_enabled_1(clnt)
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_GEN_ENABLED,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

CacheRealmEntry_va *
cli_handle_realm_get_bulk_1(clnt)
	CLIENT *clnt;
{
	static CacheRealmEntry_va clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_HANDLE_REALM_GET_BULK,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_CacheRealmEntry_va, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_handle_check_realmid_dup_1(realmid, clnt)
	u_long realmid;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_HANDLE_CHECK_REALMID_DUP,
		(xdrproc_t) xdr_u_long, (caddr_t) &realmid,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_handle_realm_enable_sig_1(rsa, clnt)
	u_long rsa;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_HANDLE_REALM_ENABLE_SIG,
		(xdrproc_t) xdr_u_long, (caddr_t) &rsa,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_handle_realm_disable_sig_1(rsa, clnt)
	u_long rsa;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_HANDLE_REALM_DISABLE_SIG,
		(xdrproc_t) xdr_u_long, (caddr_t) &rsa,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

char **
cli_handle_check_rsa_dup_1(new, old, clnt)
	RealmEntry *new;
	RealmEntry *old;
	CLIENT *clnt;
{
	cli_handle_check_rsa_dup_1_argument arg;
	static char *clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	arg.new = new;
	arg.old = old;
	if (clnt_call(clnt, CLI_HANDLE_CHECK_RSA_DUP,
		(xdrproc_t) xdr_cli_handle_check_rsa_dup_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_wrapstring, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

CacheIgrpInfo_va *
cli_handle_igrp_get_bulk_1(clnt)
	CLIENT *clnt;
{
	static CacheIgrpInfo_va clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_HANDLE_IGRP_GET_BULK,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_CacheIgrpInfo_va, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_handle_igrp_add_calls_1(igrpname, incalls, outcalls, totalcalls, clnt)
	char *igrpname;
	u_int incalls;
	u_int outcalls;
	u_int totalcalls;
	CLIENT *clnt;
{
	cli_handle_igrp_add_calls_1_argument arg;
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	arg.igrpname = igrpname;
	arg.incalls = incalls;
	arg.outcalls = outcalls;
	arg.totalcalls = totalcalls;
	if (clnt_call(clnt, CLI_HANDLE_IGRP_ADD_CALLS,
		(xdrproc_t) xdr_cli_handle_igrp_add_calls_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_handle_igrp_delete_calls_1(igrpname, incalls, outcalls, totalcalls, clnt)
	char *igrpname;
	u_int incalls;
	u_int outcalls;
	u_int totalcalls;
	CLIENT *clnt;
{
	cli_handle_igrp_delete_calls_1_argument arg;
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	arg.igrpname = igrpname;
	arg.incalls = incalls;
	arg.outcalls = outcalls;
	arg.totalcalls = totalcalls;
	if (clnt_call(clnt, CLI_HANDLE_IGRP_DELETE_CALLS,
		(xdrproc_t) xdr_cli_handle_igrp_delete_calls_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

CacheTriggerEntry_va *
cli_handle_trigger_get_bulk_1(clnt)
	CLIENT *clnt;
{
	static CacheTriggerEntry_va clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_HANDLE_TRIGGER_GET_BULK,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_CacheTriggerEntry_va, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_handle_cache_reinstantiate_1(cacheType, clnt)
	int cacheType;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_HANDLE_CACHE_REINSTANTIATE,
		(xdrproc_t) xdr_int, (caddr_t) &cacheType,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

CacheVpnEntry_va *
cli_handle_vpn_get_bulk_1(clnt)
	CLIENT *clnt;
{
	static CacheVpnEntry_va clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_HANDLE_VPN_GET_BULK,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_CacheVpnEntry_va, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

CacheVpnGEntry_va *
cli_handle_vpng_get_bulk_1(clnt)
	CLIENT *clnt;
{
	static CacheVpnGEntry_va clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_HANDLE_VPNG_GET_BULK,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_CacheVpnGEntry_va, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_handle_vpn_sipdomain_change_1(vpn, clnt)
	VpnEntry *vpn;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_HANDLE_VPN_SIPDOMAIN_CHANGE,
		(xdrproc_t) xdr_VpnEntry, (caddr_t) &vpn,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
cli_handle_vpn_prefix_change_1(vpn, clnt)
	VpnEntry *vpn;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	if (clnt_call(clnt, CLI_HANDLE_VPN_PREFIX_CHANGE,
		(xdrproc_t) xdr_VpnEntry, (caddr_t) &vpn,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

CacheCPBEntry_va *
cli_handle_cp_get_bulk_1(clnt)
	CLIENT *clnt;
{
	static CacheCPBEntry_va clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_HANDLE_CP_GET_BULK,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_CacheCPBEntry_va, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

CacheCREntry_va *
cli_handle_cr_get_bulk_1(clnt)
	CLIENT *clnt;
{
	static CacheCREntry_va clnt_res;

	memset((char *)&clnt_res, 0, sizeof (clnt_res));
	 if (clnt_call(clnt, CLI_HANDLE_CR_GET_BULK,
		(xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_CacheCREntry_va, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}
