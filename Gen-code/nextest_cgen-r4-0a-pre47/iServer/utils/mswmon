#!/usr/bin/perl

################################################################################
################################################################################
###
###	MSWmon
###
###	MSW monitor
###	Copyright (C) 2002, NexTone Communications.
################################################################################
################################################################################

## Preliminary
use English;

my $CurrentVersion = sprintf "%vd", $PERL_VERSION;

if ($CurrentVersion lt "5.6")
{
	use lib "/usr/local/nextone/lib/perl5/site_perl/5.005";
}
else
{
	use lib "/usr/local/nextone/lib/perl5/site_perl";
}

#use lib "/usr/local/nextone/lib/perl5/site_perl";

if ($ENV{BASE})
{
	use lib "$ENV{BASE}/lib/perl5/site_perl";
}



use File::Tail;
use Getopt::Std;
use XML::Simple;
use Data::Dumper;
use Sys::Syslog;
use POSIX qw(tmpnam);
use Date::EzDate;
use File::Basename;
use Statistics::Descriptive;

$mProgName = "mswmon";
$mVersion = "v0.11, 11/06/2002";

####################
## Global Variables
####################
@gKey;
@gActions;
@ValArray = ();

########################
## Environment Specific
########################
$MSWEXECPATH = "/usr/local/nextone/bin";

getopts "vhdt:";

if ($opt_v)
{
	PrintVersion ();
	exit 0;
}

if ($opt_h)
{
	PrintHelp ();
	exit 0;
}

$NoDaemon = 0;
if ($opt_d)
{
	$NoDaemon = 1;
}

##
## Parameters
##
$timeparam = 60;	## default of 60 seconds.
if ($opt_t)
{
	$timeparam = $opt_t;
}

## Config file
$ConfigFile = "events.conf";

sub signal_handler ()
{
	$dying = 1;
}

sub reaper ()
{
##	Wait for the child to die.
	my $pid = wait ();
}

##
## Initialize
##
Initialize ();

##
## Parse the XML Config file
##
my $conf = ParseConfigFile ($ConfigFile);

##
## Read the config'd info
##
ReadConfig ($conf);


##
## Daemonize
## based on flag.
##
if ($NoDaemon == 0)
{
	$pid = fork ();
	exit if $pid;
	die "Couldnt fork: $!" unless defined($pid);

	POSIX::setsid() or die "Cant start a new session: $!";
}

$dying = 0;

$SIG{INT} = $SIG{HUP} = $SIG{TERM} = \&signal_handler;
$SIG{CHLD} = \&reaper;

until ($dying)
{

	select (undef, undef, undef, $timeparam);

	##
	## Run the commands
	##
	RunCommands ();

	##
	## Analyze and take actions.
	##
	Analyze ($conf);
}



##
## Subroutines start here.
##

sub Initialize ()
{
	$IngressLeg     = Statistics::Descriptive::Full->new();
	$EgressLeg     = Statistics::Descriptive::Full->new();
}

sub Analyze ($)
{
	my ($conf) 	= @_;
	my $trigger 	= 0;
	my $j;


	for $j (0..$#ValArray)
	{
		my $metric 	= $ValArray[$j]->{val1} - $ValArray[$j]->{val2};
		my $r		= $ValArray[$j]->{conf};
		my $gt_cond 	= $r->{GT}[0];
		my $actions   	= $r->{ACTION};
		my $infer;

		for ($gt_cond)
		{
			s/^\s+\"// ; 
			s/\"\s+$// ; 
		}

		my ($month, $day, $dtime, $host) = GetWhen (" ");

		if ($gt_cond)
		{
			if ($metric > $gt_cond)
			{
				$infer = "Event: -- $key : $metric  GREATER THAN $gt_cond -- on $host occurred at $month"."/"." $day, $dtime";

				$trigger = 1;
			}
		}


	$message = <<eEOF;

$infer

was inferred from:
cli test passive


***********************************************************************
Message generated by $mProgName, $mVersion on $date
***********************************************************************
eEOF


		if ($trigger == 1)
		{
			DoActions ($message, $actions);
		}


	}

}



sub DoActions ($ $)
{
	my ($message, $actionref) = @_;

	my $NotifyFile = './mail.pl -s AlarmReport!';
##	my $MessageFile = tmpnam ();
	my $MessageFile = "tout";
	open (T, "> $MessageFile") or die "unable to open file";

	print T "$message\n";

	close (T);

	my $j;
	for $j (0..$#$actionref)
	{
		for (@$actionref[$j])
		{
			s/^\s+\"// ; 
			s/\"\s+$// ; 
		}
		print "Notification[$j]....@$actionref[$j] \n";
		syslog ('Debug', "Notification[$j]....@$actionref[$j] \n");
		system ("@$actionref[$j]");

	}

}

sub RunCommands ()
{
	my $j;

	my $cwd = `pwd`;
	chop $cwd;
	chdir $MSWEXECPATH;

	my $clitest = "./cli test passive";
	my $clistats = "./cli stats ";

	my @lines = `$clitest`;
	my $res;

	for $j (0..$#ValArray)
	{
		$key = $ValArray[$j]->{gKey};

		if ($key)
		{

			@result = grep (/$key/, @lines);

			## special logic that will eventually be configurable.
			if ($key =~ /nCalls/)
			{
				$res = $result[0];
				if ($res =~ m/\w+ =(\d+)/)
				{
					$ValArray[$j]->{val1} = $1;
				}
				$res = $result[1];
				if ($res =~ m/\w+ =(\d+)/)
				{
					$ValArray[$j]->{val2} = $1;
				}

				$IngressLeg->add_data ($val1);
				$EgressLeg->add_data ($val2);
			}

			if ($key =~ /nmessages/)
			{
				$res = $result[0];
				if ($res =~ m/\w+=\d+, \w+=(\d+)/)
				{
					$ValArray[$j]->{val1} = $1;
				}
				$res = $result[1];
				if ($res =~ m/\w+=\d+, \w+=(\d+)/)
				{
					$ValArray[$j]->{val2} = $1;
				}
			}

			## change back to the original dir
			chdir $cwd;
		}
	}
}




sub PrintHelp ()
{
	print <<eEOF
$mProgName, $mVersion
Options are:
-h                - prints this
-v                - prints out version
-t <time_period>  - time period for monitoring [default is 60 seconds]
-d 		  - do not daemonize (useful for debugging)
eEOF
;
}

sub PrintVersion ()
{
	print "$mProgName, $mVersion \n";
	print "Copyright 2002, NexTone Communications, Inc.\n";
}


##
## Parses given config file and returns hashref pointing to data.
##
sub ParseConfigFile ($)
{
	my ($arg) = @_;
	## Basic engine for doing work.
	##
	my $xs = new XML::Simple();

	## Forcearray changes the whole paradigm.
	my $ref = $xs->XMLin( $arg, forcearray => 1 );

###	For debug only.
###	print Dumper ($ref);

	return $ref;
}


sub ReadConfig ($)
{
	my ($conf) = @_;
	my $qual;
	my $key;
	my $actions;

	my $i = $conf->{EV};
	my $j;

	for $j (0..$#$i)
	{
		$qual      = @$i[$j]->{QUAL}[0];
		$key       = @$i[$j]->{KEY}[0];
		$actions   = @$i[$j]->{ACTION};

		## Clean up what we read.
		for ($key)
		{
			s/^\s+\"// ; 
			s/\"\s+$// ; 
		}

		if ($qual =~ m/mswdesc/)
		{
			if ($key =~ m/nCalls/)
			{
				my %val;
				print "Found key $key \n";
				my $k;
				for $k (@$actions)
				{
					print "Actions are: [$k] \n";
				}

				$val{gKey} = $key;
				$val{gActions} = $actions;
				$val{conf} = @$i[$j];


				push @ValArray, \%val;
			}


			if ($key =~ m/nmessages/)
			{
				my %val;
				print "Found key $key \n";
				my $k;
				for $k (@$actions)
				{
					print "Actions are: [$k] \n";
				}

				$val{gKey} = $key;
				$val{gActions} = $actions;
				$val{conf} = @$i[$j];

				push @ValArray, \%val;
			}

		}

	}
}


sub GetWhen ($)
{
	my ($in) = @_;
	my $month;
	my $day;
	my $dtime;
	my $hostname;

	if ( $in =~ m/^(\w+)\s+(\d+)\s+(\d+:\d+:\d+)\s+(\w+)\s+(\w+\[\d+\]):\s+\[ID\s(\d+)\slocal1\.(\w+)\] (.*)$/ )
	{
		$month = $1;
		$day = $2;
		$dtime = $3;
		$hostname = $4;
		my $gisdesc = $5;
		my $threadid = $6;
		my $debugdesc = $7;
		my $logdesc = $8;

		return ($month, $day, $dtime, $hostname);
	}
	else
	{
		($day, $month) = (localtime)[3,4];
		$month += 1;	## Convert from Unix month to regular month
		$dtime = sprintf("%2d:%2d", (localtime)[2,1]);
		$hostname = `hostname`;
		chop $hostname;

		return ($month, $day, $dtime, $hostname);
	}

}

