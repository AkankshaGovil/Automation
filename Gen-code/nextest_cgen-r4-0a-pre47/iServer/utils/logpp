#!/usr/bin/perl

################################################################################
################################################################################
###
###	logpp
###
###	Log post processor.
###	Copyright (C) 2002, NexTone Communications.
################################################################################
################################################################################

## Preliminary
use English;

my $CurrentVersion = sprintf "%vd", $PERL_VERSION;

if ($CurrentVersion lt "5.6")
{
	use lib "/usr/local/nextone/lib/perl5/site_perl/5.005";
}
else
{
	use lib "/usr/local/nextone/lib/perl5/site_perl";
}

#use lib "/usr/local/nextone/lib/perl5/site_perl";

if ($ENV{BASE})
{
	use lib "$ENV{BASE}/lib/perl5/site_perl";
}


use File::Tail;
use Getopt::Std;
use XML::Simple;
use Data::Dumper;
use Sys::Syslog;
use POSIX qw(tmpnam);

$mProgName = "logpp";
$mVersion = "v0.21a, 06/06/2002";

getopts "vhf:t:";

if ($opt_v)
{
	PrintVersion ();
	exit 0;
}

if ($opt_h)
{
	PrintHelp ();
	exit 0;
}

##
## Parameters
##
$tailparam = 0;
if ($opt_t)
{
	$tailparam = $opt_t;
}

## Config file
$ConfigFile = "logpp.conf";

## Log parser
$LogFile = "/var/adm/iserver.log";

if ($opt_f)
{
	$LogFile = $opt_f;
}



## ReadConfig file

my $conf = ParseConfigFile ($ConfigFile);

## Open logging
openlog ( "ALRM", 'cons,pid', "logpp");



$LogP = File::Tail->new (name       => $LogFile,
			maxinterval => 60,
			adjustafter => 10,
			tail        => $tailparam);
			

my $line;

##
## Loop forever around the given file.
##
while (defined ($line = $LogP->read) )
{

	ProcessLine ($line, $conf);

}


sub ProcessLine ($ $)
{
	my ($in, $conf) = @_;

	##
	## Syslog (iserver.log) format
	##
	if ( $in =~ m/^(\w+)\s+(\d+)\s+(\d+:\d+:\d+)\s+(\w+)\s+(\w+\[\d+\]):\s+\[ID\s(\d+)\slocal1\.(\w+)\] (.*)$/ )
	{
		my $month = $1;
		my $day = $2;
		my $dtime = $3;
		my $hostname = $4;
		my $gisdesc = $5;
		my $threadid = $6;
		my $debugdesc = $7;
		my $logdesc = $8;

#		print "month=$month, day=$day, time=$dtime, host=$hostname, gis=$gisdesc, $dummy, tid=$threadid, debug=$debugdesc, log=$logdesc \n";

		pMonth ($month);
		pDay ($day);
		pDtime ($dtime);
		pHostname ($hostname);
		pGisdesc ($gisdesc);
		pThreadid ($threadid);
		pDebugdesc ($debugdesc);
		pLogdesc ($logdesc, $in, $conf);

	}
	else
	### Not in syslog format. So, we'll assume that it is a freestyle
	### format such as iserverout.log, for instance.
	### We'll still try to process it as a regular log.
	{
		pLogdesc ($in, $in, $conf);
	}
}


sub pMonth ($)
{
	my ($month) = @_;
}

sub pDay ($)
{
	my ($day) = @_;

}

sub pDtime ($)
{
	my ($dtime) = @_;
}

sub pHostname ($)
{
	my ($hostname) = @_;
}


sub pGisdesc ($)
{
	my ($gisdesc) = @_;
}

sub pThreadid ($)
{
	my ($threadid) = @_;
}

sub pDebugdesc ($)
{
	my ($debugdesc) = @_;
}

sub pLogdesc ($ $ $)
{
	my ($logdesc, $line, $conf) = @_;
##
##	if ($logdesc =~ m/NexTone iServer started/)
##	{
##		my ($month, $day, $dtime, $host) = GetWhen ($line);
##		my $infer = "NexTone iServer on $host started at $month $day, $dtime";
##		print "$infer\n";
##
##		DoActionsLogdesc ($logdesc, $line, $infer, $conf);
##	}

	my $i = $conf->{EV};
	my $j;

	for $j (0..$#$i)
	{
		$qual      = @$i[$j]->{QUAL}[0];
		$condition = @$i[$j]->{EQUALS}[0];
		$actions   = @$i[$j]->{ACTION};

		## Clean up what we read.
		for ($condition)
		{
			s/^\s+\"// ; 
			s/\"\s+$// ; 
		}

		if ($qual =~ m/logdesc/)
		{
			if ($logdesc =~ /$condition/)
			{

				my $l = length($logdesc);

				if ($l > 40)
				{
					## If $logdesc is very long, so is $line...
					$logdesc = substr($logdesc, 0, 40);
					$line = substr($line, 0, 40);
				}
				print "Condition match: $condition, $logdesc\n";
				my ($month, $day, $dtime, $host) = GetWhen ($line);
				my $infer = "Event: -- $logdesc -- on $host occurred at $month $day, $dtime";
				print "$infer\n";
				syslog ('Notice', "$infer\n");

				DoActionsLogdesc2 ($logdesc, $line, $infer, $actions);


			}
		}

	}


}


sub DoActionsLogdesc2 ($ $ $ $)
{
	my ($log, $line, $infer, $actionref) = @_;
	my $date = `date`;
	chomp ($date);
	my $message;

$message = <<eEOF;

$infer

was inferred from:
$log

------------------------------------------
More detailed information is given below:
$line

***********************************************************************
Message generated by $mProgName, $mVersion on $date
***********************************************************************
eEOF


	my $NotifyFile = './mail.pl -s AlarmReport!';
##	my $MessageFile = tmpnam ();
	my $MessageFile = "tout";
	open (T, "> $MessageFile") or die "unable to open file";

	print T "$message\n";

	close (T);

	my $j;
	for $j (0..$#$actionref)
	{
		for (@$actionref[$j])
		{
			s/^\s+\"// ; 
			s/\"\s+$// ; 
		}
		print "Notification[$j]....@$actionref[$j] \n";
		syslog ('Debug', "Notification[$j]....@$actionref[$j] \n");
		system ("@$actionref[$j]");

	}

}

##
## Old/original routine
##
sub DoActionsLogdesc ($ $ $)
{
	my ($log, $line, $infer, $conf) = @_;
	my $date = `date`;
	chomp ($date);


my $message;

$message = <<eEOF;

$infer

was inferred from:
$log

------------------------------------------
More detailed information is given below:
$line

***********************************************************************
Message generated by $mProgName, $mVersion on $date
***********************************************************************
eEOF


	my $NotifyFile = './mail.pl -s AlarmReport!';
	my $MessageFile = "tout";
	open (T, "> $MessageFile") or die "unable to open file";

	print T "$message\n";

	close (T);

	print "Doing notification...\n";
	system ("$NotifyFile $MessageFile");

	## second notification
	$NotifyFile = './phone.pl';
	system ("$NotifyFile");

}

sub GetWhen ($)
{
	my ($in) = @_;
	my $month;
	my $day;
	my $dtime;
	my $hostname;

	if ( $in =~ m/^(\w+)\s+(\d+)\s+(\d+:\d+:\d+)\s+(\w+)\s+(\w+\[\d+\]):\s+\[ID\s(\d+)\slocal1\.(\w+)\] (.*)$/ )
	{
		$month = $1;
		$day = $2;
		$dtime = $3;
		$hostname = $4;
		my $gisdesc = $5;
		my $threadid = $6;
		my $debugdesc = $7;
		my $logdesc = $8;

		return ($month, $day, $dtime, $hostname);
	}
	else
	{
		($day, $month) = (localtime)[3,4];
		$month += 1;	## Convert from Unix month to regular month
		$dtime = sprintf("%2d:%2d", (localtime)[2,1]);
		$hostname = `hostname`;
		chop $hostname;

		return ($month, $day, $dtime, $hostname);
	}

}


sub PrintHelp ()
{
	print <<eEOF
$mProgName, $mVersion
Options are:
-f <logfile>      - scan <logfile>
-h                - prints this
-v                - prints out version
eEOF
;
}

sub PrintVersion ()
{
	print "$mProgName, $mVersion \n";
	print "Copyright 2002, NexTone Communications, Inc.\n";
}



##
## Parses given config file and returns hashref pointing to data.
##
sub ParseConfigFile ($)
{
	my ($arg) = @_;
	## Basic engine for doing work.
	##
	my $xs = new XML::Simple();

	## Forcearray changes the whole paradigm.
	my $ref = $xs->XMLin( $arg, forcearray => 1 );

###	For debug only.
###	print Dumper ($ref);

	return $ref;
}

